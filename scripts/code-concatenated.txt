# Concatenated Code from ../components/data-table
# Generated on 2025-04-07T03:02:35.092Z



================================================================================
File: aggregation/functions/basic.ts
================================================================================

    1: /**
    2:  * Basic Aggregation Functions
    3:  * 
    4:  * This module provides fundamental aggregation functions for data tables:
    5:  * - sum: Adds numeric values
    6:  * - avg: Calculates average of numeric values
    7:  * - min: Finds minimum numeric value
    8:  * - max: Finds maximum numeric value
    9:  * - count: Counts rows
   10:  */
   11: 
   12: import { AggregationFunction } from "../types"
   13: import { getNumericValues, calculateMean } from "../utils"
   14: 
   15: /**
   16:  * Calculates the sum of numeric values in a column.
   17:  */
   18: export const sumAggregation: AggregationFunction = (columnId, leafRows) => {
   19:   const values = getNumericValues(columnId, leafRows);
   20:   return values.reduce((sum, value) => sum + value, 0);
   21: }
   22: 
   23: /**
   24:  * Calculates the arithmetic mean (average) of numeric values in a column.
   25:  */
   26: export const avgAggregation: AggregationFunction = (columnId, leafRows) => {
   27:   const values = getNumericValues(columnId, leafRows);
   28:   return calculateMean(values);
   29: }
   30: 
   31: /**
   32:  * Finds the minimum numeric value in a column.
   33:  */
   34: export const minAggregation: AggregationFunction = (columnId, leafRows) => {
   35:   const values = getNumericValues(columnId, leafRows);
   36:   return values.length ? Math.min(...values) : null;
   37: }
   38: 
   39: /**
   40:  * Finds the maximum numeric value in a column.
   41:  */
   42: export const maxAggregation: AggregationFunction = (columnId, leafRows) => {
   43:   const values = getNumericValues(columnId, leafRows);
   44:   return values.length ? Math.max(...values) : null;
   45: }
   46: 
   47: /**
   48:  * Counts the number of rows in a group.
   49:  */
   50: export const countAggregation: AggregationFunction = (_, leafRows) => {
   51:   return leafRows.length;
   52: } 

================================================================================
File: aggregation/functions/grouping.ts
================================================================================

    1: /**
    2:  * Grouping Aggregation Functions
    3:  * 
    4:  * This module provides aggregation functions related to grouping and unique values:
    5:  * - unique: Lists unique values
    6:  * - uniqueCount: Counts unique values
    7:  * - mode: Finds most frequent value
    8:  * - range: Creates min-max range representation
    9:  */
   10: 
   11: import { AggregationFunction } from "../types"
   12: import { getNumericValues, getUniqueValuesFromRows } from "../utils"
   13: 
   14: /**
   15:  * Returns an array of unique values from a column.
   16:  */
   17: export const uniqueAggregation: AggregationFunction = (columnId, leafRows) => {
   18:   return getUniqueValuesFromRows(columnId, leafRows);
   19: }
   20: 
   21: /**
   22:  * Counts the number of unique values in a column.
   23:  */
   24: export const uniqueCountAggregation: AggregationFunction = (columnId, leafRows) => {
   25:   const uniqueValues = getUniqueValuesFromRows(columnId, leafRows);
   26:   return uniqueValues.length;
   27: }
   28: 
   29: /**
   30:  * Finds the most frequently occurring value in a column (the statistical mode).
   31:  */
   32: export const modeAggregation: AggregationFunction = (columnId, leafRows) => {
   33:   const countMap = new Map<unknown, number>();
   34:   
   35:   // Count occurrences
   36:   leafRows.forEach(row => {
   37:     const value = row.getValue(columnId);
   38:     if (value !== undefined && value !== null) {
   39:       countMap.set(value, (countMap.get(value) || 0) + 1);
   40:     }
   41:   });
   42:   
   43:   if (countMap.size === 0) return null;
   44:   
   45:   // Find mode (value with highest count)
   46:   return Array.from(countMap.entries())
   47:     .reduce((a, b) => a[1] > b[1] ? a : b)[0];
   48: }
   49: 
   50: /**
   51:  * Creates a range string showing the minimum and maximum values.
   52:  */
   53: export const rangeAggregation: AggregationFunction = (columnId, leafRows) => {
   54:   const values = getNumericValues(columnId, leafRows);
   55:   
   56:   if (!values.length) return null;
   57:   
   58:   const min = Math.min(...values);
   59:   const max = Math.max(...values);
   60:   
   61:   return `${min} - ${max}`;
   62: }
   63: 
   64: /**
   65:  * Returns an array of all underlying values for the column in the group.
   66:  */
   67: export const listAggregation: AggregationFunction = (columnId, leafRows) => {
   68:   return leafRows.map(row => row.getValue(columnId));
   69: }; 

================================================================================
File: aggregation/functions/index.ts
================================================================================

    1: /**
    2:  * Aggregation Functions Index
    3:  * 
    4:  * This module exports all aggregation functions from the categorized modules:
    5:  * - basic: fundamental operations (sum, avg, min, max, count)
    6:  * - statistical: advanced statistical functions (median, stdDev, percentile, etc.)
    7:  * - grouping: functions for working with groups (unique, mode, range)
    8:  * - text: functions for text and sequences (first, last, join)
    9:  */
   10: 
   11: // Export all function categories
   12: export * from './basic'
   13: export * from './statistical'
   14: export * from './grouping'
   15: export * from './text' 

================================================================================
File: aggregation/functions/statistical.ts
================================================================================

    1: /**
    2:  * Statistical Aggregation Functions
    3:  * 
    4:  * This module provides advanced statistical aggregation functions:
    5:  * - median: Calculates the middle value
    6:  * - stdDev: Calculates standard deviation
    7:  * - percentile: Calculates percentiles
    8:  * - weightedAvg: Calculates weighted average
    9:  */
   10: 
   11: import { AggregationFunction, WeightedAvgAggregationConfig, PercentileAggregationConfig } from "../types"
   12: import { getNumericValues, calculateMedian } from "../utils"
   13: 
   14: /**
   15:  * Calculates the median (middle value) of numeric values in a column.
   16:  */
   17: export const medianAggregation: AggregationFunction = (columnId, leafRows) => {
   18:   const values = getNumericValues(columnId, leafRows);
   19:   return calculateMedian(values);
   20: }
   21: 
   22: /**
   23:  * Calculates the population standard deviation of numeric values.
   24:  */
   25: export const stdDevAggregation: AggregationFunction = (columnId, leafRows) => {
   26:   const values = getNumericValues(columnId, leafRows);
   27:   if (!values.length) return null;
   28:   
   29:   // Calculate mean
   30:   const mean = values.reduce((sum, value) => sum + value, 0) / values.length;
   31:   
   32:   // Calculate sum of squared differences
   33:   const squaredDiffs = values.map(value => Math.pow(value - mean, 2));
   34:   const sumSquaredDiffs = squaredDiffs.reduce((sum, value) => sum + value, 0);
   35:   
   36:   // Calculate standard deviation
   37:   return Math.sqrt(sumSquaredDiffs / values.length);
   38: }
   39: 
   40: /**
   41:  * Calculates the specified percentile of numeric values.
   42:  */
   43: export const percentileAggregation: AggregationFunction = (columnId, leafRows, _childRows, config) => {
   44:   const percentile = (config as PercentileAggregationConfig)?.percentile || 50;
   45:   const values = getNumericValues(columnId, leafRows);
   46:   
   47:   if (!values.length) return null;
   48:   
   49:   // Sort values
   50:   values.sort((a, b) => a - b);
   51:   
   52:   // Calculate percentile index
   53:   const index = (percentile / 100) * (values.length - 1);
   54:   const lowerIndex = Math.floor(index);
   55:   const upperIndex = Math.ceil(index);
   56:   
   57:   // Interpolate if needed
   58:   if (lowerIndex === upperIndex) {
   59:     return values[lowerIndex];
   60:   }
   61:   
   62:   const lowerValue = values[lowerIndex];
   63:   const upperValue = values[upperIndex];
   64:   const fraction = index - lowerIndex;
   65:   
   66:   return lowerValue + (upperValue - lowerValue) * fraction;
   67: }
   68: 
   69: /**
   70:  * Calculates a weighted average where each value is multiplied by a weight from another column.
   71:  */
   72: export const weightedAvgAggregation: AggregationFunction = (columnId, leafRows, _childRows, config) => {
   73:   const weightColumnId = (config as WeightedAvgAggregationConfig)?.weightColumnId;
   74:   if (!weightColumnId) {
   75:     return null;
   76:   }
   77: 
   78:   let weightedSum = 0;
   79:   let totalWeight = 0;
   80: 
   81:   leafRows.forEach(row => {
   82:     const value = row.getValue(columnId);
   83:     const weight = row.getValue(weightColumnId);
   84:     
   85:     if (typeof value === 'number' && typeof weight === 'number') {
   86:       weightedSum += value * weight;
   87:       totalWeight += weight;
   88:     }
   89:   });
   90: 
   91:   return totalWeight ? weightedSum / totalWeight : null;
   92: } 

================================================================================
File: aggregation/functions/text.ts
================================================================================

    1: /**
    2:  * Text Aggregation Functions
    3:  * 
    4:  * This module provides aggregation functions for working with text and sequences:
    5:  * - first: Gets the first value in the group
    6:  * - last: Gets the last value in the group
    7:  * - join: Concatenates values with a separator
    8:  */
    9: 
   10: import { AggregationFunction, JoinAggregationConfig } from "../types"
   11: import { safeToString } from "../utils"
   12: 
   13: /**
   14:  * Returns the first value in the group of rows.
   15:  */
   16: export const firstAggregation: AggregationFunction = (columnId, leafRows) => {
   17:   return leafRows.length ? leafRows[0].getValue(columnId) : null;
   18: }
   19: 
   20: /**
   21:  * Returns the last value in the group of rows.
   22:  */
   23: export const lastAggregation: AggregationFunction = (columnId, leafRows) => {
   24:   return leafRows.length ? leafRows[leafRows.length - 1].getValue(columnId) : null;
   25: }
   26: 
   27: /**
   28:  * Joins the values in the column into a single string with a separator.
   29:  */
   30: export const joinAggregation: AggregationFunction = (columnId, leafRows, _childRows, config) => {
   31:   const { separator = ', ', limit } = (config as JoinAggregationConfig) || {};
   32:   
   33:   if (!leafRows.length) return null;
   34:   
   35:   // Get string values from rows
   36:   const values = leafRows.map(row => {
   37:     const value = row.getValue(columnId);
   38:     return value !== null && value !== undefined ? safeToString(value) : '';
   39:   }).filter(Boolean); // Remove empty strings
   40:   
   41:   if (!values.length) return null;
   42:   
   43:   // Apply limit if specified
   44:   const limitedValues = limit ? values.slice(0, limit) : values;
   45:   
   46:   return limitedValues.join(separator);
   47: } 

================================================================================
File: aggregation/index.ts
================================================================================

    1: /**
    2:  * Aggregation Module
    3:  * 
    4:  * This module provides a comprehensive system for aggregating data in tables. It includes:
    5:  * 
    6:  * - Type definitions for aggregation functions
    7:  * - A registry system for managing aggregation functions
    8:  * - Standard and advanced aggregation functions
    9:  * - Utility functions for common operations
   10:  * 
   11:  * The module is designed to work with TanStack Table but can be used independently.
   12:  * It supports both synchronous and asynchronous aggregation operations.
   13:  * 
   14:  * @module aggregation
   15:  */
   16: 
   17: // Export type definitions
   18: export * from './types'
   19: 
   20: // Export registry
   21: export * from './registry'
   22: 
   23: // Export all aggregation functions
   24: export * from './functions'
   25: 
   26: // Export utility functions
   27: export * from './utils'
   28: 
   29: // Import required elements for creating a registry
   30: import { AggregationFunctionRegistry } from './registry'
   31: import {
   32:   // Basic functions
   33:   sumAggregation,
   34:   avgAggregation,
   35:   minAggregation,
   36:   maxAggregation,
   37:   countAggregation,
   38:   
   39:   // Grouping functions
   40:   rangeAggregation,
   41:   uniqueAggregation,
   42:   uniqueCountAggregation,
   43:   modeAggregation,
   44:   listAggregation,
   45:   
   46:   // Statistical functions
   47:   medianAggregation,
   48:   stdDevAggregation,
   49:   percentileAggregation,
   50:   weightedAvgAggregation,
   51:   
   52:   // Text functions
   53:   firstAggregation,
   54:   lastAggregation,
   55:   joinAggregation
   56: } from './functions'
   57: 
   58: /**
   59:  * Creates a new aggregation function registry pre-loaded with standard functions.
   60:  * 
   61:  * @returns {AggregationFunctionRegistry} A new registry instance with standard functions
   62:  * 
   63:  * @example
   64:  * ```ts
   65:  * const registry = createAggregationFunctionRegistry();
   66:  * const sumFn = registry.get('sum');
   67:  * ```
   68:  */
   69: export function createRegistry(): AggregationFunctionRegistry {
   70:   const registry = new AggregationFunctionRegistry()
   71:   
   72:   // Register basic functions
   73:   registry.register('sum', sumAggregation, { label: 'Sum', description: 'Sum of values' })
   74:   registry.register('mean', avgAggregation, { label: 'Average', description: 'Average of values' })
   75:   registry.register('min', minAggregation, { label: 'Minimum', description: 'Minimum value' })
   76:   registry.register('max', maxAggregation, { label: 'Maximum', description: 'Maximum value' })
   77:   registry.register('count', countAggregation, { label: 'Count', description: 'Count of rows' })
   78:   
   79:   // Register grouping functions
   80:   registry.register('range', rangeAggregation, { label: 'Range', description: 'Range of values (min - max)' })
   81:   registry.register('unique', uniqueAggregation, { label: 'Unique Values', description: 'List of unique values' })
   82:   registry.register('uniqueCount', uniqueCountAggregation, { label: 'Unique Count', description: 'Count of unique values' })
   83:   registry.register('mode', modeAggregation, { label: 'Mode', description: 'Most frequent value' })
   84:   registry.register('list', listAggregation, { label: 'List', description: 'List of all values' })
   85:   
   86:   // Register statistical functions
   87:   registry.register('median', medianAggregation, { label: 'Median', description: 'Median value' })
   88:   registry.register('stdDev', stdDevAggregation, { label: 'Standard Deviation', description: 'Standard deviation of values' })
   89:   registry.register('percentile', percentileAggregation, { label: 'Percentile', description: 'Calculate percentile of values' })
   90:   registry.register('weightedAvg', weightedAvgAggregation, { label: 'Weighted Average', description: 'Weighted average based on another column' })
   91:   
   92:   // Register text functions
   93:   registry.register('first', firstAggregation, { label: 'First', description: 'First value in the group' })
   94:   registry.register('last', lastAggregation, { label: 'Last', description: 'Last value in the group' })
   95:   registry.register('join', joinAggregation, { label: 'Join', description: 'Join values with a separator' })
   96:   
   97:   return registry
   98: }
   99: 
  100: // For backward compatibility
  101: export const createAggregationFunctionRegistry = createRegistry
  102: 
  103: // Create and export a default registry instance
  104: export const defaultRegistry = createRegistry()
  105: 
  106: // For backward compatibility
  107: export const getGlobalAggregationFunctionRegistry = () => defaultRegistry 

================================================================================
File: aggregation/registry.ts
================================================================================

    1: /**
    2:  * Aggregation Registry Module
    3:  * 
    4:  * This module provides a registry system for managing aggregation functions.
    5:  * It implements a simplified registry pattern that allows for dynamic 
    6:  * registration and retrieval of aggregation functions.
    7:  */
    8: 
    9: import { AggregationFunction, AggregationFunctionConfig } from "./types"
   10: 
   11: /**
   12:  * Registry class for managing aggregation functions.
   13:  */
   14: export class AggregationFunctionRegistry {
   15:   private registry = new Map<string, {
   16:     fn: AggregationFunction,
   17:     config: AggregationFunctionConfig
   18:   }>();
   19:   
   20:   private defaultFn?: AggregationFunction;
   21: 
   22:   /**
   23:    * Registers a new aggregation function with the registry.
   24:    */
   25:   register(
   26:     type: string,
   27:     fn: AggregationFunction,
   28:     config: AggregationFunctionConfig = {}
   29:   ): AggregationFunctionRegistry {
   30:     if (this.has(type)) {
   31:       console.warn(`Aggregation function "${type}" is already registered. It will be overwritten.`);
   32:     }
   33:     
   34:     this.registry.set(type, { fn, config });
   35:     return this;
   36:   }
   37: 
   38:   /**
   39:    * Sets the default aggregation function to use when a requested function is not found.
   40:    */
   41:   setDefaultFunction(fn: AggregationFunction): AggregationFunctionRegistry {
   42:     this.defaultFn = fn;
   43:     return this;
   44:   }
   45: 
   46:   /**
   47:    * Retrieves an aggregation function by its type.
   48:    */
   49:   get(type: string): AggregationFunction | undefined {
   50:     return this.registry.get(type)?.fn || this.defaultFn;
   51:   }
   52: 
   53:   /**
   54:    * Retrieves the configuration for an aggregation function.
   55:    */
   56:   getConfig(type: string): AggregationFunctionConfig | undefined {
   57:     return this.registry.get(type)?.config;
   58:   }
   59: 
   60:   /**
   61:    * Checks if an aggregation function is registered.
   62:    */
   63:   has(type: string): boolean {
   64:     return this.registry.has(type);
   65:   }
   66: 
   67:   /**
   68:    * Returns an array of all registered aggregation function types.
   69:    */
   70:   getTypes(): string[] {
   71:     return Array.from(this.registry.keys());
   72:   }
   73: 
   74:   /**
   75:    * Removes all registered aggregation functions and configurations.
   76:    */
   77:   clear(): void {
   78:     this.registry.clear();
   79:     this.defaultFn = undefined;
   80:   }
   81: } 

================================================================================
File: aggregation/types.ts
================================================================================

    1: /**
    2:  * Aggregation Types Module
    3:  * 
    4:  * This module defines the core types and interfaces for the aggregation system.
    5:  * It provides a comprehensive type system for:
    6:  * - Aggregation function definitions
    7:  * - Standard and custom aggregation types
    8:  * - Configuration interfaces for different aggregation methods
    9:  */
   10: 
   11: import { Row } from "@tanstack/react-table"
   12: 
   13: /**
   14:  * Interface for aggregation functions that process table data.
   15:  * 
   16:  * Aggregation functions take a set of rows and produce a single aggregated value.
   17:  * They can operate on either leaf rows (rows with no children) or all rows in a group,
   18:  * and can be configured with additional options through the config parameter.
   19:  */
   20: export type AggregationFunction<TData = unknown> = (
   21:   columnId: string,
   22:   leafRows: Row<TData>[],
   23:   childRows: Row<TData>[],
   24:   config?: AggregationFunctionConfig
   25: ) => unknown
   26: 
   27: /**
   28:  * Standard aggregation function types compatible with TanStack Table.
   29:  */
   30: export type StandardAggregationFunctionType = 
   31:   | 'sum'        // Sum values
   32:   | 'min'        // Minimum value
   33:   | 'max'        // Maximum value
   34:   | 'extent'     // Array of min and max
   35:   | 'mean'       // Average (like our 'avg')
   36:   | 'median'     // Median value
   37:   | 'unique'     // Array of unique values
   38:   | 'uniqueCount' // Count of unique values
   39:   | 'count'      // Count of values
   40: 
   41: /**
   42:  * Extended aggregation function types providing additional analytical capabilities.
   43:  */
   44: export type CustomAggregationFunctionType =
   45:   | 'weightedAvg'
   46:   | 'mode'
   47:   | 'stdDev'
   48:   | 'percentile'
   49:   | 'first'
   50:   | 'last'
   51:   | 'join'
   52:   | 'list'
   53: 
   54: /**
   55:  * Union type of all supported aggregation function types.
   56:  */
   57: export type AggregationFunctionType = 
   58:   | StandardAggregationFunctionType 
   59:   | CustomAggregationFunctionType
   60:   | string
   61: 
   62: /**
   63:  * Base configuration interface for aggregation functions.
   64:  */
   65: export interface AggregationFunctionConfig {
   66:   label?: string
   67:   description?: string
   68:   [key: string]: unknown
   69: }
   70: 
   71: /**
   72:  * Configuration for weighted average aggregation.
   73:  */
   74: export interface WeightedAvgAggregationConfig extends AggregationFunctionConfig {
   75:   weightColumnId: string
   76: }
   77: 
   78: /**
   79:  * Configuration for percentile calculations.
   80:  */
   81: export interface PercentileAggregationConfig extends AggregationFunctionConfig {
   82:   percentile: number
   83: }
   84: 
   85: /**
   86:  * Configuration for joining values into a string.
   87:  */
   88: export interface JoinAggregationConfig extends AggregationFunctionConfig {
   89:   separator: string
   90:   limit?: number
   91: }
   92: 
   93: /**
   94:  * Configuration for list aggregation (currently empty, placeholder).
   95:  */
   96: export type ListAggregationConfig = AggregationFunctionConfig; 

================================================================================
File: aggregation/utils.ts
================================================================================

    1: /**
    2:  * Aggregation Utilities Module
    3:  * 
    4:  * This module provides utility functions for common operations used across
    5:  * different aggregation functions, helping to reduce duplication and
    6:  * standardize calculations.
    7:  */
    8: 
    9: import { Row } from "@tanstack/react-table"
   10: import { getUniqueValues as getUniqueValuesFromArray } from "../utils"
   11: 
   12: /**
   13:  * Extracts numeric values from a column in the given rows.
   14:  * Filters out non-numeric values.
   15:  */
   16: export function getNumericValues<TData>(
   17:   columnId: string, 
   18:   rows: Row<TData>[]
   19: ): number[] {
   20:   return rows
   21:     .map(row => row.getValue(columnId))
   22:     .filter((value): value is number => typeof value === 'number');
   23: }
   24: 
   25: /**
   26:  * Calculates the mean (average) of an array of numeric values.
   27:  * Returns null if the array is empty.
   28:  */
   29: export function calculateMean(values: number[]): number | null {
   30:   return values.length ? values.reduce((sum, v) => sum + v, 0) / values.length : null;
   31: }
   32: 
   33: /**
   34:  * Calculates the median of an array of numeric values.
   35:  * Returns null if the array is empty.
   36:  */
   37: export function calculateMedian(values: number[]): number | null {
   38:   if (!values.length) return null;
   39:   
   40:   const sorted = [...values].sort((a, b) => a - b);
   41:   const mid = Math.floor(sorted.length / 2);
   42:   
   43:   return sorted.length % 2 === 0
   44:     ? (sorted[mid - 1] + sorted[mid]) / 2
   45:     : sorted[mid];
   46: }
   47: 
   48: /**
   49:  * Gets the unique values from a column in the given rows.
   50:  * Filters out null and undefined values.
   51:  */
   52: export function getUniqueValuesFromRows<TData>(
   53:   columnId: string, 
   54:   rows: Row<TData>[]
   55: ): unknown[] {
   56:   const allValues: unknown[] = [];
   57:   rows.forEach(row => {
   58:     const value = row.getValue(columnId);
   59:     if (value !== undefined && value !== null) {
   60:       allValues.push(value);
   61:     }
   62:   });
   63:   
   64:   return getUniqueValuesFromArray(allValues);
   65: }
   66: 
   67: /**
   68:  * Safely converts a value to a string representation.
   69:  * Handles null, undefined, and complex objects.
   70:  */
   71: export function safeToString(value: unknown): string {
   72:   if (value === null || value === undefined) {
   73:     return '';
   74:   }
   75:   
   76:   if (typeof value === 'object') {
   77:     try {
   78:       return JSON.stringify(value);
   79:     } catch {
   80:       return Object.prototype.toString.call(value);
   81:     }
   82:   }
   83:   
   84:   return String(value);
   85: } 

================================================================================
File: cell-renderers/defaultRegistry.ts
================================================================================

    1: /**
    2:  * Default Cell Renderer Registry
    3:  *
    4:  * Provides a pre-configured object containing the standard cell renderers
    5:  * for use in schema deserialization or other scenarios where a simple
    6:  * registry is needed without relying on React Context or deprecated globals.
    7:  */
    8: 
    9: import {
   10:     CellRendererFunction
   11:   } from "./types";
   12:   import {
   13:     textRenderer,
   14:     statusRenderer,
   15:     currencyRenderer,
   16:     dateRenderer,
   17:     booleanRenderer,
   18:     nullRenderer,
   19:     decimalRenderer,
   20:     starRatingRenderer,
   21:     sparklineHistogramRenderer
   22:   } from "./renderers";
   23:   
   24:   // Define the structure expected by deserializeSchema
   25:   interface CellRendererRegistryLike {
   26:     get: (type: string) => CellRendererFunction | undefined;
   27:   }
   28:   
   29:   // Create the map of standard renderers
   30:   const standardRenderers: Record<string, CellRendererFunction> = {
   31:     text: textRenderer,
   32:     status: statusRenderer,
   33:     currency: currencyRenderer,
   34:     date: dateRenderer,
   35:     boolean: booleanRenderer,
   36:     null: nullRenderer,
   37:     decimal: decimalRenderer,
   38:     starRating: starRatingRenderer,
   39:     sparklineHistogram: sparklineHistogramRenderer
   40:     // Add other standard renderers if necessary
   41:   };
   42:   
   43:   // Export the registry object conforming to the required interface
   44:   export const defaultCellRendererRegistry: CellRendererRegistryLike = {
   45:     get: (type: string): CellRendererFunction | undefined => {
   46:       return standardRenderers[type];
   47:     }
   48:   };

================================================================================
File: cell-renderers/index.tsx
================================================================================

    1: /**
    2:  * Cell Renderers Module
    3:  * 
    4:  * A comprehensive system for rendering table cell content with different formats and styles.
    5:  * This module implements a simplified approach using React Context and hooks.
    6:  */
    7: 
    8: import * as React from 'react';
    9: import { createContext, useContext, useState } from 'react';
   10: 
   11: // Import types and raw renderer functions for registry
   12: import type { CellRendererProps, CellRendererFunction, BaseRendererConfig } from './types';
   13: import { 
   14:   textRendererFn,
   15:   statusRendererFn,
   16:   currencyRendererFn, 
   17:   dateRendererFn,
   18:   booleanRendererFn,
   19:   nullRendererFn,
   20:   decimalRendererFn,
   21:   starRatingRendererFn,
   22:   sparklineHistogramRendererFn
   23: } from './renderers';
   24: 
   25: // Export for external use
   26: export * from './types';
   27: export * from './renderers';
   28: 
   29: // Context for cell renderers
   30: type CellRendererContextType = {
   31:   getRenderer: (type: string) => CellRendererFunction | undefined;
   32:   registerRenderer: (type: string, renderer: CellRendererFunction) => void;
   33: };
   34: 
   35: const CellRendererContext = createContext<CellRendererContextType | undefined>(undefined);
   36: 
   37: // Global registry (singleton) for backward compatibility
   38: let globalRegistry: Record<string, CellRendererFunction> = {
   39:   // Use the raw function renderers (not wrapped with React.memo)
   40:   text: textRendererFn,
   41:   status: statusRendererFn,
   42:   currency: currencyRendererFn,
   43:   date: dateRendererFn,
   44:   boolean: booleanRendererFn,
   45:   null: nullRendererFn,
   46:   decimal: decimalRendererFn,
   47:   starRating: starRatingRendererFn,
   48:   sparklineHistogram: sparklineHistogramRendererFn
   49: };
   50: 
   51: /**
   52:  * Gets the global renderer registry instance
   53:  * @deprecated Use the React Context API and hooks instead
   54:  */
   55: export function getGlobalCellRendererRegistry() {
   56:   return {
   57:     get: (type: string) => globalRegistry[type],
   58:     register: (type: string, renderer: CellRendererFunction) => {
   59:       globalRegistry[type] = renderer;
   60:     },
   61:     clear: () => {
   62:       globalRegistry = {
   63:         text: textRendererFn,
   64:         status: statusRendererFn,
   65:         currency: currencyRendererFn,
   66:         date: dateRendererFn,
   67:         boolean: booleanRendererFn,
   68:         null: nullRendererFn,
   69:         decimal: decimalRendererFn,
   70:         starRating: starRatingRendererFn,
   71:         sparklineHistogram: sparklineHistogramRendererFn
   72:       };
   73:     }
   74:   };
   75: }
   76: 
   77: /**
   78:  * Provider component for cell renderers
   79:  */
   80: export function CellRendererProvider({ children, initialRenderers = {} }: { 
   81:   children: React.ReactNode; 
   82:   initialRenderers?: Record<string, CellRendererFunction>;
   83: }) {
   84:   const [renderers, setRenderers] = useState<Record<string, CellRendererFunction>>({
   85:     ...globalRegistry,
   86:     ...initialRenderers
   87:   });
   88:   
   89:   const registerRenderer = (type: string, renderer: CellRendererFunction) => {
   90:     setRenderers(prev => ({
   91:       ...prev,
   92:       [type]: renderer
   93:     }));
   94:   };
   95:   
   96:   const getRenderer = (type: string) => renderers[type];
   97:   
   98:   return (
   99:     <CellRendererContext.Provider value={{ getRenderer, registerRenderer }}>
  100:       {children}
  101:     </CellRendererContext.Provider>
  102:   );
  103: }
  104: 
  105: /**
  106:  * Hook to use and register cell renderers
  107:  */
  108: export function useCellRenderers() {
  109:   const context = useContext(CellRendererContext);
  110:   
  111:   if (!context) {
  112:     throw new Error('useCellRenderers must be used within a CellRendererProvider');
  113:   }
  114:   
  115:   return context;
  116: }
  117: 
  118: /**
  119:  * Hook to render a cell with the appropriate renderer
  120:  */
  121: export function useCellRenderer(type: string, defaultRenderer?: CellRendererFunction) {
  122:   const { getRenderer } = useCellRenderers();
  123:   
  124:   return (props: CellRendererProps, config?: BaseRendererConfig) => {
  125:     const renderer = getRenderer(type) || defaultRenderer;
  126:     if (!renderer) {
  127:       console.warn(`No renderer found for type: ${type}`);
  128:       return props.getValue();
  129:     }
  130:     
  131:     return renderer(props, config);
  132:   };
  133: }
  134: 
  135: /**
  136:  * Creates and returns a pre-configured CellRendererProvider with all built-in renderers
  137:  */
  138: export function createDefaultCellRendererProvider(children: React.ReactNode) {
  139:   return (
  140:     <CellRendererProvider 
  141:       initialRenderers={{
  142:         text: textRendererFn,
  143:         status: statusRendererFn,
  144:         currency: currencyRendererFn,
  145:         date: dateRendererFn,
  146:         boolean: booleanRendererFn,
  147:         null: nullRendererFn,
  148:         decimal: decimalRendererFn,
  149:         starRating: starRatingRendererFn,
  150:         sparklineHistogram: sparklineHistogramRendererFn
  151:       }}
  152:     >
  153:       {children}
  154:     </CellRendererProvider>
  155:   );
  156: }
  157: 
  158: export default globalRegistry; 

================================================================================
File: cell-renderers/renderers.tsx
================================================================================

    1: /**
    2:  * Cell Renderers
    3:  * 
    4:  * A collection of cell renderer functions for different data types.
    5:  * Each renderer has a specific purpose and configuration options.
    6:  * All renderers are memoized for optimal performance.
    7:  */
    8: 
    9: import * as React from "react";
   10: import { 
   11:   CellRendererProps, 
   12:   TextRendererConfig,
   13:   StatusRendererConfig,
   14:   CurrencyRendererConfig,
   15:   DateRendererConfig,
   16:   BooleanRendererConfig,
   17:   NullRendererConfig,
   18:   DecimalRendererConfig,
   19:   StarRatingRendererConfig,
   20:   SparklineHistogramRendererConfig
   21: } from "./types";
   22: import { StarRating } from "@/components/ui/star-rating";
   23: import { SparklineHistogram } from "@/components/charts/sparkline-histogram";
   24: 
   25: /**
   26:  * Text Cell Renderer - Raw Function
   27:  */
   28: export function textRendererFn(
   29:   props: CellRendererProps,
   30:   config?: TextRendererConfig
   31: ): React.ReactNode {
   32:   const value = props.getValue();
   33:   const text = String(value || '');
   34:   
   35:   // Handle empty values with a placeholder
   36:   if (!text) return <React.Fragment>-</React.Fragment>;
   37:   
   38:   // Apply truncation if configured
   39:   if (config?.truncate && config?.maxLength && text.length > config.maxLength) {
   40:     return (
   41:       <div className={config?.className} title={text}>
   42:         {text.substring(0, config.maxLength)}...
   43:       </div>
   44:     );
   45:   }
   46:   
   47:   // Render full text
   48:   return config?.className 
   49:     ? <div className={config.className}>{text}</div> 
   50:     : <React.Fragment>{text}</React.Fragment>;
   51: }
   52: 
   53: /**
   54:  * Text Cell Renderer - Memoized Component
   55:  */
   56: export const textRenderer = React.memo(
   57:   textRendererFn,
   58:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
   59:     return prevProps.getValue() === nextProps.getValue();
   60:   }
   61: );
   62: 
   63: /**
   64:  * Status Cell Renderer - Raw Function
   65:  */
   66: export function statusRendererFn(
   67:   props: CellRendererProps,
   68:   config?: StatusRendererConfig
   69: ): React.ReactNode {
   70:   const value = String(props.getValue() || '');
   71:   if (!value) return <React.Fragment>-</React.Fragment>;
   72:   
   73:   const colorMap = config?.colorMap || {
   74:     active: 'green',
   75:     inactive: 'red',
   76:     pending: 'yellow',
   77:     completed: 'blue',
   78:     error: 'red',
   79:   };
   80:   
   81:   const color = colorMap[value.toLowerCase()] || 'gray';
   82:   
   83:   // Status indicator with text
   84:   const content = (
   85:     <React.Fragment>
   86:       <span
   87:         style={{
   88:           display: 'inline-block',
   89:           width: '10px',
   90:           height: '10px',
   91:           borderRadius: '50%',
   92:           backgroundColor: color,
   93:           marginRight: '6px',
   94:         }}
   95:       />
   96:       {value}
   97:     </React.Fragment>
   98:   );
   99:   
  100:   // Only wrap in div if className is provided
  101:   return config?.className 
  102:     ? <div className={config.className}>{content}</div>
  103:     : content;
  104: }
  105: 
  106: /**
  107:  * Status Cell Renderer - Memoized Component
  108:  */
  109: export const statusRenderer = React.memo(
  110:   statusRendererFn,
  111:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
  112:     const prevValue = String(prevProps.getValue() || '').toLowerCase();
  113:     const nextValue = String(nextProps.getValue() || '').toLowerCase();
  114:     return prevValue === nextValue;
  115:   }
  116: );
  117: 
  118: /**
  119:  * Currency Cell Renderer - Raw Function
  120:  */
  121: export function currencyRendererFn(
  122:   props: CellRendererProps,
  123:   config?: CurrencyRendererConfig
  124: ): React.ReactNode {
  125:   const value = props.getValue();
  126:   
  127:   // Handle null/undefined
  128:   if (value === null || value === undefined) {
  129:     return <React.Fragment>-</React.Fragment>;
  130:   }
  131:   
  132:   const numValue = Number(value);
  133:   if (isNaN(numValue)) {
  134:     return <React.Fragment>{String(value)}</React.Fragment>;
  135:   }
  136:   
  137:   const currency = config?.currency || 'USD';
  138:   const locale = config?.locale || 'en-US';
  139:   
  140:   // Format the currency (no useMemo hooks in pure functions)
  141:   const formatted = new Intl.NumberFormat(locale, {
  142:     style: 'currency',
  143:     currency,
  144:     ...config?.options
  145:   }).format(numValue);
  146:   
  147:   // Style based on value
  148:   const color = numValue >= 0 ? config?.positiveColor : config?.negativeColor;
  149:   const style = color ? { color, display: 'inline-block' } : undefined;
  150:   
  151:   // Create content with or without styling
  152:   const content = style 
  153:     ? <span style={style}>{formatted}</span>
  154:     : <React.Fragment>{formatted}</React.Fragment>;
  155:   
  156:   // Only wrap in div if className is provided
  157:   return config?.className 
  158:     ? <div className={config.className}>{content}</div>
  159:     : content;
  160: }
  161: 
  162: /**
  163:  * Currency Cell Renderer - Memoized Component
  164:  */
  165: export const currencyRenderer = React.memo(
  166:   currencyRendererFn,
  167:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
  168:     const prevValue = prevProps.getValue();
  169:     const nextValue = nextProps.getValue();
  170:     
  171:     // If both are null/undefined, they're equal
  172:     if (prevValue == null && nextValue == null) return true;
  173:     
  174:     // If only one is null/undefined, they're not equal
  175:     if (prevValue == null || nextValue == null) return false;
  176:     
  177:     // Convert to numbers for comparison
  178:     const prevNum = Number(prevValue);
  179:     const nextNum = Number(nextValue);
  180:     
  181:     // Handle NaN cases
  182:     if (isNaN(prevNum) && isNaN(nextNum)) {
  183:       return String(prevValue) === String(nextValue);
  184:     }
  185:     if (isNaN(prevNum) || isNaN(nextNum)) return false;
  186:     
  187:     // Compare the actual numbers
  188:     return prevNum === nextNum;
  189:   }
  190: );
  191: 
  192: /**
  193:  * Date Cell Renderer - Raw Function
  194:  */
  195: export function dateRendererFn(
  196:   props: CellRendererProps,
  197:   config?: DateRendererConfig
  198: ): React.ReactNode {
  199:   const value = props.getValue();
  200:   
  201:   // Handle null/undefined
  202:   if (value === null || value === undefined) {
  203:     return <React.Fragment>-</React.Fragment>;
  204:   }
  205:   
  206:   let date: Date;
  207:   
  208:   if (value instanceof Date) {
  209:     date = value;
  210:   } else if (typeof value === 'string' || typeof value === 'number') {
  211:     date = new Date(value);
  212:   } else {
  213:     return <React.Fragment>{String(value)}</React.Fragment>;
  214:   }
  215:   
  216:   if (isNaN(date.getTime())) {
  217:     return <React.Fragment>{String(value)}</React.Fragment>;
  218:   }
  219:   
  220:   const locale = config?.locale || 'en-US';
  221:   const options = config?.options || { 
  222:     dateStyle: 'medium',
  223:   };
  224:   
  225:   // Format the date (no useMemo hooks in pure functions)
  226:   const formatted = new Intl.DateTimeFormat(locale, options).format(date);
  227:   
  228:   return config?.className 
  229:     ? <div className={config.className}>{formatted}</div> 
  230:     : <React.Fragment>{formatted}</React.Fragment>;
  231: }
  232: 
  233: /**
  234:  * Date Cell Renderer - Memoized Component
  235:  */
  236: export const dateRenderer = React.memo(
  237:   dateRendererFn,
  238:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
  239:     const prevValue = prevProps.getValue();
  240:     const nextValue = nextProps.getValue();
  241:     
  242:     // Handle null/undefined cases
  243:     if (prevValue == null && nextValue == null) return true;
  244:     if (prevValue == null || nextValue == null) return false;
  245:     
  246:     // If both are Date objects
  247:     if (prevValue instanceof Date && nextValue instanceof Date) {
  248:       return prevValue.getTime() === nextValue.getTime();
  249:     }
  250:     
  251:     // Convert to date times for comparison
  252:     let prevDate: number, nextDate: number;
  253:     
  254:     try {
  255:       // Only try to convert if the values are valid for Date constructor
  256:       if (typeof prevValue === 'string' || typeof prevValue === 'number' || prevValue instanceof Date) {
  257:         prevDate = new Date(prevValue).getTime();
  258:       } else {
  259:         return String(prevValue) === String(nextValue);
  260:       }
  261:       
  262:       if (typeof nextValue === 'string' || typeof nextValue === 'number' || nextValue instanceof Date) {
  263:         nextDate = new Date(nextValue).getTime();
  264:       } else {
  265:         return String(prevValue) === String(nextValue);
  266:       }
  267:       
  268:       // If either is invalid date
  269:       if (isNaN(prevDate) || isNaN(nextDate)) {
  270:         return String(prevValue) === String(nextValue);
  271:       }
  272:       
  273:       return prevDate === nextDate;
  274:     } catch {
  275:       // If conversion fails, compare as strings
  276:       return String(prevValue) === String(nextValue);
  277:     }
  278:   }
  279: );
  280: 
  281: /**
  282:  * Boolean Cell Renderer - Raw Function
  283:  */
  284: export function booleanRendererFn(
  285:   props: CellRendererProps,
  286:   config?: BooleanRendererConfig
  287: ): React.ReactNode {
  288:   const value = props.getValue();
  289:   
  290:   // Handle null/undefined
  291:   if (value === null || value === undefined) {
  292:     return <React.Fragment>-</React.Fragment>;
  293:   }
  294:   
  295:   const boolValue = Boolean(value);
  296:   
  297:   const yesText = config?.yesText || 'Yes';
  298:   const noText = config?.noText || 'No';
  299:   const yesIcon = config?.yesIcon || '✓';
  300:   const noIcon = config?.noIcon || '✗';
  301:   
  302:   const content = boolValue ? (
  303:     <React.Fragment>
  304:       {yesIcon} {yesText}
  305:     </React.Fragment>
  306:   ) : (
  307:     <React.Fragment>
  308:       {noIcon} {noText}
  309:     </React.Fragment>
  310:   );
  311:   
  312:   return config?.className 
  313:     ? <div className={config.className}>{content}</div>
  314:     : content;
  315: }
  316: 
  317: /**
  318:  * Boolean Cell Renderer - Memoized Component
  319:  */
  320: export const booleanRenderer = React.memo(
  321:   booleanRendererFn,
  322:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
  323:     const prevValue = prevProps.getValue();
  324:     const nextValue = nextProps.getValue();
  325:     
  326:     // Handle null/undefined cases
  327:     if (prevValue == null && nextValue == null) return true;
  328:     if (prevValue == null || nextValue == null) return false;
  329:     
  330:     // Compare boolean values
  331:     return Boolean(prevValue) === Boolean(nextValue);
  332:   }
  333: );
  334: 
  335: /**
  336:  * Null Cell Renderer - Raw Function 
  337:  */
  338: export function nullRendererFn(
  339:   props: CellRendererProps,
  340:   config?: NullRendererConfig
  341: ): React.ReactNode {
  342:   const value = props.getValue();
  343:   
  344:   if (value === null || value === undefined || value === '') {
  345:     const placeholder = config?.placeholder || '-';
  346:     return config?.className 
  347:       ? <div className={config.className}>{placeholder}</div>
  348:       : <React.Fragment>{placeholder}</React.Fragment>;
  349:   }
  350:   
  351:   return config?.className 
  352:     ? <div className={config.className}>{String(value)}</div>
  353:     : <React.Fragment>{String(value)}</React.Fragment>;
  354: }
  355: 
  356: /**
  357:  * Null Cell Renderer - Memoized Component
  358:  */
  359: export const nullRenderer = React.memo(
  360:   nullRendererFn,
  361:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
  362:     const prevValue = prevProps.getValue();
  363:     const nextValue = nextProps.getValue();
  364:     
  365:     // Special comparison for null renderer which treats null, undefined and '' as equivalent
  366:     const prevEmpty = prevValue === null || prevValue === undefined || prevValue === '';
  367:     const nextEmpty = nextValue === null || nextValue === undefined || nextValue === '';
  368:     
  369:     if (prevEmpty && nextEmpty) {
  370:       return true;
  371:     }
  372:     
  373:     if (prevEmpty || nextEmpty) return false;
  374:     
  375:     return String(prevValue) === String(nextValue);
  376:   }
  377: );
  378: 
  379: /**
  380:  * Decimal Cell Renderer - Raw Function
  381:  */
  382: export function decimalRendererFn(
  383:   props: CellRendererProps,
  384:   config?: DecimalRendererConfig
  385: ): React.ReactNode {
  386:   const value = props.getValue();
  387:   
  388:   if (value === null || value === undefined) {
  389:     return <React.Fragment>-</React.Fragment>;
  390:   }
  391: 
  392:   const numValue = Number(value);
  393:   if (isNaN(numValue)) {
  394:     return <React.Fragment>{String(value)}</React.Fragment>;
  395:   }
  396: 
  397:   const decimals = config?.decimals ?? 2;
  398:   const useGrouping = config?.thousand_separator ?? true;
  399:   const locale = config?.locale || 'en-US';
  400: 
  401:   // Format the number (no useMemo hooks in pure functions)
  402:   const formatted = new Intl.NumberFormat(locale, {
  403:     minimumFractionDigits: decimals,
  404:     maximumFractionDigits: decimals,
  405:     useGrouping: useGrouping,
  406:   }).format(numValue);
  407: 
  408:   const color = numValue >= 0 ? config?.positiveColor : config?.negativeColor;
  409:   const style = color ? { color } : undefined;
  410: 
  411:   return config?.className 
  412:     ? <div className={config.className} style={style}>{formatted}</div>
  413:     : <span style={style}>{formatted}</span>;
  414: }
  415: 
  416: /**
  417:  * Decimal Cell Renderer - Memoized Component
  418:  */
  419: export const decimalRenderer = React.memo(
  420:   decimalRendererFn,
  421:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
  422:     const prevValue = prevProps.getValue();
  423:     const nextValue = nextProps.getValue();
  424:     
  425:     // Handle null/undefined cases
  426:     if (prevValue == null && nextValue == null) return true;
  427:     if (prevValue == null || nextValue == null) return false;
  428:     
  429:     // Compare numeric values
  430:     const prevNum = Number(prevValue);
  431:     const nextNum = Number(nextValue);
  432:     
  433:     // Handle NaN cases
  434:     if (isNaN(prevNum) && isNaN(nextNum)) {
  435:       return String(prevValue) === String(nextValue);
  436:     }
  437:     if (isNaN(prevNum) || isNaN(nextNum)) return false;
  438:     
  439:     return prevNum === nextNum;
  440:   }
  441: );
  442: 
  443: /**
  444:  * Star Rating Cell Renderer - Raw Function
  445:  */
  446: export function starRatingRendererFn(
  447:   props: CellRendererProps,
  448:   config?: StarRatingRendererConfig
  449: ): React.ReactNode {
  450:   const value = props.getValue();
  451:   
  452:   if (value === null || value === undefined) {
  453:     return <React.Fragment>-</React.Fragment>;
  454:   }
  455: 
  456:   const numValue = Number(value);
  457:   if (isNaN(numValue)) {
  458:     return <React.Fragment>{String(value)}</React.Fragment>;
  459:   }
  460: 
  461:   // The StarRating component is self-contained and doesn't need a wrapper
  462:   // unless a className is provided
  463:   const starRating = (
  464:     <StarRating
  465:       rating={numValue}
  466:       maxRating={config?.maxRating}
  467:       style={{ color: config?.color }}
  468:     />
  469:   );
  470:   
  471:   return config?.className 
  472:     ? <div className={config.className}>{starRating}</div>
  473:     : starRating;
  474: }
  475: 
  476: /**
  477:  * Star Rating Cell Renderer - Memoized Component
  478:  */
  479: export const starRatingRenderer = React.memo(
  480:   starRatingRendererFn,
  481:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
  482:     const prevValue = prevProps.getValue();
  483:     const nextValue = nextProps.getValue();
  484:     
  485:     // Handle null/undefined cases
  486:     if (prevValue == null && nextValue == null) return true;
  487:     if (prevValue == null || nextValue == null) return false;
  488:     
  489:     // Compare numeric values for rating
  490:     const prevNum = Number(prevValue);
  491:     const nextNum = Number(nextValue);
  492:     
  493:     // Handle NaN cases
  494:     if (isNaN(prevNum) && isNaN(nextNum)) {
  495:       return String(prevValue) === String(nextValue);
  496:     }
  497:     if (isNaN(prevNum) || isNaN(nextNum)) return false;
  498:     
  499:     return prevNum === nextNum;
  500:   }
  501: );
  502: 
  503: /**
  504:  * Sparkline Histogram Cell Renderer - Raw Function
  505:  */
  506: export function sparklineHistogramRendererFn(
  507:   props: CellRendererProps,
  508:   config?: SparklineHistogramRendererConfig
  509: ): React.ReactNode {
  510:   const value = props.getValue();
  511:   
  512:   // Handle null/undefined/empty values
  513:   if (!value || !Array.isArray(value)) {
  514:     return <React.Fragment>-</React.Fragment>;
  515:   }
  516:   
  517:   // Convert values to numbers and filter out invalid ones
  518:   const numbers = value
  519:     .map(v => {
  520:       // If v is already a number, use it directly
  521:       if (typeof v === 'number') return v;
  522:       // Try to convert string/other types to number
  523:       const num = Number(v);
  524:       return isNaN(num) ? null : num;
  525:     })
  526:     .filter((v): v is number => v !== null);
  527:     
  528:   if (numbers.length === 0) {
  529:     return <React.Fragment>-</React.Fragment>;
  530:   }
  531:   
  532:   // Note: SparklineHistogram might require a wrapper for proper sizing
  533:   // so we keep it wrapped even without a className
  534:   const histogram = (
  535:     <SparklineHistogram
  536:       data={numbers}
  537:       numBins={config?.numBins}
  538:       height={config?.height}
  539:       width={config?.width}
  540:       barColor={config?.barColor}
  541:       formatTooltipValue={config?.formatTooltipValue}
  542:     />
  543:   );
  544:   
  545:   return config?.className 
  546:     ? <div className={config.className}>{histogram}</div>
  547:     : histogram;
  548: }
  549: 
  550: /**
  551:  * Sparkline Histogram Cell Renderer - Memoized Component
  552:  */
  553: export const sparklineHistogramRenderer = React.memo(
  554:   sparklineHistogramRendererFn,
  555:   (prevProps: CellRendererProps, nextProps: CellRendererProps) => {
  556:     const prevValue = prevProps.getValue();
  557:     const nextValue = nextProps.getValue();
  558:     
  559:     // Handle null/undefined cases
  560:     if (!prevValue && !nextValue) return true;
  561:     if (!prevValue || !nextValue) return false;
  562:     
  563:     // Both must be arrays
  564:     if (!Array.isArray(prevValue) || !Array.isArray(nextValue)) {
  565:       return false;
  566:     }
  567:     
  568:     // Quick length check
  569:     if (prevValue.length !== nextValue.length) {
  570:       return false;
  571:     }
  572:     
  573:     // Check if each element is the same
  574:     const areArraysEqual = prevValue.every((val, index) => {
  575:       if (typeof val === 'number' && typeof nextValue[index] === 'number') {
  576:         return val === nextValue[index];
  577:       }
  578:       return String(val) === String(nextValue[index]);
  579:     });
  580:     
  581:     return areArraysEqual;
  582:   }
  583: ); 

================================================================================
File: cell-renderers/types.tsx
================================================================================

    1: /**
    2:  * Core Types Module
    3:  * 
    4:  * This module defines the fundamental types and interfaces used by the cell renderer system.
    5:  * It provides type definitions for renderer functions, their props, and configuration options.
    6:  */
    7: 
    8: import * as React from "react";
    9: 
   10: /**
   11:  * Base props passed to all cell renderer functions.
   12:  * These props provide access to the cell's value and context.
   13:  * 
   14:  * @property row Optional row context with methods to access row data
   15:  * @property column Optional column context with column identifier
   16:  * @property table Optional table-wide context
   17:  * @property getValue Function to get the current cell's value
   18:  */
   19: export type CellRendererProps = {
   20:   row?: {
   21:     getValue: (columnId: string) => unknown;
   22:     [key: string]: unknown;
   23:   };
   24:   column?: {
   25:     id: string;
   26:     [key: string]: unknown;
   27:   };
   28:   table?: Record<string, unknown>;
   29:   getValue: () => unknown;
   30:   [key: string]: unknown;
   31: };
   32: 
   33: /**
   34:  * Base configuration interface for all renderers.
   35:  * Provides common styling options that all renderers can use.
   36:  * 
   37:  * @property className Optional CSS class name to apply to the rendered element
   38:  */
   39: export interface BaseRendererConfig {
   40:   className?: string;
   41: }
   42: 
   43: /**
   44:  * Configuration options for the text renderer.
   45:  * Controls how text content is displayed and truncated.
   46:  * 
   47:  * @property truncate Whether to truncate text that exceeds maxLength
   48:  * @property maxLength Maximum number of characters before truncation
   49:  */
   50: export interface TextRendererConfig extends BaseRendererConfig {
   51:   truncate?: boolean;
   52:   maxLength?: number;
   53: }
   54: 
   55: /**
   56:  * Configuration options for the status renderer.
   57:  * Maps status values to their display colors.
   58:  * 
   59:  * @property colorMap Object mapping status values to color values
   60:  * @example
   61:  * ```ts
   62:  * {
   63:  *   active: 'green',
   64:  *   inactive: 'red',
   65:  *   pending: 'yellow'
   66:  * }
   67:  * ```
   68:  */
   69: export interface StatusRendererConfig extends BaseRendererConfig {
   70:   colorMap?: Record<string, string>;
   71: }
   72: 
   73: /**
   74:  * Configuration options for the currency renderer.
   75:  * Controls how currency values are formatted.
   76:  * 
   77:  * @property currency ISO 4217 currency code (e.g., 'USD', 'EUR')
   78:  * @property locale BCP 47 language tag for localization
   79:  * @property options Additional Intl.NumberFormat options
   80:  * @property positiveColor Color for positive values (e.g. 'green', '#00ff00')
   81:  * @property negativeColor Color for negative values (e.g. 'red', '#ff0000')
   82:  * 
   83:  * @example
   84:  * ```ts
   85:  * {
   86:  *   currency: 'USD',
   87:  *   locale: 'en-US',
   88:  *   options: { minimumFractionDigits: 2 },
   89:  *   positiveColor: 'green',
   90:  *   negativeColor: 'red'
   91:  * }
   92:  * ```
   93:  */
   94: export interface CurrencyRendererConfig extends BaseRendererConfig {
   95:   currency?: string;
   96:   locale?: string;
   97:   options?: Intl.NumberFormatOptions;
   98:   positiveColor?: string;
   99:   negativeColor?: string;
  100: }
  101: 
  102: /**
  103:  * Configuration options for the date renderer.
  104:  * Controls how dates are formatted and localized.
  105:  * 
  106:  * @property locale BCP 47 language tag for localization
  107:  * @property options Intl.DateTimeFormat options for customizing the format
  108:  * 
  109:  * @example
  110:  * ```ts
  111:  * {
  112:  *   locale: 'en-US',
  113:  *   options: { 
  114:  *     dateStyle: 'full',
  115:  *     timeStyle: 'short'
  116:  *   }
  117:  * }
  118:  * ```
  119:  */
  120: export interface DateRendererConfig extends BaseRendererConfig {
  121:   locale?: string;
  122:   options?: Intl.DateTimeFormatOptions;
  123: }
  124: 
  125: /**
  126:  * Configuration options for the boolean renderer.
  127:  * Customizes how boolean values are displayed.
  128:  * 
  129:  * @property yesText Text to display for true values
  130:  * @property noText Text to display for false values
  131:  * @property yesIcon Icon to display for true values
  132:  * @property noIcon Icon to display for false values
  133:  * 
  134:  * @example
  135:  * ```ts
  136:  * {
  137:  *   yesText: 'Active',
  138:  *   noText: 'Inactive',
  139:  *   yesIcon: '✓',
  140:  *   noIcon: '✗'
  141:  * }
  142:  * ```
  143:  */
  144: export interface BooleanRendererConfig extends BaseRendererConfig {
  145:   yesText?: string;
  146:   noText?: string;
  147:   yesIcon?: string;
  148:   noIcon?: string;
  149: }
  150: 
  151: /**
  152:  * Configuration options for the null renderer.
  153:  * Controls how null or undefined values are displayed.
  154:  * 
  155:  * @property placeholder Text to display for null values
  156:  */
  157: export interface NullRendererConfig extends BaseRendererConfig {
  158:   placeholder?: string;
  159: }
  160: 
  161: /**
  162:  * Function type for cell renderers.
  163:  * Defines the signature that all cell renderer functions must implement.
  164:  * 
  165:  * @template TConfig Type of the configuration object, must extend BaseRendererConfig
  166:  * @param props Props containing cell value and context
  167:  * @param config Optional configuration object
  168:  * @returns React node to render in the cell
  169:  */
  170: export type CellRendererFunction<TConfig extends BaseRendererConfig = BaseRendererConfig> = (
  171:   props: CellRendererProps,
  172:   config?: TConfig
  173: ) => React.ReactNode;
  174: 
  175: /**
  176:  * Renderer Type
  177:  * 
  178:  * Defines the possible types of cell renderers.
  179:  */
  180: export type RendererType = 
  181:   | 'text' 
  182:   | 'status' 
  183:   | 'currency' 
  184:   | 'date' 
  185:   | 'boolean' 
  186:   | 'null'
  187:   | 'decimal'
  188:   | 'starRating'
  189:   | 'sparklineHistogram';
  190: 
  191: /**
  192:  * Renderer Configuration
  193:  * 
  194:  * Defines the configuration options for cell renderers.
  195:  */
  196: export interface RendererConfig {
  197:   text?: TextRendererConfig;
  198:   status?: StatusRendererConfig;
  199:   currency?: CurrencyRendererConfig;
  200:   date?: DateRendererConfig;
  201:   boolean?: BooleanRendererConfig;
  202:   null?: NullRendererConfig;
  203:   decimal?: DecimalRendererConfig;
  204:   starRating?: StarRatingRendererConfig;
  205:   sparklineHistogram?: SparklineHistogramRendererConfig;
  206: }
  207: 
  208: /**
  209:  * Decimal Renderer Configuration
  210:  * 
  211:  * Configuration options for the decimal cell renderer.
  212:  */
  213: export interface DecimalRendererConfig {
  214:   decimals?: number;           // Number of decimal places to display
  215:   thousand_separator?: boolean; // Whether to use thousand separators
  216:   className?: string;          // Optional CSS class for the cell
  217:   locale?: string;             // Optional locale for number formatting
  218:   positiveColor?: string;      // Color for positive values (e.g. 'green', '#00ff00')
  219:   negativeColor?: string;      // Color for negative values (e.g. 'red', '#ff0000')
  220: }
  221: 
  222: /**
  223:  * Configuration options for the star rating renderer.
  224:  * Controls how star ratings are displayed.
  225:  */
  226: export interface StarRatingRendererConfig extends BaseRendererConfig {
  227:   maxRating?: number;          // Maximum rating value (default: 5)
  228:   color?: string;              // Color of the stars (default: '#facc15')
  229: }
  230: 
  231: /**
  232:  * Configuration options for the sparkline histogram renderer.
  233:  * Controls how the histogram is displayed.
  234:  */
  235: export interface SparklineHistogramRendererConfig extends BaseRendererConfig {
  236:   numBins?: number;            // Number of bins for the histogram (default: 10)
  237:   height?: string;             // Height of the chart (default: "h-[50px]")
  238:   width?: string;              // Width of the chart (default: "w-full")
  239:   barColor?: string;           // Color of the bars (default: "hsl(var(--primary))")
  240:   formatTooltipValue?: (value: number) => string; // Optional formatter for bin range values
  241: } 

================================================================================
File: core/aggregated-cell.tsx
================================================================================

    1: "use client"
    2: 
    3: import React from "react"
    4: import { Cell, Row } from "@tanstack/react-table"
    5: import { getGlobalCellRendererRegistry } from "@/components/data-table/cell-renderers"
    6: import { CellRendererProps } from "@/components/data-table/cell-renderers/types"
    7: import { DataTableColumnDef } from "../types"
    8: 
    9: /**
   10:  * Props for the DataTableAggregatedCell component.
   11:  * 
   12:  * @template TData The type of data in the table rows
   13:  * @property cell The TanStack Table cell instance containing value and context
   14:  */
   15: interface DataTableAggregatedCellProps<TData> {
   16:   cell: Cell<TData, unknown>
   17: }
   18: 
   19: /**
   20:  * A cell component specifically for rendering aggregated cells.
   21:  * 
   22:  * This component uses the `aggregationRenderer` defined in the column's meta
   23:  * configuration to render the aggregated cell content using the cell renderer registry.
   24:  * 
   25:  * @param props The component props
   26:  * @param props.cell The TanStack Table cell instance (should be an aggregated cell)
   27:  * @returns A rendered cell with appropriate content based on aggregation renderer config
   28:  */
   29: export const DataTableAggregatedCell = React.memo(
   30:   function DataTableAggregatedCellInner<TData = unknown>({ cell }: DataTableAggregatedCellProps<TData>) {
   31:     const registry = getGlobalCellRendererRegistry()
   32:     const row = cell.getContext().row as Row<TData>
   33:     const column = cell.column
   34:     
   35:     // Get the column definition with the correct type
   36:     const columnDef = column.columnDef as DataTableColumnDef<TData>
   37:     
   38:     // Get aggregation renderer type and config from column definition
   39:     const rendererType = columnDef.aggregationRenderer?.type || 'text' // Default to text if somehow missing
   40:     const rendererConfig = columnDef.aggregationRenderer?.config || {}
   41:     
   42:     // Get the cell renderer from registry (using the aggregation renderer type)
   43:     const renderer = registry.get(rendererType)
   44:     
   45:     // Prepare props for the renderer
   46:     const rendererProps: CellRendererProps = {
   47:       // Pass row context (though less relevant for aggregated cells typically)
   48:       row: {
   49:         getValue: (columnId: string) => row.getValue(columnId),
   50:         original: row.original,
   51:       },
   52:       column: {
   53:         id: column.id,
   54:       },
   55:       // Use the aggregated value
   56:       getValue: () => cell.getValue(), 
   57:       isAggregated: true, // This cell is always aggregated
   58:       isGrouped: true, // Aggregated cells only appear in grouped rows
   59:       isExpanded: Boolean(row.getIsExpanded && row.getIsExpanded()),
   60:     }
   61:     
   62:     // Render the cell using the appropriate renderer
   63:     if (renderer) {
   64:       return <>{renderer(rendererProps, rendererConfig)}</>
   65:     }
   66:     
   67:     // Fallback to basic text rendering if no renderer found (should ideally not happen)
   68:     return <>{String(cell.getValue() ?? '')}</>
   69:   },
   70:   // Custom comparison function for memoization
   71:   (prevProps, nextProps) => {
   72:     // Compare cell values
   73:     const prevValue = prevProps.cell.getValue();
   74:     const nextValue = nextProps.cell.getValue();
   75:     
   76:     // Get rows to compare expanded state
   77:     const prevRow = prevProps.cell.getContext().row;
   78:     const nextRow = nextProps.cell.getContext().row;
   79:     
   80:     // Check if expanded state is the same
   81:     const expandedEqual = prevRow.getIsExpanded() === nextRow.getIsExpanded();
   82:     
   83:     // Skip re-rendering if values and expanded state are the same
   84:     return prevValue === nextValue && expandedEqual;
   85:   }
   86: ) 

================================================================================
File: core/cell.tsx
================================================================================

    1: "use client"
    2: 
    3: import React from "react"
    4: import { Cell, Row, ColumnDef } from "@tanstack/react-table"
    5: import { getGlobalCellRendererRegistry } from "@/components/data-table/cell-renderers"
    6: 
    7: /**
    8:  * Props for the DataTableCell component.
    9:  * 
   10:  * @template TData The type of data in the table rows
   11:  * @property cell The TanStack Table cell instance containing value and context
   12:  */
   13: interface DataTableCellProps<TData> {
   14:   cell: Cell<TData, unknown>
   15: }
   16: 
   17: // Global registry reference to avoid re-fetching on each render
   18: const cellRendererRegistry = getGlobalCellRendererRegistry();
   19: 
   20: /**
   21:  * A unified cell component that handles rendering of table cells.
   22:  * 
   23:  * This component acts as a smart wrapper around cell rendering, supporting:
   24:  * - Regular cell values
   25:  * - Aggregated values (when using grouping)
   26:  * - Custom cell renderers through a registry system
   27:  * - Grouped and expanded states
   28:  * 
   29:  * The component uses a cell renderer registry to determine how to display cell content.
   30:  * If no specific renderer is defined, it falls back to basic text rendering.
   31:  * 
   32:  * @example
   33:  * ```tsx
   34:  * // Basic usage
   35:  * <DataTableCell cell={cell} />
   36:  * 
   37:  * // With custom renderer in column definition
   38:  * const columns = [{
   39:  *   id: 'status',
   40:  *   cellRenderer: {
   41:  *     type: 'badge',
   42:  *     config: { colors: { active: 'green' } }
   43:  *   }
   44:  * }]
   45:  * ```
   46:  */
   47: export const DataTableCell = React.memo(
   48:   function DataTableCellInner<TData = unknown>({ cell }: DataTableCellProps<TData>) {
   49:     const row = cell.getContext().row as Row<TData>
   50:     const column = cell.column
   51:     const columnDef = column.columnDef as ColumnDef<TData, unknown> & {
   52:       cellRenderer?: { type: string; config?: Record<string, unknown> }
   53:     }
   54:     
   55:     // Get cell renderer type from column definition
   56:     const rendererType = columnDef.cellRenderer?.type || 'text'
   57:     const rendererConfig = columnDef.cellRenderer?.config || {}
   58:     
   59:     // Get the cell renderer from registry - memoized to avoid lookups
   60:     const renderer = React.useMemo(() => {
   61:       return cellRendererRegistry.get(rendererType)
   62:     }, [rendererType])
   63:     
   64:     // Memoize the value extraction to avoid recalculation on re-renders
   65:     const cellValue = React.useMemo(() => cell.getValue(), [cell])
   66:     
   67:     // Get row properties once and memoize them
   68:     const isGrouped = React.useMemo(() => Boolean(row.getIsGrouped()), [row])
   69:     const isExpanded = React.useMemo(() => 
   70:       isGrouped && Boolean(row.getIsExpanded && row.getIsExpanded()), 
   71:       [row, isGrouped]
   72:     )
   73:     const isAggregated = React.useMemo(() => 
   74:       Boolean(row.subRows?.length && isGrouped), 
   75:       [row.subRows?.length, isGrouped]
   76:     )
   77:     
   78:     // Prepare props for the renderer - memoized to prevent unnecessary object creation
   79:     const rendererProps = React.useMemo(() => ({
   80:       row: {
   81:         getValue: (columnId: string) => row.getValue(columnId),
   82:         original: row.original,
   83:       },
   84:       column: {
   85:         id: column.id,
   86:       },
   87:       getValue: () => cellValue,
   88:       isAggregated,
   89:       isGrouped,
   90:       isExpanded,
   91:     }), [row, column.id, cellValue, isAggregated, isGrouped, isExpanded])
   92:     
   93:     // Render the cell using the appropriate renderer
   94:     if (renderer) {
   95:       return <>{renderer(rendererProps, rendererConfig)}</>
   96:     }
   97:     
   98:     // Fallback to basic text rendering if no renderer found - directly use the memoized value
   99:     return <>{String(cellValue ?? '')}</>
  100:   },
  101:   // Custom comparison function to prevent unnecessary re-renders
  102:   (prevProps, nextProps) => {
  103:     // Get values for comparison
  104:     const prevValue = prevProps.cell.getValue();
  105:     const nextValue = nextProps.cell.getValue();
  106:     
  107:     // Get rows for comparison
  108:     const prevRow = prevProps.cell.getContext().row;
  109:     const nextRow = nextProps.cell.getContext().row;
  110:     
  111:     // Compare basic properties
  112:     const valueEqual = prevValue === nextValue;
  113:     const isGroupedEqual = prevRow.getIsGrouped() === nextRow.getIsGrouped();
  114:     
  115:     // Only check expanded state if the row is grouped
  116:     let expandedEqual = true;
  117:     if (prevRow.getIsGrouped() && nextRow.getIsGrouped()) {
  118:       expandedEqual = prevRow.getIsExpanded() === nextRow.getIsExpanded();
  119:     }
  120:     
  121:     // Return true if equal (no need to re-render)
  122:     return valueEqual && isGroupedEqual && expandedEqual;
  123:   }
  124: ) 

================================================================================
File: core/context.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Data Table Context Module
    5:  * 
    6:  * This module implements the state management and context system for the data table.
    7:  * It provides a comprehensive solution for managing:
    8:  * - Table configuration and schema
    9:  * - Data and row models
   10:  * - Sorting state
   11:  * - Filtering (column and global)
   12:  * - Column visibility
   13:  * - Grouping and expansion
   14:  * - Aggregation functions
   15:  * 
   16:  * The implementation uses React Context and TanStack Table's core functionality
   17:  * to provide a powerful yet flexible state management solution.
   18:  * 
   19:  * @module data-table/core/context
   20:  */
   21: 
   22: import * as React from "react"
   23: import {
   24:   getCoreRowModel,
   25:   getFilteredRowModel,
   26:   getPaginationRowModel,
   27:   getSortedRowModel,
   28:   useReactTable,
   29:   getGroupedRowModel,
   30:   getExpandedRowModel,
   31:   // Core States
   32:   SortingState,
   33:   ColumnFiltersState,
   34:   VisibilityState,
   35:   GroupingState,
   36:   ExpandedState,
   37:   ColumnOrderState,
   38:   // Types & Defs
   39:   ColumnDef,
   40:   Table,
   41:   AggregationFnOption,
   42:   Updater,
   43: } from "@tanstack/react-table"
   44: import { DataTableSchema } from "../types"
   45: import { createMultiSelectFilterFn, createDateRangeFilterFn, createBooleanFilterFn } from "../filters"
   46: import { DataTableColumnHeader } from "../parts/column-header"
   47: import { createAggregationFunctionRegistry, getGlobalAggregationFunctionRegistry } from "../aggregation"
   48: 
   49: /**
   50:  * Data Table Context Value Interface
   51:  * 
   52:  * Defines the shape of the context value that will be shared throughout the
   53:  * data table component tree. This interface provides access to:
   54:  * 
   55:  * State:
   56:  * - Table configuration (schema)
   57:  * - Data array
   58:  * - Sorting configuration
   59:  * - Filter states (column and global)
   60:  * - Column visibility settings
   61:  * - Grouping configuration
   62:  * - Expansion state
   63:  * - Aggregation settings
   64:  * 
   65:  * Operations:
   66:  * - State setters for all managed states
   67:  * - Table instance access
   68:  * - Initialization status
   69:  * 
   70:  * @template TData The type of data in the table rows
   71:  */
   72: export interface DataTableContextValue<TData> {
   73:   /** Table configuration schema */
   74:   schema: DataTableSchema<TData>
   75:   /** Array of data items to display */
   76:   data: TData[]
   77:   /** Current sorting state */
   78:   sorting: SortingState
   79:   /** Function to update sorting state */
   80:   setSorting: (sorting: SortingState) => void
   81:   /** Current column filter state */
   82:   columnFilters: ColumnFiltersState
   83:   /** Function to update column filters */
   84:   setColumnFilters: (filters: ColumnFiltersState) => void
   85:   /** Current global filter value */
   86:   globalFilter: string
   87:   /** Function to update global filter */
   88:   setGlobalFilter: (filter: string) => void
   89:   /** Current column visibility state */
   90:   columnVisibility: VisibilityState
   91:   /** Function to update column visibility */
   92:   setColumnVisibility: (updater: Updater<VisibilityState>) => void
   93:   /** Current grouping state */
   94:   grouping: GroupingState
   95:   /** Function to update grouping */
   96:   setGrouping: (grouping: GroupingState) => void
   97:   /** Current row expansion state */
   98:   expanded: ExpandedState
   99:   /** Function to update expansion state */
  100:   setExpanded: (expanded: ExpandedState) => void
  101:   /** TanStack Table instance */
  102:   table: Table<TData>
  103:   /** Whether the table has completed initialization */
  104:   isInitialized: boolean
  105:   /** Function to update column aggregation */
  106:   setColumnAggregation: (columnId: string, aggregationType?: string) => void
  107:   /** Current column aggregation settings */
  108:   columnAggregations: Record<string, string | undefined>
  109:   /** Current column order state */
  110:   columnOrder: ColumnOrderState
  111:   /** Function to update column order */
  112:   setColumnOrder: (order: ColumnOrderState) => void
  113: }
  114: 
  115: /**
  116:  * Data Table Context
  117:  * 
  118:  * React Context instance for the data table state management system.
  119:  * This context is consumed by all data table components to access shared state.
  120:  * 
  121:  * @private
  122:  */
  123: const DataTableContext = React.createContext<DataTableContextValue<unknown> | undefined>(undefined)
  124: 
  125: /**
  126:  * Props for the DataTableProvider component
  127:  * 
  128:  * @template TData The type of data in the table rows
  129:  */
  130: interface DataTableProviderProps<TData> {
  131:   /** Child components that will have access to the context */
  132:   children: React.ReactNode
  133:   /** Table configuration schema */
  134:   schema: DataTableSchema<TData>
  135:   /** Array of data items to display */
  136:   data: TData[]
  137: }
  138: 
  139: /**
  140:  * Data Table Context Provider
  141:  * 
  142:  * This component manages the state and operations for the entire data table.
  143:  * It combines React's Context API with TanStack Table to provide a complete
  144:  * state management solution.
  145:  * 
  146:  * Features:
  147:  * - Automatic aggregation registry initialization
  148:  * - State management for all table features
  149:  * - Custom filter function creation
  150:  * - Column definition processing
  151:  * - Aggregation function management
  152:  * 
  153:  * The provider handles all complex state interactions and provides a clean
  154:  * interface for child components to access and modify table state.
  155:  * 
  156:  * @template TData The type of data in the table rows
  157:  * 
  158:  * @example
  159:  * ```tsx
  160:  * function MyTable({ data }) {
  161:  *   const schema = {
  162:  *     columns: [
  163:  *       { accessorKey: 'name', header: 'Name' },
  164:  *       { accessorKey: 'age', header: 'Age' }
  165:  *     ]
  166:  *   };
  167:  * 
  168:  *   return (
  169:  *     <DataTableProvider schema={schema} data={data}>
  170:  *       <TableContent />
  171:  *     </DataTableProvider>
  172:  *   );
  173:  * }
  174:  * ```
  175:  */
  176: export function DataTableProvider<TData>({
  177:   children,
  178:   schema,
  179:   data,
  180: }: DataTableProviderProps<TData>) {
  181:   // Initialize the registry on the first render
  182:   React.useEffect(() => {
  183:     createAggregationFunctionRegistry();
  184:   }, []);
  185:   
  186:   // Internal state for data to manage reference changes
  187:   const [internalData, setInternalData] = React.useState<TData[]>(data);
  188: 
  189:   // Effect to update internalData when the data prop changes
  190:   React.useEffect(() => {
  191:     setInternalData(data);
  192:   }, [data]);
  193: 
  194:   // Initialize state
  195:   const [sorting, setSorting] = React.useState<SortingState>(schema.defaultSorting || [])
  196:   const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([])
  197:   const [globalFilter, setGlobalFilter] = React.useState<string>("")
  198:   const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>(schema.defaultColumnVisibility || {})
  199:   const [grouping, setGrouping] = React.useState<GroupingState>(schema.defaultGrouping || [])
  200:   const [expanded, setExpanded] = React.useState<ExpandedState>({})
  201:   const [isInitialized, setIsInitialized] = React.useState(false)
  202:   const [columnOrder, setColumnOrder] = React.useState<ColumnOrderState>(schema.defaultColumnOrder || [])
  203:   
  204:   // Create state for column aggregation functions
  205:   const [columnAggregations, setColumnAggregations] = React.useState<Record<string, string | undefined>>({})
  206: 
  207:   // Create filter functions
  208:   const multiSelectFilter = React.useMemo(() => createMultiSelectFilterFn<TData>(), [])
  209:   const dateRangeFilter = React.useMemo(() => createDateRangeFilterFn<TData>(), [])
  210:   const booleanFilter = React.useMemo(() => createBooleanFilterFn<TData>(), [])
  211: 
  212:   // Get the global aggregation registry to access custom aggregation functions
  213:   const aggregationRegistry = React.useMemo(() => getGlobalAggregationFunctionRegistry(), [])
  214: 
  215:   // Create aggregation functions map for TanStack Table
  216:   const customAggregationFns = React.useMemo(() => {
  217:     // eslint-disable-next-line @typescript-eslint/no-explicit-any
  218:     const fns: Record<string, any> = {}
  219:     
  220:     // Define built-in types that TanStack already handles
  221:     const builtInTypes = ['sum', 'min', 'max', 'extent', 'mean', 'median', 'unique', 'uniqueCount', 'count'];
  222:     
  223:     // Get all registered types from the registry that aren't built-in
  224:     const customTypes = aggregationRegistry.getTypes().filter(type => !builtInTypes.includes(type));
  225:     
  226:     // If we can't get types from registry, fall back to our static list
  227:     if (customTypes.length === 0) {
  228:       customTypes.push('first', 'last', 'mode', 'stdDev', 'percentile', 'weightedAvg', 'join');
  229:     }
  230:     
  231:     customTypes.forEach(type => {
  232:       const fn = aggregationRegistry.get(type)
  233:       if (fn) {
  234:         // Create a TanStack compatible aggregation function
  235:         // eslint-disable-next-line @typescript-eslint/no-explicit-any
  236:         fns[type] = (columnId: string, leafRows: any[], childRows: any[]) => {
  237:           // Find the column configuration from schema
  238:           const schemaColumn = schema.columns.find(col => 
  239:             (col.id === columnId) || (col.accessorKey === columnId)
  240:           );
  241:           
  242:           // Get the aggregation config
  243:           const config = schemaColumn?.aggregationRenderer?.config;
  244:           
  245:           // Call our aggregation function with the right parameters
  246:           return fn(columnId, leafRows, childRows, config);
  247:         }
  248:       }
  249:     })
  250:     
  251:     return fns
  252:   }, [aggregationRegistry, schema.columns])
  253: 
  254:   // Initialize column aggregations from schema
  255:   React.useEffect(() => {
  256:     // Create initial aggregations state from schema definitions
  257:     const initialAggregations: Record<string, string | undefined> = {};
  258:     
  259:     schema.columns.forEach(column => {
  260:       const columnId = column.id || column.accessorKey;
  261:       if (columnId && column.aggregationType) {
  262:         initialAggregations[columnId] = column.aggregationType;
  263:       }
  264:     });
  265:     
  266:     // Only set if we found any aggregations to avoid unnecessary renders
  267:     if (Object.keys(initialAggregations).length > 0) {
  268:       setColumnAggregations(initialAggregations);
  269:     }
  270:   }, [schema.columns]);
  271: 
  272:   // Convert our schema columns to ColumnDef format
  273:   const columns = React.useMemo(() => {
  274:     // Process columns and add header component
  275:     return schema.columns.map(column => {
  276:       // Create a new column definition with all properties from the original
  277:       // Destructure to handle properties explicitly
  278:       // eslint-disable-next-line @typescript-eslint/no-unused-vars
  279:       const { aggregationFn, meta, ...restOfColumn } = column;
  280:       const columnDef: Partial<ColumnDef<TData, unknown>> = { ...restOfColumn };
  281: 
  282:       const columnId = column.id || (typeof column.accessorKey === 'string' ? column.accessorKey : undefined);
  283:       
  284:       // If header is a string, replace it with DataTableColumnHeader component
  285:       if (typeof column.header === 'string') {
  286:         const headerText = column.header
  287:         
  288:         // Replace header with DataTableColumnHeader component
  289:         columnDef.header = ({ column: tableColumn }) => (
  290:           <DataTableColumnHeader
  291:             column={tableColumn}
  292:             title={headerText}
  293:           />
  294:         )
  295:       } else {
  296:         // Ensure header is passed if it's not a string (e.g., a custom component)
  297:         columnDef.header = column.header;
  298:       }
  299: 
  300:       // Determine the current aggregation type
  301:       let currentAggregationType: string | undefined = undefined;
  302:       if (columnId && columnAggregations[columnId] !== undefined) {
  303:         currentAggregationType = columnAggregations[columnId];
  304:       } else if (column.aggregationType) {
  305:         currentAggregationType = column.aggregationType;
  306:       }
  307: 
  308:       // Set the aggregation function based on the type
  309:       if (currentAggregationType) {
  310:         // Built-in TanStack aggregation functions can be referenced by string
  311:         const builtInTypes = ['sum', 'min', 'max', 'extent', 'mean', 'median', 'unique', 'uniqueCount', 'count'];
  312:         
  313:         if (builtInTypes.includes(currentAggregationType)) {
  314:           // For built-in types, pass the string directly
  315:           // eslint-disable-next-line @typescript-eslint/no-explicit-any
  316:           columnDef.aggregationFn = currentAggregationType as any;
  317:         } else {
  318:           // For custom types, reference the function by name (TanStack resolves via aggregationFns map)
  319:           // eslint-disable-next-line @typescript-eslint/no-explicit-any
  320:           columnDef.aggregationFn = currentAggregationType as any;
  321:         }
  322:       } else {
  323:         // No aggregation type specified
  324:         columnDef.aggregationFn = undefined;
  325:       }
  326:       
  327:       // Ensure meta includes aggregationConfig and other relevant properties
  328:       columnDef.meta = {
  329:         ...(column.meta || {}), // Preserve original meta from schema
  330:         aggregationRenderer: column.aggregationRenderer,
  331:         alignment: column.alignment, 
  332:         filter: column.filter,
  333:       };
  334:       
  335:       return columnDef as ColumnDef<TData, unknown> // Cast back to full type
  336:     })
  337:   }, [schema.columns, columnAggregations])
  338: 
  339:   // Add forceUpdateCounter to the dependency array of the table options
  340:   const tableOptions = React.useMemo(() => ({
  341:     data: internalData,
  342:     columns,
  343:     getCoreRowModel: getCoreRowModel(),
  344:     // Only use pagination model if explicitly enabled
  345:     ...(schema.enablePagination === true 
  346:       ? { getPaginationRowModel: getPaginationRowModel() } 
  347:       : {}),
  348:     onSortingChange: setSorting,
  349:     getSortedRowModel: getSortedRowModel(),
  350:     onColumnFiltersChange: setColumnFilters,
  351:     getFilteredRowModel: getFilteredRowModel(),
  352:     onGlobalFilterChange: setGlobalFilter,
  353:     onColumnVisibilityChange: setColumnVisibility,
  354:     onGroupingChange: setGrouping,
  355:     getGroupedRowModel: schema.enableGrouping ? getGroupedRowModel() : undefined,
  356:     onExpandedChange: setExpanded,
  357:     onColumnOrderChange: setColumnOrder,
  358:     getExpandedRowModel: getExpandedRowModel(),
  359:     filterFns: {
  360:       multiSelect: multiSelectFilter,
  361:       dateRange: dateRangeFilter,
  362:       boolean: booleanFilter,
  363:     },
  364:     // Register custom aggregation functions with TanStack Table
  365:     aggregationFns: customAggregationFns,
  366:     state: {
  367:       sorting,
  368:       columnFilters,
  369:       globalFilter,
  370:       columnVisibility,
  371:       grouping,
  372:       expanded,
  373:       columnOrder,
  374:       // When pagination is disabled, set the page size to show all data
  375:       ...(schema.enablePagination === true 
  376:         ? {} 
  377:         : { pagination: { pageIndex: 0, pageSize: internalData.length > 10000 ? 10000 : internalData.length || 10 } })
  378:     },
  379:     enableGrouping: schema.enableGrouping,
  380:     enableColumnFilters: true,
  381:     enableSorting: true,
  382:     manualGrouping: !schema.enableGrouping,
  383:     // Only set initialState.pagination if pagination is enabled
  384:     initialState: {
  385:       ...(schema.enablePagination === true ? {
  386:         pagination: {
  387:           pageSize: schema.defaultPageSize || 10,
  388:         }
  389:       } : {})
  390:     },
  391:   }), [
  392:     internalData,
  393:     columns, 
  394:     schema.enablePagination, 
  395:     schema.enableGrouping, 
  396:     schema.defaultPageSize,
  397:     sorting, 
  398:     columnFilters, 
  399:     globalFilter, 
  400:     columnVisibility, 
  401:     grouping, 
  402:     expanded,
  403:     columnOrder,
  404:     multiSelectFilter,
  405:     dateRangeFilter,
  406:     booleanFilter,
  407:     customAggregationFns,
  408:   ]);
  409: 
  410:   // Create table instance using memoized options
  411:   const table = useReactTable(tableOptions);
  412: 
  413:   // Set column aggregation function
  414:   const setColumnAggregation = React.useCallback((columnId: string, aggregationType?: string) => {
  415:     // Update the aggregation state
  416:     setColumnAggregations(prev => {
  417:       const newAggregations = {
  418:         ...prev,
  419:         [columnId]: aggregationType
  420:       };
  421:       return newAggregations;
  422:     });
  423: 
  424:     // Get the column and update its definition
  425:     const column = table.getColumn(columnId);
  426:     if (column) {
  427:       // Update the column definition
  428:       column.columnDef.aggregationFn = aggregationType as AggregationFnOption<TData>;
  429:       
  430:       // Force the table to recalculate with new aggregation
  431:       table.options.state.grouping = [...(table.getState().grouping || [])];
  432:       table.reset();
  433:     }
  434: 
  435:     // Trigger a data reference update
  436:     setInternalData(currentData => [...currentData]);
  437:   }, [table]);
  438: 
  439:   // Mark component as initialized after first render
  440:   React.useEffect(() => {
  441:     setIsInitialized(true)
  442:   }, [])
  443: 
  444:   // Create context value
  445:   const contextValue = React.useMemo<DataTableContextValue<TData>>(() => ({
  446:     schema,
  447:     data,
  448:     sorting,
  449:     setSorting,
  450:     columnFilters,
  451:     setColumnFilters,
  452:     globalFilter,
  453:     setGlobalFilter,
  454:     columnVisibility, 
  455:     setColumnVisibility,
  456:     grouping,
  457:     setGrouping,
  458:     expanded,
  459:     setExpanded,
  460:     columnOrder,
  461:     setColumnOrder,
  462:     table: table as Table<TData>,
  463:     isInitialized,
  464:     setColumnAggregation,
  465:     columnAggregations,
  466:   }), [
  467:     schema,
  468:     data,
  469:     sorting,
  470:     columnFilters,
  471:     globalFilter,
  472:     columnVisibility,
  473:     grouping,
  474:     expanded,
  475:     columnOrder,
  476:     table,
  477:     isInitialized,
  478:     setColumnAggregation,
  479:     columnAggregations,
  480:   ])
  481:   return (
  482:     <DataTableContext.Provider value={contextValue as DataTableContextValue<unknown>}>
  483:       {children}
  484:     </DataTableContext.Provider>
  485:   )
  486: }
  487: 
  488: /**
  489:  * Data Table Hook
  490:  * 
  491:  * A custom hook that provides access to the data table context. This hook
  492:  * enables components to interact with the table state and operations in a
  493:  * type-safe manner.
  494:  * 
  495:  * Features:
  496:  * - Type-safe access to table state
  497:  * - Access to all table operations
  498:  * - Automatic error handling for missing context
  499:  * 
  500:  * @template TData The type of data in the table rows
  501:  * @throws {Error} If used outside of a DataTableProvider
  502:  * 
  503:  * @example
  504:  * ```tsx
  505:  * function TableAction() {
  506:  *   const { sorting, setSorting } = useDataTable<MyDataType>();
  507:  * 
  508:  *   return (
  509:  *     <button onClick={() => setSorting([{ id: 'name', desc: false }])}>
  510:  *       Sort by Name
  511:  *     </button>
  512:  *   );
  513:  * }
  514:  * ```
  515:  */
  516: export function useDataTable<TData>() {
  517:   const context = React.useContext(DataTableContext)
  518:   if (!context) {
  519:     throw new Error("useDataTable must be used within a DataTableProvider")
  520:   }
  521:   return context as DataTableContextValue<TData>
  522: } 

================================================================================
File: core/data-table.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Data Table Component Module
    5:  * 
    6:  * This module provides the main DataTable component implementation, serving as the
    7:  * primary entry point for the data table system. It implements a composable
    8:  * architecture that separates the table's presentation from its state management.
    9:  * 
   10:  * The module consists of two components:
   11:  * 1. DataTable - The main public component that users interact with
   12:  * 2. DataTableContent - An internal component that handles the actual rendering
   13:  * 
   14:  * Key Features:
   15:  * - Schema-based configuration
   16:  * - Context-based state management
   17:  * - Composable structure
   18:  * - Built-in toolbar and pagination
   19:  * - Responsive design
   20:  * - Virtualization for large datasets
   21:  * - Adaptive sizing with ResizeObserver
   22:  * 
   23:  * @module data-table/core/data-table
   24:  */
   25: 
   26: import * as React from "react"
   27: import { DataTableProvider, useDataTable } from "./context"
   28: import { DataTableProps } from "../types"
   29: import { Table } from "@/components/ui/table"
   30: import { TableHeader, TableBody, Toolbar, Pagination } from "../parts"
   31: import { TableBodyComponent } from "../parts/table-body"
   32: import { useAdaptiveColumns } from "../hooks/useAdaptiveColumns"
   33: 
   34: /**
   35:  * Main DataTable component
   36:  * 
   37:  * A flexible and feature-rich data table component that provides a complete
   38:  * solution for displaying and manipulating tabular data. It serves as a facade
   39:  * for the underlying table implementation, handling the integration between
   40:  * the schema configuration, data, and table features.
   41:  * 
   42:  * Features:
   43:  * - Schema-based configuration for columns and behavior
   44:  * - Dynamic data handling with automatic updates
   45:  * - Built-in sorting, filtering, and pagination
   46:  * - Column visibility and ordering
   47:  * - Grouping and aggregation support
   48:  * - Responsive design and accessibility
   49:  * - Virtualization for large datasets
   50:  * 
   51:  * The component uses a provider pattern to manage state, making it easy to
   52:  * extend and customize while maintaining a clean separation of concerns.
   53:  * 
   54:  * @template TData The type of data being displayed in the table
   55:  * 
   56:  * @param props Component properties
   57:  * @param props.schema Configuration schema defining table structure and behavior
   58:  * @param props.data Array of data items to display in the table
   59:  * 
   60:  * @example
   61:  * ```tsx
   62:  * // Basic usage with minimal configuration
   63:  * const schema = {
   64:  *   columns: [
   65:  *     { accessorKey: 'name', header: 'Name' },
   66:  *     { accessorKey: 'age', header: 'Age' }
   67:  *   ]
   68:  * };
   69:  * 
   70:  * const data = [
   71:  *   { name: 'John', age: 30 },
   72:  *   { name: 'Jane', age: 25 }
   73:  * ];
   74:  * 
   75:  * return <DataTable schema={schema} data={data} />;
   76:  * 
   77:  * // Advanced usage with features enabled
   78:  * const advancedSchema = {
   79:  *   columns: [
   80:  *     {
   81:  *       accessorKey: 'name',
   82:  *       header: 'Name',
   83:  *       filter: { type: 'text' }
   84:  *     },
   85:  *     {
   86:  *       accessorKey: 'age',
   87:  *       header: 'Age',
   88:  *       aggregationType: 'average'
   89:  *     }
   90:  *   ],
   91:  *   enablePagination: true,
   92:  *   enableGrouping: true,
   93:  *   defaultPageSize: 25,
   94:  *   enableVirtualization: true  // Enable virtualization for large datasets
   95:  * };
   96:  * 
   97:  * return <DataTable schema={advancedSchema} data={data} />;
   98:  * ```
   99:  */
  100: export function DataTable<TData>({
  101:   schema,
  102:   data,
  103: }: DataTableProps<TData>) {
  104:   return (
  105:     <DataTableProvider schema={schema} data={data}>
  106:       <DataTableContent />
  107:     </DataTableProvider>
  108:   )
  109: }
  110: 
  111: /**
  112:  * Internal DataTable content component
  113:  * 
  114:  * Renders the actual table structure and its associated controls. This component
  115:  * consumes the DataTable context and organizes the table's visual structure.
  116:  * 
  117:  * Layout Structure:
  118:  * 1. Toolbar - Contains table controls and actions
  119:  *    - Column visibility toggles
  120:  *    - Global search
  121:  *    - Custom actions
  122:  * 
  123:  * 2. Table Container - Main data display area
  124:  *    - Responsive border and rounded corners
  125:  *    - Header with sort and filter controls
  126:  *    - Body with data rows and formatting
  127:  *    - Virtualization for large datasets when enabled
  128:  *    - Adaptive sizing based on container dimensions
  129:  * 
  130:  * 3. Pagination - Controls for navigating through data pages
  131:  *    - Page size selection
  132:  *    - Page navigation
  133:  *    - Page information
  134:  * 
  135:  * The component uses a vertical stack layout with consistent spacing and
  136:  * applies styling for a modern, clean appearance.
  137:  * 
  138:  * @private
  139:  */
  140: function DataTableContent() {
  141:   const { table, schema } = useDataTable<unknown>()
  142:   
  143:   // Reference to the table container for size measurements
  144:   const tableContainerRef = React.useRef<HTMLDivElement>(null)
  145:   
  146:   // Determine if we should use virtualization
  147:   const rows = table.getRowModel().rows
  148:   const shouldVirtualize = schema.enableVirtualization !== false && 
  149:                           rows.length > (schema.virtualizationThreshold || 100) &&
  150:                           !schema.enableGrouping; // Don't virtualize when grouping is enabled
  151:                           
  152:   // Setup adaptive columns if enabled
  153:   useAdaptiveColumns(
  154:     table,
  155:     tableContainerRef,
  156:     {
  157:       enabled: schema.enableAdaptiveColumns === true,
  158:       minColumnWidth: schema.minColumnWidth,
  159:       resizeThrottleMs: schema.resizeThrottleMs,
  160:     }
  161:   )
  162:   
  163:   return (
  164:     <div className="space-y-2">
  165:       <Toolbar />
  166:       <div ref={tableContainerRef} className="rounded-md border">
  167:         {shouldVirtualize ? (
  168:           // Use virtualized table body component directly
  169:           <TableBodyComponent />
  170:         ) : (
  171:           // Use standard table with header and body
  172:           <Table>
  173:             <TableHeader />
  174:             <TableBody />
  175:           </Table>
  176:         )}
  177:       </div>
  178:       <Pagination />
  179:     </div>
  180:   )
  181: } 

================================================================================
File: core/index.ts
================================================================================

    1: /**
    2:  * Data Table Core Module
    3:  * 
    4:  * This module defines the core components and context providers
    5:  * for the data table system.
    6:  * 
    7:  * @module data-table/core
    8:  */
    9: 
   10: export * from "./data-table"
   11: export * from "./context"
   12: export * from "./cell"
   13: export * from "./aggregated-cell"
   14: export * from "./worker-data-provider" 

================================================================================
File: core/worker-data-provider.tsx
================================================================================

    1: "use client"
    2: 
    3: import * as React from "react"
    4: import { useTableWorker } from "../hooks/useTableWorker"
    5: import { 
    6:   SortingState, 
    7:   ColumnFiltersState,
    8:   Table,
    9:   ColumnDef,
   10: } from "@tanstack/react-table"
   11: 
   12: interface WorkerDataProviderProps<TData> {
   13:   children: React.ReactNode
   14:   data: TData[]
   15:   table: Table<TData>
   16:   sorting: SortingState
   17:   columnFilters: ColumnFiltersState
   18:   globalFilter: string
   19:   isWorkerEnabled?: boolean
   20:   onDataProcessed?: (processedData: TData[]) => void
   21: }
   22: 
   23: interface WorkerStatusContextValue {
   24:   isProcessing: boolean
   25:   processingTime?: number
   26:   lastOperation?: string
   27:   recordCount?: number
   28:   processedData?: unknown[]
   29: }
   30: 
   31: const WorkerStatusContext = React.createContext<WorkerStatusContextValue>({
   32:   isProcessing: false,
   33: })
   34: 
   35: export const useWorkerStatus = () => React.useContext(WorkerStatusContext)
   36: 
   37: /**
   38:  * Higher-order component that processes data using web workers
   39:  * 
   40:  * This component offloads expensive data operations like sorting and filtering
   41:  * to a web worker, keeping the UI responsive when working with large datasets.
   42:  * 
   43:  * @template TData The type of data being displayed
   44:  */
   45: export function WorkerDataProvider<TData extends Record<string, unknown>>({
   46:   children,
   47:   data,
   48:   table,
   49:   sorting,
   50:   columnFilters,
   51:   globalFilter,
   52:   isWorkerEnabled = true,
   53:   onDataProcessed,
   54: }: WorkerDataProviderProps<TData>) {
   55:   // Reference to the original data
   56:   const originalData = React.useRef<TData[]>(data)
   57:   
   58:   // Track processed data
   59:   const [processedData, setProcessedData] = React.useState<TData[]>(data)
   60:   
   61:   // Get worker functions
   62:   const { processData, isProcessing } = useTableWorker()
   63:   
   64:   // Track processing metrics
   65:   const [processingMetrics, setProcessingMetrics] = React.useState<{
   66:     time?: number
   67:     lastOperation?: string
   68:     recordCount?: number
   69:   }>({})
   70:   
   71:   // Update original data ref when data changes
   72:   React.useEffect(() => {
   73:     originalData.current = data
   74:     // Also reset processed data if needed
   75:     if (!isProcessing) {
   76:       setProcessedData(data)
   77:     }
   78:   }, [data, isProcessing])
   79:   
   80:   // Process data when sorting or filters change
   81:   React.useEffect(() => {
   82:     // Skip if worker is disabled or we have no data
   83:     if (!isWorkerEnabled || originalData.current.length === 0) {
   84:       return
   85:     }
   86:     
   87:     // Build filter array from column filters and global filter
   88:     const filters: Array<{ id: string; value: unknown; type: string }> = []
   89:     
   90:     // Add column filters
   91:     if (columnFilters.length > 0) {
   92:       columnFilters.forEach(filter => {
   93:         const column = table.getColumn(filter.id)
   94:         const columnDef = column?.columnDef as ColumnDef<TData, unknown> & {
   95:           meta?: { filter?: { type: string } }
   96:         }
   97:         const filterType = columnDef?.meta?.filter?.type || 'text'
   98:         
   99:         filters.push({
  100:           id: filter.id,
  101:           value: filter.value,
  102:           type: filterType,
  103:         })
  104:       })
  105:     }
  106:     
  107:     // Add global filter if present
  108:     if (globalFilter) {
  109:       // Apply global filter to all visible text columns
  110:       table.getAllLeafColumns()
  111:         .filter(column => column.getCanFilter())
  112:         .forEach(column => {
  113:           filters.push({
  114:             id: column.id,
  115:             value: globalFilter,
  116:             type: 'text',
  117:           })
  118:         })
  119:     }
  120:     
  121:     // Build sort array
  122:     const sorts = sorting.map(sort => ({
  123:       columnId: sort.id,
  124:       desc: sort.desc,
  125:     }))
  126:     
  127:     // Skip worker if no operations to perform
  128:     if (sorts.length === 0 && filters.length === 0) {
  129:       setProcessedData(originalData.current)
  130:       if (onDataProcessed) {
  131:         onDataProcessed(originalData.current)
  132:       }
  133:       return
  134:     }
  135:     
  136:     // Use the worker to process data
  137:     const processDataWithWorker = async () => {
  138:       try {
  139:         const result = await processData(originalData.current as Record<string, unknown>[], {
  140:           sorts,
  141:           filters,
  142:         })
  143:         
  144:         // Update processed data
  145:         const newProcessedData = result.result as TData[]
  146:         setProcessedData(newProcessedData)
  147:         
  148:         // Call the callback if provided
  149:         if (onDataProcessed) {
  150:           onDataProcessed(newProcessedData)
  151:         }
  152:         
  153:         // Update metrics
  154:         if (result.performance) {
  155:           setProcessingMetrics({
  156:             time: result.performance.totalTime,
  157:             lastOperation: result.operation,
  158:             recordCount: result.performance.recordCount,
  159:           })
  160:         }
  161:       } catch (error) {
  162:         console.error('Error processing data with worker:', error)
  163:         // Fall back to original data
  164:         setProcessedData(originalData.current)
  165:         if (onDataProcessed) {
  166:           onDataProcessed(originalData.current)
  167:         }
  168:       }
  169:     }
  170:     
  171:     processDataWithWorker()
  172:   }, [isWorkerEnabled, sorting, columnFilters, globalFilter, table, processData, onDataProcessed])
  173:   
  174:   // Prepare context value
  175:   const statusContextValue = React.useMemo(() => ({
  176:     isProcessing,
  177:     processingTime: processingMetrics.time,
  178:     lastOperation: processingMetrics.lastOperation,
  179:     recordCount: processingMetrics.recordCount,
  180:     processedData,
  181:   }), [isProcessing, processingMetrics, processedData])
  182:   
  183:   return (
  184:     <WorkerStatusContext.Provider value={statusContextValue}>
  185:       {children}
  186:     </WorkerStatusContext.Provider>
  187:   )
  188: } 

================================================================================
File: filters/components/BooleanFilter.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Boolean Filter Component
    5:  * 
    6:  * A component that provides a boolean selection interface for filtering table data.
    7:  * It allows users to filter table rows based on true/false values using a radio group
    8:  * with visual indicators.
    9:  * 
   10:  * Features:
   11:  * - Radio group selection
   12:  * - Visual indicators (check/x icons)
   13:  * - All/Yes/No options
   14:  * - Real-time filter updates
   15:  * - Consistent styling with the design system
   16:  * 
   17:  * @module data-table/filters/components/BooleanFilter
   18:  */
   19: 
   20: import * as React from "react"
   21: import { Column } from "@tanstack/react-table"
   22: import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group"
   23: import { Label } from "@/components/ui/label"
   24: import { Check, X } from "lucide-react"
   25: import { BooleanFilter } from "../../types"
   26: 
   27: /**
   28:  * Props for the BooleanFilterComponent
   29:  * 
   30:  * @template TData The type of data in the table rows
   31:  */
   32: interface BooleanFilterProps<TData> {
   33:   /** The column instance from TanStack Table */
   34:   column: Column<TData, unknown>
   35:   /** The filter configuration */
   36:   filter: BooleanFilter
   37: }
   38: 
   39: /**
   40:  * Boolean Filter Component
   41:  * 
   42:  * Renders a radio group for filtering table data based on boolean values. The component
   43:  * integrates with TanStack Table's filtering system and provides a user-friendly
   44:  * interface for selecting boolean filter values with visual indicators.
   45:  * 
   46:  * @template TData The type of data in the table rows
   47:  * 
   48:  * @param props Component properties
   49:  * @param props.column The column instance from TanStack Table
   50:  * @param props.filter The filter configuration
   51:  * 
   52:  * @example
   53:  * ```tsx
   54:  * // Basic usage
   55:  * <BooleanFilterComponent
   56:  *   column={column}
   57:  *   filter={{
   58:  *     type: 'boolean'
   59:  *   }}
   60:  * />
   61:  * ```
   62:  */
   63: export function BooleanFilterComponent<TData>({
   64:   column,
   65: }: BooleanFilterProps<TData>) {
   66:   const filterValue = column.getFilterValue() as boolean | undefined
   67:   
   68:   // Convert boolean to string for RadioGroup
   69:   const [booleanValue, setBooleanValue] = React.useState<string>(
   70:     filterValue === undefined ? "all" : filterValue ? "true" : "false"
   71:   )
   72: 
   73:   // Handle when filter value changes externally
   74:   React.useEffect(() => {
   75:     if (filterValue === undefined) {
   76:       setBooleanValue("all")
   77:     } else {
   78:       setBooleanValue(filterValue ? "true" : "false")
   79:     }
   80:   }, [filterValue])
   81: 
   82:   // Apply boolean filter when selection changes
   83:   const handleBooleanFilter = React.useCallback((value: string) => {
   84:     setBooleanValue(value)
   85:     
   86:     if (value === "all") {
   87:       column.setFilterValue(undefined)
   88:     } else {
   89:       column.setFilterValue(value === "true")
   90:     }
   91:   }, [column])
   92: 
   93:   return (
   94:     <RadioGroup 
   95:       value={booleanValue}
   96:       onValueChange={handleBooleanFilter}
   97:       className="flex flex-col gap-2"
   98:     >
   99:       <div className="flex items-center space-x-2">
  100:         <RadioGroupItem value="all" id={`filter-${column.id}-all`} />
  101:         <Label htmlFor={`filter-${column.id}-all`}>All</Label>
  102:       </div>
  103:       <div className="flex items-center space-x-2">
  104:         <RadioGroupItem value="true" id={`filter-${column.id}-true`} />
  105:         <Label htmlFor={`filter-${column.id}-true`} className="flex items-center">
  106:           <Check className="mr-1 h-4 w-4 text-green-600" />
  107:           Yes
  108:         </Label>
  109:       </div>
  110:       <div className="flex items-center space-x-2">
  111:         <RadioGroupItem value="false" id={`filter-${column.id}-false`} />
  112:         <Label htmlFor={`filter-${column.id}-false`} className="flex items-center">
  113:           <X className="mr-1 h-4 w-4 text-red-600" />
  114:           No
  115:         </Label>
  116:       </div>
  117:     </RadioGroup>
  118:   )
  119: } 

================================================================================
File: filters/components/DateRangeFilter.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Date Range Filter Component
    5:  * 
    6:  * A component that provides a date range selection interface for filtering table data.
    7:  * It allows users to select start and end dates to filter table rows within a specific
    8:  * date range.
    9:  * 
   10:  * Features:
   11:  * - Calendar-based date selection
   12:  * - Start and end date inputs
   13:  * - Date formatting
   14:  * - Real-time filter updates
   15:  * - Consistent styling with the design system
   16:  * 
   17:  * @module data-table/filters/components/DateRangeFilter
   18:  */
   19: 
   20: import * as React from "react"
   21: import { Column } from "@tanstack/react-table"
   22: import { format } from "date-fns"
   23: import { Calendar } from "@/components/ui/calendar"
   24: import {
   25:   Popover,
   26:   PopoverContent,
   27:   PopoverTrigger,
   28: } from "@/components/ui/popover"
   29: import { Button } from "@/components/ui/button"
   30: import { CalendarIcon } from "lucide-react"
   31: import { cn } from "@/lib/utils"
   32: import { DateRangeFilter } from "../../types"
   33: 
   34: /**
   35:  * Props for the DateRangeFilterComponent
   36:  * 
   37:  * @template TData The type of data in the table rows
   38:  */
   39: interface DateRangeFilterProps<TData> {
   40:   /** The column instance from TanStack Table */
   41:   column: Column<TData, unknown>
   42:   /** The filter configuration */
   43:   filter: DateRangeFilter
   44: }
   45: 
   46: /**
   47:  * Date Range Filter Component
   48:  * 
   49:  * Renders calendar popovers for selecting start and end dates to filter table data
   50:  * within a date range. The component integrates with TanStack Table's filtering system
   51:  * and provides a user-friendly interface for selecting date ranges.
   52:  * 
   53:  * @template TData The type of data in the table rows
   54:  * 
   55:  * @param props Component properties
   56:  * @param props.column The column instance from TanStack Table
   57:  * @param props.filter The filter configuration
   58:  * 
   59:  * @example
   60:  * ```tsx
   61:  * // Basic usage
   62:  * <DateRangeFilterComponent
   63:  *   column={column}
   64:  *   filter={{
   65:  *     type: 'dateRange',
   66:  *     format: 'yyyy-MM-dd'
   67:  *   }}
   68:  * />
   69:  * ```
   70:  */
   71: export function DateRangeFilterComponent<TData>({
   72:   column,
   73: }: DateRangeFilterProps<TData>) {
   74:   const filterValue = column.getFilterValue() as [string | undefined, string | undefined]
   75:   
   76:   const [fromDate, setFromDate] = React.useState<Date | undefined>(
   77:     filterValue?.[0] ? new Date(filterValue[0]) : undefined
   78:   )
   79:   
   80:   const [toDate, setToDate] = React.useState<Date | undefined>(
   81:     filterValue?.[1] ? new Date(filterValue[1]) : undefined
   82:   )
   83: 
   84:   // Handle when filter value changes externally
   85:   React.useEffect(() => {
   86:     if (filterValue) {
   87:       setFromDate(filterValue[0] ? new Date(filterValue[0]) : undefined)
   88:       setToDate(filterValue[1] ? new Date(filterValue[1]) : undefined)
   89:     } else {
   90:       setFromDate(undefined)
   91:       setToDate(undefined)
   92:     }
   93:   }, [filterValue])
   94: 
   95:   // Apply date range filter when dates change
   96:   const handleDateRangeFilter = React.useCallback(() => {
   97:     // Convert dates to ISO strings for filtering
   98:     const fromStr = fromDate?.toISOString()
   99:     const toStr = toDate?.toISOString()
  100:     
  101:     column.setFilterValue(
  102:       fromStr || toStr 
  103:         ? [fromStr, toStr] 
  104:         : undefined
  105:     )
  106:   }, [fromDate, toDate, column])
  107: 
  108:   return (
  109:     <div className="space-y-2">
  110:       <div className="flex flex-col space-y-1">
  111:         <div className="text-xs text-muted-foreground mb-1">From date</div>
  112:         <Popover>
  113:           <PopoverTrigger asChild>
  114:             <Button
  115:               variant="outline"
  116:               className={cn(
  117:                 "justify-start text-left font-normal h-8",
  118:                 !fromDate && "text-muted-foreground"
  119:               )}
  120:             >
  121:               <CalendarIcon className="mr-2 h-4 w-4" />
  122:               {fromDate ? format(fromDate, "PPP") : "Pick a date"}
  123:             </Button>
  124:           </PopoverTrigger>
  125:           <PopoverContent className="w-auto p-0">
  126:             <Calendar
  127:               mode="single"
  128:               selected={fromDate}
  129:               onSelect={(date) => {
  130:                 setFromDate(date)
  131:                 if (date || toDate) handleDateRangeFilter()
  132:               }}
  133:               initialFocus
  134:             />
  135:           </PopoverContent>
  136:         </Popover>
  137:       </div>
  138:       
  139:       <div className="flex flex-col space-y-1">
  140:         <div className="text-xs text-muted-foreground mb-1">To date</div>
  141:         <Popover>
  142:           <PopoverTrigger asChild>
  143:             <Button
  144:               variant="outline"
  145:               className={cn(
  146:                 "justify-start text-left font-normal h-8",
  147:                 !toDate && "text-muted-foreground"
  148:               )}
  149:             >
  150:               <CalendarIcon className="mr-2 h-4 w-4" />
  151:               {toDate ? format(toDate, "PPP") : "Pick a date"}
  152:             </Button>
  153:           </PopoverTrigger>
  154:           <PopoverContent className="w-auto p-0">
  155:             <Calendar
  156:               mode="single"
  157:               selected={toDate}
  158:               onSelect={(date) => {
  159:                 setToDate(date)
  160:                 if (date || fromDate) handleDateRangeFilter()
  161:               }}
  162:               initialFocus
  163:             />
  164:           </PopoverContent>
  165:         </Popover>
  166:       </div>
  167:     </div>
  168:   )
  169: } 

================================================================================
File: filters/components/MultiSelectFilter.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Multi-Select Filter Component
    5:  * 
    6:  * A component that provides a multiple-value selection interface for filtering table data.
    7:  * It allows users to select multiple options from a predefined list of values to filter
    8:  * the table rows.
    9:  * 
   10:  * Features:
   11:  * - Multiple-value selection
   12:  * - Checkbox-based selection
   13:  * - Clear all functionality
   14:  * - Selected count display
   15:  * - Scrollable options list
   16:  * - Consistent styling with the design system
   17:  * 
   18:  * @module data-table/filters/components/MultiSelectFilter
   19:  */
   20: 
   21: import * as React from "react"
   22: import { Column } from "@tanstack/react-table"
   23: import { Checkbox } from "@/components/ui/checkbox"
   24: import { MultiSelectFilter } from "../../types"
   25: 
   26: /**
   27:  * Props for the MultiSelectFilterComponent
   28:  * 
   29:  * @template TData The type of data in the table rows
   30:  */
   31: interface MultiSelectFilterProps<TData> {
   32:   /** The column instance from TanStack Table */
   33:   column: Column<TData, unknown>
   34:   /** The filter configuration containing options */
   35:   filter: MultiSelectFilter
   36: }
   37: 
   38: /**
   39:  * Multi-Select Filter Component
   40:  * 
   41:  * Renders a list of checkboxes for filtering table data based on multiple selected values.
   42:  * The component integrates with TanStack Table's filtering system and provides a
   43:  * user-friendly interface for selecting multiple filter values.
   44:  * 
   45:  * @template TData The type of data in the table rows
   46:  * 
   47:  * @param props Component properties
   48:  * @param props.column The column instance from TanStack Table
   49:  * @param props.filter The filter configuration containing options
   50:  * 
   51:  * @example
   52:  * ```tsx
   53:  * // Basic usage
   54:  * <MultiSelectFilterComponent
   55:  *   column={column}
   56:  *   filter={{
   57:  *     type: 'multiSelect',
   58:  *     options: [
   59:  *       { value: 'pending', label: 'Pending' },
   60:  *       { value: 'processing', label: 'Processing' },
   61:  *       { value: 'completed', label: 'Completed' }
   62:  *     ]
   63:  *   }}
   64:  * />
   65:  * ```
   66:  */
   67: export function MultiSelectFilterComponent<TData>({
   68:   column,
   69:   filter,
   70: }: MultiSelectFilterProps<TData>) {
   71:   const filterValue = column.getFilterValue() as string[]
   72:   const [selectedValues, setSelectedValues] = React.useState<string[]>(filterValue || [])
   73: 
   74:   // Handle when filter value changes externally
   75:   React.useEffect(() => {
   76:     setSelectedValues(filterValue || [])
   77:   }, [filterValue])
   78: 
   79:   // Handle multi-select checkbox toggle
   80:   const handleMultiSelectToggle = React.useCallback((value: string, checked: boolean) => {
   81:     let newValues: string[]
   82:     
   83:     if (checked) {
   84:       newValues = [...selectedValues, value]
   85:     } else {
   86:       newValues = selectedValues.filter(v => v !== value)
   87:     }
   88:     
   89:     setSelectedValues(newValues)
   90:     column.setFilterValue(newValues.length > 0 ? newValues : undefined)
   91:   }, [selectedValues, column])
   92: 
   93:   return (
   94:     <div className="space-y-1 max-h-[200px] overflow-y-auto pr-1">
   95:       <div className="flex items-center justify-between mb-2">
   96:         <div className="text-xs text-muted-foreground">
   97:           {selectedValues.length} selected
   98:         </div>
   99:         {selectedValues.length > 0 && (
  100:           <button
  101:             onClick={() => {
  102:               setSelectedValues([])
  103:               column.setFilterValue(undefined)
  104:             }}
  105:             className="text-xs text-muted-foreground hover:text-foreground"
  106:           >
  107:             Clear all
  108:           </button>
  109:         )}
  110:       </div>
  111:       {filter.options?.map((option) => (
  112:         <div key={option.value} className="flex items-center space-x-2">
  113:           <Checkbox 
  114:             id={`filter-${column.id}-${option.value}`} 
  115:             checked={selectedValues.includes(option.value)}
  116:             onCheckedChange={(checked) => 
  117:               handleMultiSelectToggle(option.value, checked === true)
  118:             }
  119:           />
  120:           <label 
  121:             htmlFor={`filter-${column.id}-${option.value}`}
  122:             className="text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
  123:           >
  124:             {option.label}
  125:           </label>
  126:         </div>
  127:       ))}
  128:     </div>
  129:   )
  130: } 

================================================================================
File: filters/components/RangeFilter.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Range Filter Component
    5:  * 
    6:  * A component that provides a numeric range selection interface for filtering table data.
    7:  * It allows users to specify minimum and maximum values to filter table rows within a
    8:  * numeric range.
    9:  * 
   10:  * Features:
   11:  * - Minimum and maximum value inputs
   12:  * - Numeric input validation
   13:  * - Real-time filter updates
   14:  * - Keyboard support (Enter key)
   15:  * - Consistent styling with the design system
   16:  * 
   17:  * @module data-table/filters/components/RangeFilter
   18:  */
   19: 
   20: import * as React from "react"
   21: import { Column } from "@tanstack/react-table"
   22: import { Input } from "@/components/ui/input"
   23: import { RangeFilter } from "../../types"
   24: 
   25: /**
   26:  * Props for the RangeFilterComponent
   27:  * 
   28:  * @template TData The type of data in the table rows
   29:  */
   30: interface RangeFilterProps<TData> {
   31:   /** The column instance from TanStack Table */
   32:   column: Column<TData, unknown>
   33:   /** The filter configuration */
   34:   filter: RangeFilter
   35: }
   36: 
   37: /**
   38:  * Range Filter Component
   39:  * 
   40:  * Renders input fields for minimum and maximum values to filter table data within a
   41:  * numeric range. The component integrates with TanStack Table's filtering system and
   42:  * provides a user-friendly interface for specifying range boundaries.
   43:  * 
   44:  * @template TData The type of data in the table rows
   45:  * 
   46:  * @param props Component properties
   47:  * @param props.column The column instance from TanStack Table
   48:  * @param props.filter The filter configuration
   49:  * 
   50:  * @example
   51:  * ```tsx
   52:  * // Basic usage
   53:  * <RangeFilterComponent
   54:  *   column={column}
   55:  *   filter={{
   56:  *     type: 'range'
   57:  *   }}
   58:  * />
   59:  * ```
   60:  */
   61: export function RangeFilterComponent<TData>({
   62:   column,
   63: }: RangeFilterProps<TData>) {
   64:   const filterValue = column.getFilterValue() as [number | undefined, number | undefined]
   65:   const [min, setMin] = React.useState<string>(filterValue?.[0] !== undefined ? String(filterValue[0]) : "")
   66:   const [max, setMax] = React.useState<string>(filterValue?.[1] !== undefined ? String(filterValue[1]) : "")
   67: 
   68:   // Handle when filter value changes externally
   69:   React.useEffect(() => {
   70:     if (filterValue) {
   71:       setMin(filterValue[0] !== undefined ? String(filterValue[0]) : "")
   72:       setMax(filterValue[1] !== undefined ? String(filterValue[1]) : "")
   73:     } else {
   74:       setMin("")
   75:       setMax("")
   76:     }
   77:   }, [filterValue])
   78: 
   79:   // Apply range filter when min or max changes
   80:   const handleRangeFilter = React.useCallback(() => {
   81:     const minVal = min ? Number(min) : undefined
   82:     const maxVal = max ? Number(max) : undefined
   83:     
   84:     column.setFilterValue(
   85:       minVal !== undefined || maxVal !== undefined 
   86:         ? [minVal, maxVal] 
   87:         : undefined
   88:     )
   89:   }, [min, max, column])
   90: 
   91:   return (
   92:     <div className="space-y-2">
   93:       <div className="flex items-center gap-2">
   94:         <Input
   95:           type="number"
   96:           placeholder="Min"
   97:           className="h-8"
   98:           value={min}
   99:           onChange={(e) => setMin(e.target.value)}
  100:           onBlur={handleRangeFilter}
  101:           onKeyDown={(e) => e.key === 'Enter' && handleRangeFilter()}
  102:         />
  103:       </div>
  104:       <div className="flex items-center gap-2">
  105:         <Input
  106:           type="number"
  107:           placeholder="Max"
  108:           className="h-8"
  109:           value={max}
  110:           onChange={(e) => setMax(e.target.value)}
  111:           onBlur={handleRangeFilter}
  112:           onKeyDown={(e) => e.key === 'Enter' && handleRangeFilter()}
  113:         />
  114:       </div>
  115:     </div>
  116:   )
  117: } 

================================================================================
File: filters/components/SelectFilter.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Select Filter Component
    5:  * 
    6:  * A component that provides a single-value selection interface for filtering table data.
    7:  * It allows users to select one option from a predefined list of values to filter the
    8:  * table rows.
    9:  * 
   10:  * Features:
   11:  * - Single-value selection
   12:  * - "All" option to clear filter
   13:  * - Customizable options with labels
   14:  * - Consistent styling with the design system
   15:  * 
   16:  * @module data-table/filters/components/SelectFilter
   17:  */
   18: 
   19: import * as React from "react"
   20: import { Column } from "@tanstack/react-table"
   21: import {
   22:   Select,
   23:   SelectContent,
   24:   SelectItem,
   25:   SelectTrigger,
   26:   SelectValue,
   27: } from "@/components/ui/select"
   28: import { SelectFilter } from "../../types"
   29: 
   30: /**
   31:  * Props for the SelectFilterComponent
   32:  * 
   33:  * @template TData The type of data in the table rows
   34:  */
   35: interface SelectFilterProps<TData> {
   36:   /** The column instance from TanStack Table */
   37:   column: Column<TData, unknown>
   38:   /** The filter configuration containing options */
   39:   filter: SelectFilter
   40: }
   41: 
   42: /**
   43:  * Select Filter Component
   44:  * 
   45:  * Renders a select dropdown for filtering table data based on a single selected value.
   46:  * The component integrates with TanStack Table's filtering system and provides a
   47:  * user-friendly interface for selecting filter values.
   48:  * 
   49:  * @template TData The type of data in the table rows
   50:  * 
   51:  * @param props Component properties
   52:  * @param props.column The column instance from TanStack Table
   53:  * @param props.filter The filter configuration containing options
   54:  * 
   55:  * @example
   56:  * ```tsx
   57:  * // Basic usage
   58:  * <SelectFilterComponent
   59:  *   column={column}
   60:  *   filter={{
   61:  *     type: 'select',
   62:  *     options: [
   63:  *       { value: 'active', label: 'Active' },
   64:  *       { value: 'inactive', label: 'Inactive' }
   65:  *     ]
   66:  *   }}
   67:  * />
   68:  * ```
   69:  */
   70: export function SelectFilterComponent<TData>({
   71:   column,
   72:   filter,
   73: }: SelectFilterProps<TData>) {
   74:   const filterValue = column.getFilterValue() as string
   75: 
   76:   return (
   77:     <Select
   78:       value={filterValue || "_all"}
   79:       onValueChange={(value) => {
   80:         column.setFilterValue(value === "_all" ? undefined : value)
   81:       }}
   82:     >
   83:       <SelectTrigger className="h-8 w-full">
   84:         <SelectValue placeholder="Select..." />
   85:       </SelectTrigger>
   86:       <SelectContent>
   87:         <SelectItem value="_all">All</SelectItem>
   88:         {filter.options?.map((option) => (
   89:           <SelectItem key={option.value} value={option.value}>
   90:             {option.label}
   91:           </SelectItem>
   92:         ))}
   93:       </SelectContent>
   94:     </Select>
   95:   )
   96: } 

================================================================================
File: filters/components/TextFilter.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Text Filter Component
    5:  * 
    6:  * A component that provides a text input filter for filtering table data.
    7:  * It uses debouncing to prevent excessive re-renders while the user is typing.
    8:  * 
    9:  * Features:
   10:  * - Text input for filtering
   11:  * - Debounced input handling for better performance
   12:  * - Case-insensitive filtering
   13:  * - Immediate filtering on Enter key
   14:  * - Consistent styling with the design system
   15:  * 
   16:  * @module data-table/filters/components/TextFilter
   17:  */
   18: 
   19: import * as React from "react"
   20: import { Column } from "@tanstack/react-table"
   21: import { Input } from "@/components/ui/input"
   22: import { TextFilter } from "../../types"
   23: 
   24: /**
   25:  * Props for the TextFilterComponent
   26:  * 
   27:  * @template TData The type of data in the table rows
   28:  */
   29: interface TextFilterProps<TData> {
   30:   /** The column instance from TanStack Table */
   31:   column: Column<TData, unknown>
   32:   /** The filter configuration */
   33:   filter: TextFilter
   34: }
   35: 
   36: /**
   37:  * Text Filter Component
   38:  * 
   39:  * Renders a text input field for filtering table data based on text content.
   40:  * The component integrates with TanStack Table's filtering system and provides
   41:  * a user-friendly interface with debounced input for better performance.
   42:  * 
   43:  * @template TData The type of data in the table rows
   44:  * 
   45:  * @param props Component properties
   46:  * @param props.column The column instance from TanStack Table
   47:  * @param props.filter The filter configuration
   48:  * 
   49:  * @example
   50:  * ```tsx
   51:  * // Basic usage
   52:  * <TextFilterComponent
   53:  *   column={column}
   54:  *   filter={{
   55:  *     type: 'text',
   56:  *     placeholder: 'Search...'
   57:  *   }}
   58:  * />
   59:  * ```
   60:  */
   61: export function TextFilterComponent<TData>({
   62:   column,
   63:   filter,
   64: }: TextFilterProps<TData>) {
   65:   const filterValue = column.getFilterValue() as string
   66:   const [value, setValue] = React.useState<string>(filterValue || "")
   67:   
   68:   // Store timeout ID for debouncing
   69:   const timeoutRef = React.useRef<NodeJS.Timeout | null>(null)
   70: 
   71:   // Handle when filter value changes externally
   72:   React.useEffect(() => {
   73:     setValue(filterValue || "")
   74:   }, [filterValue])
   75:   
   76:   // Clean up timeout on unmount
   77:   React.useEffect(() => {
   78:     return () => {
   79:       if (timeoutRef.current) {
   80:         clearTimeout(timeoutRef.current)
   81:       }
   82:     }
   83:   }, [])
   84: 
   85:   // Handle input change with debouncing
   86:   const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
   87:     const newValue = e.target.value
   88:     setValue(newValue)
   89:     
   90:     // Clear any existing timeout
   91:     if (timeoutRef.current) {
   92:       clearTimeout(timeoutRef.current)
   93:     }
   94:     
   95:     // Set new timeout for the filter update
   96:     timeoutRef.current = setTimeout(() => {
   97:       column.setFilterValue(newValue || undefined)
   98:     }, filter.debounceMs || 300)
   99:   }, [column, filter.debounceMs])
  100: 
  101:   // Apply filter immediately on Enter key
  102:   const handleKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
  103:     if (e.key === 'Enter') {
  104:       // Clear any pending timeout
  105:       if (timeoutRef.current) {
  106:         clearTimeout(timeoutRef.current)
  107:       }
  108:       
  109:       // Apply filter immediately
  110:       column.setFilterValue(value || undefined)
  111:     }
  112:   }, [column, value])
  113: 
  114:   // Return the input directly - no unnecessary wrapper div
  115:   return (
  116:     <Input
  117:       type="text"
  118:       placeholder={filter.placeholder || "Search..."}
  119:       className="h-8"
  120:       value={value}
  121:       onChange={handleInputChange}
  122:       onKeyDown={handleKeyDown}
  123:     />
  124:   )
  125: } 

================================================================================
File: filters/components/index.ts
================================================================================

    1: /**
    2:  * Filter Components Module
    3:  * 
    4:  * This module provides a collection of filter components that implement different
    5:  * filtering interfaces for the data table. Each component is designed to handle
    6:  * a specific type of filtering operation and provides a consistent user interface
    7:  * for filtering table data.
    8:  * 
    9:  * Available Components:
   10:  * - SelectFilterComponent: Single-value selection filter
   11:  * - MultiSelectFilterComponent: Multiple-value selection filter
   12:  * - RangeFilterComponent: Numeric range filter
   13:  * - DateRangeFilterComponent: Date range filter
   14:  * - BooleanFilterComponent: True/False filter
   15:  * - TextFilterComponent: Text search filter with debouncing
   16:  * 
   17:  * Each component is designed to work with TanStack Table's column filtering system
   18:  * and provides a consistent interface for filter state management and user interaction.
   19:  * 
   20:  * @module data-table/filters/components
   21:  */
   22: 
   23: export { SelectFilterComponent } from "./SelectFilter"
   24: export { MultiSelectFilterComponent } from "./MultiSelectFilter"
   25: export { RangeFilterComponent } from "./RangeFilter"
   26: export { DateRangeFilterComponent } from "./DateRangeFilter"
   27: export { BooleanFilterComponent } from "./BooleanFilter"
   28: export { TextFilterComponent } from "./TextFilter" 

================================================================================
File: filters/filter-factory.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Filter Factory Module
    5:  * 
    6:  * This module provides a factory component that dynamically creates the appropriate
    7:  * filter interface based on the column's filter configuration. It serves as a bridge
    8:  * between the table's column configuration and the actual filter components.
    9:  * 
   10:  * The factory handles:
   11:  * - Filter type detection
   12:  * - Component selection
   13:  * - Filter state management
   14:  * - Clear filter functionality
   15:  * 
   16:  * @module data-table/filters/filter-factory
   17:  */
   18: 
   19: import * as React from "react"
   20: import { Column } from "@tanstack/react-table"
   21: import { X } from "lucide-react"
   22: import { 
   23:   ColumnFilter, 
   24:   TextFilter, 
   25:   isSelectFilter, 
   26:   isMultiSelectFilter, 
   27:   isRangeFilter, 
   28:   isDateRangeFilter, 
   29:   isBooleanFilter 
   30: } from "../types"
   31: import {
   32:   SelectFilterComponent,
   33:   MultiSelectFilterComponent,
   34:   RangeFilterComponent,
   35:   DateRangeFilterComponent,
   36:   BooleanFilterComponent,
   37:   TextFilterComponent
   38: } from "./components"
   39: 
   40: /**
   41:  * Props for the FilterFactory component
   42:  * 
   43:  * @template TData The type of data in the table rows
   44:  */
   45: interface FilterFactoryProps<TData> {
   46:   /** The column instance from TanStack Table */
   47:   column: Column<TData, unknown>
   48:   /** The filter configuration for the column */
   49:   filter: ColumnFilter
   50:   /** Whether to show the clear filter button */
   51:   showClearButton?: boolean
   52: }
   53: 
   54: /**
   55:  * Filter Factory Component
   56:  * 
   57:  * A factory component that renders the appropriate filter interface based on
   58:  * the column's filter configuration. It supports various filter types and
   59:  * provides a consistent interface for filter management.
   60:  * 
   61:  * Features:
   62:  * - Dynamic filter component selection
   63:  * - Filter state management
   64:  * - Clear filter functionality
   65:  * - Consistent styling and behavior
   66:  * 
   67:  * Supported Filter Types:
   68:  * - Select (single choice)
   69:  * - Multi-select (multiple choices)
   70:  * - Range (numeric ranges)
   71:  * - Date Range (date ranges)
   72:  * - Boolean (true/false)
   73:  * 
   74:  * @template TData The type of data in the table rows
   75:  * 
   76:  * @param props Component properties
   77:  * @param props.column The column instance from TanStack Table
   78:  * @param props.filter The filter configuration for the column
   79:  * @param props.showClearButton Whether to show the clear filter button
   80:  * 
   81:  * @example
   82:  * ```tsx
   83:  * // Basic usage
   84:  * <FilterFactory
   85:  *   column={column}
   86:  *   filter={{
   87:  *     type: 'select',
   88:  *     options: ['Active', 'Inactive']
   89:  *   }}
   90:  * />
   91:  * 
   92:  * // With clear button
   93:  * <FilterFactory
   94:  *   column={column}
   95:  *   filter={{
   96:  *     type: 'dateRange',
   97:  *     format: 'YYYY-MM-DD'
   98:  *   }}
   99:  *   showClearButton={true}
  100:  * />
  101:  * ```
  102:  */
  103: export function FilterFactory<TData>({
  104:   column,
  105:   filter,
  106:   showClearButton = false
  107: }: FilterFactoryProps<TData>) {
  108:   // Check if there's an active filter
  109:   const hasActiveFilter = column.getFilterValue() !== undefined
  110: 
  111:   // Handle clearing the filter
  112:   const handleClearFilter = React.useCallback(() => {
  113:     column.setFilterValue(undefined)
  114:   }, [column])
  115: 
  116:   // Create the appropriate filter component based on filter type
  117:   const renderFilterComponent = () => {
  118:     if (isTextFilter(filter)) {
  119:       return <TextFilterComponent column={column} filter={filter} />
  120:     }
  121:     
  122:     if (isSelectFilter(filter)) {
  123:       return <SelectFilterComponent column={column} filter={filter} />
  124:     }
  125:     
  126:     if (isMultiSelectFilter(filter)) {
  127:       return <MultiSelectFilterComponent column={column} filter={filter} />
  128:     }
  129:     
  130:     if (isRangeFilter(filter)) {
  131:       return <RangeFilterComponent column={column} filter={filter} />
  132:     }
  133:     
  134:     if (isDateRangeFilter(filter)) {
  135:       return <DateRangeFilterComponent column={column} filter={filter} />
  136:     }
  137:     
  138:     if (isBooleanFilter(filter)) {
  139:       return <BooleanFilterComponent column={column} filter={filter} />
  140:     }
  141:     
  142:     return null
  143:   }
  144: 
  145:   return (
  146:     <>
  147:       {renderFilterComponent()}
  148:       
  149:       {hasActiveFilter && showClearButton && (
  150:         <button
  151:           onClick={handleClearFilter}
  152:           className="mt-2 w-full h-7 text-xs flex items-center justify-center rounded border border-input bg-background hover:bg-accent hover:text-accent-foreground"
  153:         >
  154:           <X className="mr-1 h-3 w-3" />
  155:           Clear Filter
  156:         </button>
  157:       )}
  158:     </>
  159:   )
  160: }
  161: 
  162: // Add the text filter type check function to the existing type guards
  163: export function isTextFilter(filter: ColumnFilter): filter is TextFilter {
  164:   return filter.type === 'text'
  165: } 

================================================================================
File: filters/filter-functions.ts
================================================================================

    1: /**
    2:  * Filter Functions Module
    3:  * 
    4:  * This module provides the core filtering logic for the data table system.
    5:  * It implements various filter functions that can be used with TanStack Table
    6:  * to filter data based on different criteria and data types.
    7:  * 
    8:  * Each filter function is designed to handle specific data types and filtering
    9:  * requirements, providing type-safe and efficient filtering capabilities.
   10:  * 
   11:  * @module data-table/filters/filter-functions
   12:  */
   13: 
   14: import { FilterFn } from "@tanstack/react-table"
   15: 
   16: /**
   17:  * Creates a filter function for multi-select filtering
   18:  * 
   19:  * This function creates a filter that allows selecting multiple values from
   20:  * a predefined set of options. It handles various data types and formats:
   21:  * - Array values (checks if any array element matches)
   22:  * - String values (direct comparison)
   23:  * - Other types (converts to string for comparison)
   24:  * 
   25:  * @template TData The type of data in the table rows
   26:  * @returns A filter function that can be used with TanStack Table
   27:  * 
   28:  * @example
   29:  * ```ts
   30:  * // Create a multi-select filter
   31:  * const multiSelectFilter = createMultiSelectFilterFn<User>();
   32:  * 
   33:  * // Use with TanStack Table
   34:  * const table = useReactTable({
   35:  *   columns,
   36:  *   data,
   37:  *   filterFns: {
   38:  *     multiSelect: multiSelectFilter
   39:  *   }
   40:  * });
   41:  * 
   42:  * // Filter values can be an array of any type
   43:  * table.getColumn('status').setFilterValue(['active', 'pending']);
   44:  * ```
   45:  */
   46: export function createMultiSelectFilterFn<TData>(): FilterFn<TData> {
   47:   return (row, columnId, filterValues) => {
   48:     // Handle empty filter values
   49:     if (!filterValues || !Array.isArray(filterValues) || !filterValues.length) return true
   50:     
   51:     // Get the cell value
   52:     const value = row.getValue(columnId)
   53:     
   54:     // Handle different value types
   55:     if (Array.isArray(value)) {
   56:       // If cell value is an array, check if any of the filter values are in the cell value array
   57:       return value.some(v => filterValues.includes(v))
   58:     } else if (typeof value === 'string') {
   59:       // If cell value is a string, check if it's included in the filter values
   60:       return filterValues.includes(value)
   61:     } else {
   62:       // For other types, convert to string and check
   63:       return filterValues.includes(String(value))
   64:     }
   65:   }
   66: }
   67: 
   68: /**
   69:  * Creates a filter function for date range filtering
   70:  * 
   71:  * This function creates a filter that allows selecting a range of dates.
   72:  * It handles date strings and timestamps, comparing them to ensure they
   73:  * fall within the specified range.
   74:  * 
   75:  * Features:
   76:  * - Handles partial ranges (min only, max only, or both)
   77:  * - Converts various date formats to timestamps
   78:  * - Properly handles edge cases and invalid dates
   79:  * 
   80:  * @template TData The type of data in the table rows
   81:  * @returns A filter function that can be used with TanStack Table
   82:  * 
   83:  * @example
   84:  * ```ts
   85:  * // Create a date range filter
   86:  * const dateRangeFilter = createDateRangeFilterFn<Order>();
   87:  * 
   88:  * // Use with TanStack Table
   89:  * const table = useReactTable({
   90:  *   columns,
   91:  *   data,
   92:  *   filterFns: {
   93:  *     dateRange: dateRangeFilter
   94:  *   }
   95:  * });
   96:  * 
   97:  * // Filter values should be an array with min and max dates
   98:  * table.getColumn('orderDate').setFilterValue(['2023-01-01', '2023-12-31']);
   99:  * ```
  100:  */
  101: export function createDateRangeFilterFn<TData>(): FilterFn<TData> {
  102:   return (row, columnId, filterValue) => {
  103:     // Handle empty filter values
  104:     if (!filterValue || !Array.isArray(filterValue)) return true
  105:     
  106:     // Get the date value and convert to timestamp
  107:     const value = row.getValue(columnId) as string
  108:     if (!value) return false
  109:     
  110:     const dateValue = new Date(value).getTime()
  111:     const [min, max] = filterValue as [string | undefined, string | undefined]
  112:     
  113:     // Check min value if provided
  114:     if (min) {
  115:       const minDate = new Date(min).getTime()
  116:       if (dateValue < minDate) return false
  117:     }
  118:     
  119:     // Check max value if provided
  120:     if (max) {
  121:       const maxDate = new Date(max).getTime()
  122:       if (dateValue > maxDate) return false
  123:     }
  124:     
  125:     return true
  126:   }
  127: }
  128: 
  129: /**
  130:  * Creates a filter function for boolean filtering
  131:  * 
  132:  * This function creates a filter that handles boolean values, allowing
  133:  * filtering for true/false values in a column. It's particularly useful
  134:  * for columns containing status flags or binary choices.
  135:  * 
  136:  * Features:
  137:  * - Simple true/false comparison
  138:  * - Handles undefined/null filter values
  139:  * - Type-safe boolean comparison
  140:  * 
  141:  * @template TData The type of data in the table rows
  142:  * @returns A filter function that can be used with TanStack Table
  143:  * 
  144:  * @example
  145:  * ```ts
  146:  * // Create a boolean filter
  147:  * const booleanFilter = createBooleanFilterFn<User>();
  148:  * 
  149:  * // Use with TanStack Table
  150:  * const table = useReactTable({
  151:  *   columns,
  152:  *   data,
  153:  *   filterFns: {
  154:  *     boolean: booleanFilter
  155:  *   }
  156:  * });
  157:  * 
  158:  * // Filter values should be true or false
  159:  * table.getColumn('isActive').setFilterValue(true);
  160:  * ```
  161:  */
  162: export function createBooleanFilterFn<TData>(): FilterFn<TData> {
  163:   return (row, columnId, filterValue) => {
  164:     // If no filter value is set, include all rows
  165:     if (filterValue === undefined || filterValue === null) return true
  166:     
  167:     // Get the boolean value from the row
  168:     const value = row.getValue(columnId) as boolean
  169:     
  170:     // Compare with the filter value
  171:     return value === filterValue
  172:   }
  173: } 

================================================================================
File: filters/index.ts
================================================================================

    1: /**
    2:  * Data Table Filters Module
    3:  * 
    4:  * This module provides a comprehensive filtering system for the data table,
    5:  * including filter functions, components, and a factory for creating appropriate
    6:  * filter interfaces based on column configuration.
    7:  * 
    8:  * Key Components:
    9:  * - Filter Functions: Core filtering logic for different data types
   10:  * - Filter Factory: Component that creates appropriate filter UIs
   11:  * - Filter Components: UI components for different filter types
   12:  * 
   13:  * The module supports various filter types:
   14:  * - Text/Select filters
   15:  * - Multi-select filters
   16:  * - Range filters (numeric and date)
   17:  * - Boolean filters
   18:  * 
   19:  * @module data-table/filters
   20:  */
   21: 
   22: // Export filter functions
   23: export * from "./filter-functions"
   24: 
   25: // Export filter factory
   26: export * from "./filter-factory"
   27: 
   28: // Export filter components
   29: export * from "./components" 

================================================================================
File: hooks/index.ts
================================================================================

    1: /**
    2:  * Data Table Hooks Module
    3:  * 
    4:  * This module exports all hooks related to the data table functionality.
    5:  * These hooks provide reusable logic for data table operations and features.
    6:  * 
    7:  * Features:
    8:  * - Data source hooks
    9:  * - Virtualization hooks
   10:  * - Web worker integration for offloading heavy computations
   11:  * - Custom state management hooks
   12:  * 
   13:  * @module data-table/hooks
   14:  */
   15: 
   16: export * from "./useDataTableSource"
   17: export * from "./useVirtualization"
   18: export * from "./useTableWorker" 

================================================================================
File: hooks/useAdaptiveColumns.ts
================================================================================

    1: import * as React from "react"
    2: import { Table, ColumnDef } from "@tanstack/react-table"
    3: import { useResizeObserver } from "./useResizeObserver"
    4: import { debounce } from "../utils/debounce"
    5: 
    6: interface UseAdaptiveColumnsOptions {
    7:   /**
    8:    * Whether to enable adaptive column sizing
    9:    */
   10:   enabled?: boolean
   11:   /**
   12:    * Minimum width for columns in pixels
   13:    */
   14:   minColumnWidth?: number
   15:   /**
   16:    * Maximum width for columns in pixels (0 means no limit)
   17:    */
   18:   maxColumnWidth?: number
   19:   /**
   20:    * Throttle time for resize calculations in milliseconds
   21:    */
   22:   resizeThrottleMs?: number
   23:   /**
   24:    * Whether to distribute remaining space proportionally
   25:    * If false, all columns get equal share of remaining space
   26:    */
   27:   proportionalDistribution?: boolean
   28: }
   29: 
   30: /**
   31:  * Hook for managing adaptive column widths based on container size
   32:  * 
   33:  * This hook adjusts column widths based on the container size and content
   34:  * to optimize the space utilization. It respects min/max width constraints
   35:  * and distributes available space among columns.
   36:  *
   37:  * @param table The table instance
   38:  * @param containerRef Reference to the container element
   39:  * @param options Configuration options
   40:  * @returns Column width state and utilities
   41:  */
   42: export function useAdaptiveColumns<TData>(
   43:   table: Table<TData>,
   44:   containerRef: React.RefObject<HTMLElement | null>,
   45:   {
   46:     enabled = false,
   47:     minColumnWidth = 50,
   48:     maxColumnWidth = 0,
   49:     resizeThrottleMs = 200,
   50:     proportionalDistribution = true,
   51:   }: UseAdaptiveColumnsOptions = {}
   52: ) {
   53:   // Track column widths
   54:   const [columnWidths, setColumnWidths] = React.useState<Record<string, number>>({})
   55:   
   56:   // Observe container size changes
   57:   const { size: containerSize } = useResizeObserver({ targetRef: containerRef })
   58:   
   59:   // Memoize columns to compare for changes
   60:   const columns = React.useMemo(() => table.getAllColumns(), [table])
   61:   
   62:   // Calculate column widths based on container size and content
   63:   const calculateColumnWidths = React.useCallback(() => {
   64:     if (!enabled || !containerSize || !containerRef.current) return
   65:     
   66:     const { width: containerWidth } = containerSize
   67:     const visibleColumns = table.getVisibleLeafColumns()
   68:     const columnCount = visibleColumns.length
   69:     
   70:     if (columnCount === 0) return
   71:     
   72:     // Get column size hints from column definitions
   73:     const columnSizeHints = visibleColumns.map(column => {
   74:       const colDef = column.columnDef as ColumnDef<TData> & { 
   75:         minWidth?: number;
   76:         maxWidth?: number;
   77:         width?: number;
   78:         sizePriority?: number;
   79:       }
   80:       
   81:       return {
   82:         id: column.id,
   83:         minWidth: colDef.minWidth || minColumnWidth,
   84:         maxWidth: colDef.maxWidth || maxColumnWidth,
   85:         width: colDef.width,
   86:         sizePriority: colDef.sizePriority || 1,
   87:       }
   88:     })
   89:     
   90:     // Start with minimum widths for all columns
   91:     let allocatedWidth = 0
   92:     const initialWidths: Record<string, number> = {}
   93:     
   94:     columnSizeHints.forEach(col => {
   95:       // Use defined width or minWidth
   96:       const width = col.width || col.minWidth
   97:       initialWidths[col.id] = width
   98:       allocatedWidth += width
   99:     })
  100:     
  101:     // Calculate remaining width to distribute
  102:     const remainingWidth = Math.max(0, containerWidth - allocatedWidth)
  103:     
  104:     if (remainingWidth > 0) {
  105:       // Distribute remaining width among columns
  106:       if (proportionalDistribution) {
  107:         // Distribute proportionally based on sizePriority
  108:         const totalPriority = columnSizeHints.reduce((sum, col) => sum + col.sizePriority, 0)
  109:         
  110:         columnSizeHints.forEach(col => {
  111:           const share = (col.sizePriority / totalPriority) * remainingWidth
  112:           const newWidth = initialWidths[col.id] + share
  113:           
  114:           // Respect maxWidth if defined
  115:           if (col.maxWidth && col.maxWidth > 0 && newWidth > col.maxWidth) {
  116:             initialWidths[col.id] = col.maxWidth
  117:           } else {
  118:             initialWidths[col.id] = newWidth
  119:           }
  120:         })
  121:       } else {
  122:         // Distribute equally
  123:         const sharePerColumn = remainingWidth / columnCount
  124:         
  125:         columnSizeHints.forEach(col => {
  126:           const newWidth = initialWidths[col.id] + sharePerColumn
  127:           
  128:           // Respect maxWidth if defined
  129:           if (col.maxWidth && col.maxWidth > 0 && newWidth > col.maxWidth) {
  130:             initialWidths[col.id] = col.maxWidth
  131:           } else {
  132:             initialWidths[col.id] = newWidth
  133:           }
  134:         })
  135:       }
  136:     }
  137:     
  138:     // Update state with new column widths
  139:     setColumnWidths(initialWidths)
  140:   }, [enabled, containerSize, containerRef, table, minColumnWidth, maxColumnWidth, proportionalDistribution])
  141:   
  142:   // Debounced calculation function to prevent excessive recalculations
  143:   const debouncedCalculation = React.useMemo(
  144:     () => debounce(calculateColumnWidths, resizeThrottleMs),
  145:     [calculateColumnWidths, resizeThrottleMs]
  146:   )
  147:   
  148:   // Recalculate column widths when container size changes
  149:   React.useEffect(() => {
  150:     if (enabled && containerSize) {
  151:       debouncedCalculation()
  152:     }
  153:   }, [enabled, containerSize, debouncedCalculation])
  154:   
  155:   // Recalculate when columns change
  156:   React.useEffect(() => {
  157:     if (enabled) {
  158:       debouncedCalculation()
  159:     }
  160:   }, [enabled, columns, debouncedCalculation])
  161:   
  162:   // Apply column widths to the table
  163:   const applyColumnWidths = React.useCallback(() => {
  164:     if (!enabled || Object.keys(columnWidths).length === 0) return
  165:     
  166:     table.getAllLeafColumns().forEach(column => {
  167:       if (columnWidths[column.id]) {
  168:         column.getSize = () => columnWidths[column.id]
  169:       }
  170:     })
  171:   }, [enabled, columnWidths, table])
  172:   
  173:   // Apply column widths when they change
  174:   React.useEffect(() => {
  175:     applyColumnWidths()
  176:   }, [columnWidths, applyColumnWidths])
  177:   
  178:   return {
  179:     columnWidths,
  180:     recalculate: calculateColumnWidths,
  181:     isEnabled: enabled,
  182:   }
  183: } 

================================================================================
File: hooks/useDataTableSource.ts
================================================================================

    1: "use client"
    2: 
    3: import { useState, useEffect } from 'react'
    4: import { DataTableSchema, deserializeSchema, SerializableDataTableSchema } from '../index'
    5: import { defaultCellRendererRegistry } from '../cell-renderers/defaultRegistry'
    6: import { CellRendererFunction } from '../cell-renderers/types'
    7: 
    8: // Define the registry interface, mirroring the one expected by deserializeSchema
    9: interface CellRendererRegistryLike {
   10:   get: (type: string) => CellRendererFunction | undefined;
   11: }
   12: 
   13: // Define the hook's return type
   14: interface UseDataTableSourceReturn<T> {
   15:   schema: DataTableSchema<T> | null
   16:   data: T[]
   17:   loading: boolean
   18:   error: string | null
   19: }
   20: 
   21: // Internal fetch function for schema
   22: async function fetchSchemaInternal<T>(
   23:   schemaName: string,
   24:   registry: CellRendererRegistryLike
   25: ): Promise<DataTableSchema<T>> {
   26:   const response = await fetch(`/api/schemas/${schemaName}`)
   27:   if (!response.ok) {
   28:     throw new Error(`Failed to fetch schema: ${schemaName}`)
   29:   }
   30:   const serialized = await response.json() as SerializableDataTableSchema
   31:   // Explicitly pass the generic type T to deserializeSchema
   32:   return deserializeSchema<T>(serialized, registry)
   33: }
   34: 
   35: // Internal fetch function for data
   36: async function fetchDataInternal<T>(dataUrl: string): Promise<T[]> {
   37:   const response = await fetch(dataUrl)
   38:   if (!response.ok) {
   39:     throw new Error(`Failed to fetch data from ${dataUrl}`)
   40:   }
   41:   return response.json()
   42: }
   43: 
   44: /**
   45:  * Custom hook to fetch and manage DataTable schema and data.
   46:  * @param schemaName - The name of the schema to fetch (used in /api/schemas/:schemaName).
   47:  * @param dataUrl - The URL to fetch the table data from.
   48:  * @param registry - The cell renderer registry to use for deserialization. Defaults to defaultCellRendererRegistry.
   49:  * @returns An object containing the schema, data, loading state, and error state.
   50:  */
   51: export function useDataTableSource<T = unknown>(
   52:   schemaName: string,
   53:   dataUrl: string,
   54:   registry: CellRendererRegistryLike = defaultCellRendererRegistry
   55: ): UseDataTableSourceReturn<T> {
   56:   const [schema, setSchema] = useState<DataTableSchema<T> | null>(null)
   57:   const [data, setData] = useState<T[]>([])
   58:   const [loading, setLoading] = useState(true)
   59:   const [error, setError] = useState<string | null>(null)
   60: 
   61:   useEffect(() => {
   62:     let isMounted = true // Flag to prevent state updates on unmounted component
   63: 
   64:     async function loadAllData() {
   65:       setLoading(true)
   66:       setError(null)
   67:       try {
   68:         // Fetch schema and data in parallel
   69:         const [loadedSchema, loadedData] = await Promise.all([
   70:           fetchSchemaInternal<T>(schemaName, registry),
   71:           fetchDataInternal<T>(dataUrl)
   72:         ])
   73: 
   74:         if (isMounted) {
   75:           setSchema(loadedSchema)
   76:           setData(loadedData)
   77:         }
   78:       } catch (err) {
   79:         console.error('Error loading data table source:', err)
   80:         if (isMounted) {
   81:           setError(err instanceof Error ? err.message : 'An unknown error occurred while loading data.')
   82:         }
   83:       } finally {
   84:         if (isMounted) {
   85:           setLoading(false)
   86:         }
   87:       }
   88:     }
   89: 
   90:     loadAllData()
   91: 
   92:     // Cleanup function to set isMounted to false when the component unmounts
   93:     return () => {
   94:       isMounted = false
   95:     }
   96:     // Dependency array includes schemaName, dataUrl, and registry instance
   97:   }, [schemaName, dataUrl, registry])
   98: 
   99:   return { schema, data, loading, error }
  100: } 

================================================================================
File: hooks/useResizeObserver.ts
================================================================================

    1: import { useEffect, useRef, useState } from 'react';
    2: 
    3: /**
    4:  * Size information returned by the resize observer
    5:  */
    6: export interface DOMRectSize {
    7:   width: number;
    8:   height: number;
    9:   x: number;
   10:   y: number;
   11:   top: number;
   12:   right: number;
   13:   bottom: number;
   14:   left: number;
   15: }
   16: 
   17: /**
   18:  * Hook that uses ResizeObserver to track element dimensions
   19:  * 
   20:  * @param targetRef - Optional ref to the element to observe. If not provided, 
   21:  *                   the hook will create and return a ref that you should attach to the element.
   22:  * @returns An object containing:
   23:  *   - ref: A ref to attach to the element (if not provided)
   24:  *   - size: The current dimensions of the element
   25:  *   - isObserving: Whether observation has started
   26:  * 
   27:  * @example
   28:  * // Using with an existing ref
   29:  * const myRef = useRef(null);
   30:  * const { size } = useResizeObserver({ targetRef: myRef });
   31:  * 
   32:  * @example
   33:  * // Creating a ref automatically
   34:  * const { ref, size } = useResizeObserver();
   35:  * return <div ref={ref}>Resizable content</div>;
   36:  */
   37: export function useResizeObserver<T extends HTMLElement = HTMLElement>({
   38:   targetRef,
   39: }: {
   40:   targetRef?: React.RefObject<T | null>;
   41: } = {}) {
   42:   // Create a ref if one wasn't provided
   43:   const localRef = useRef<T>(null);
   44:   const ref = targetRef || localRef;
   45:   
   46:   // Track the current size of the element
   47:   const [size, setSize] = useState<DOMRectSize | null>(null);
   48:   const [isObserving, setIsObserving] = useState(false);
   49:   
   50:   // Observer instance, kept in a ref to avoid recreation
   51:   const observerRef = useRef<ResizeObserver | null>(null);
   52:   
   53:   useEffect(() => {
   54:     // The element being observed
   55:     const element = ref.current;
   56:     if (!element) {
   57:       return;
   58:     }
   59:     
   60:     const updateSize = (entries: ResizeObserverEntry[]) => {
   61:       // In case multiple elements are observed, we find the one we care about
   62:       const entry = entries.find(entry => entry.target === element);
   63:       if (entry) {
   64:         // Get the content box size
   65:         const { x, y, width, height, top, right, bottom, left } = entry.contentRect;
   66:         setSize({ width, height, x, y, top, right, bottom, left });
   67:         
   68:         if (!isObserving) {
   69:           setIsObserving(true);
   70:         }
   71:       }
   72:     };
   73:     
   74:     // Cleanup previous observer if it exists
   75:     if (observerRef.current) {
   76:       observerRef.current.disconnect();
   77:     }
   78:     
   79:     // Create a new ResizeObserver
   80:     try {
   81:       observerRef.current = new ResizeObserver(updateSize);
   82:       observerRef.current.observe(element);
   83:       
   84:       // Get initial size
   85:       const { x, y, width, height, top, right, bottom, left } = element.getBoundingClientRect();
   86:       setSize({ width, height, x, y, top, right, bottom, left });
   87:     } catch (error) {
   88:       // ResizeObserver may not be supported in all environments
   89:       console.error('ResizeObserver failed:', error);
   90:     }
   91:     
   92:     // Cleanup on unmount
   93:     return () => {
   94:       if (observerRef.current) {
   95:         observerRef.current.disconnect();
   96:         observerRef.current = null;
   97:       }
   98:     };
   99:   }, [ref, isObserving]);
  100:   
  101:   return { ref: localRef, size, isObserving };
  102: } 

================================================================================
File: hooks/useTableWorker.ts
================================================================================

    1: import * as React from "react";
    2: 
    3: // Types for the worker messages
    4: type WorkerOperation = 'sort' | 'filter' | 'group' | 'process';
    5: 
    6: interface WorkerRequest {
    7:   operation: WorkerOperation;
    8:   data: Record<string, unknown>[];
    9:   params: Record<string, unknown>;
   10:   id?: string;
   11: }
   12: 
   13: interface WorkerResponse {
   14:   result: Record<string, unknown>[];
   15:   operation: string;
   16:   id?: string;
   17:   error?: string;
   18:   performance?: {
   19:     totalTime: number;
   20:     recordCount: number;
   21:   };
   22: }
   23: 
   24: interface WorkerHandler {
   25:   processData: (data: Record<string, unknown>[], params: {
   26:     sorts?: Array<{ columnId: string; desc: boolean }>;
   27:     filters?: Array<{ id: string; value: unknown; type: string }>;
   28:   }) => Promise<WorkerResponse>;
   29:   sortData: (data: Record<string, unknown>[], params: { 
   30:     columnId: string; 
   31:     desc: boolean 
   32:   }) => Promise<WorkerResponse>;
   33:   filterData: (data: Record<string, unknown>[], params: { 
   34:     filters: Array<{ id: string; value: unknown; type: string }> 
   35:   }) => Promise<WorkerResponse>;
   36:   terminateWorker: () => void;
   37:   isProcessing: boolean;
   38: }
   39: 
   40: let workerInstance: Worker | null = null;
   41: const pendingRequests = new Map<string, (value: WorkerResponse) => void>();
   42: 
   43: /**
   44:  * Hook for using a web worker to process table data
   45:  * 
   46:  * This hook provides methods to offload data processing tasks to a web worker,
   47:  * keeping the main UI thread responsive even with large datasets.
   48:  * 
   49:  * @returns Object with methods to interact with the worker
   50:  */
   51: export function useTableWorker(): WorkerHandler {
   52:   const [isProcessing, setIsProcessing] = React.useState(false);
   53:   
   54:   // Initialize the worker
   55:   React.useEffect(() => {
   56:     // Create the worker if it doesn't exist yet
   57:     if (!workerInstance) {
   58:       try {
   59:         workerInstance = new Worker(new URL('../workers/table-worker.ts', import.meta.url));
   60:         
   61:         // Set up the message handler
   62:         workerInstance.onmessage = (event: MessageEvent<WorkerResponse>) => {
   63:           const { id } = event.data;
   64:           
   65:           // Resolve the pending promise for this request
   66:           if (id && pendingRequests.has(id)) {
   67:             const resolve = pendingRequests.get(id)!;
   68:             resolve(event.data);
   69:             pendingRequests.delete(id);
   70:           }
   71:           
   72:           // If there are no more pending requests, we're not processing
   73:           if (pendingRequests.size === 0) {
   74:             setIsProcessing(false);
   75:           }
   76:         };
   77:         
   78:         // Handle worker errors
   79:         workerInstance.onerror = (error) => {
   80:           console.error('Worker error:', error);
   81:           setIsProcessing(false);
   82:           
   83:           // Reject all pending promises
   84:           pendingRequests.forEach((resolve) => {
   85:             resolve({
   86:               result: [],
   87:               operation: 'error',
   88:               error: error.message,
   89:             });
   90:           });
   91:           pendingRequests.clear();
   92:         };
   93:       } catch (error) {
   94:         console.error('Failed to create worker:', error);
   95:       }
   96:     }
   97:     
   98:     // Clean up when the component unmounts
   99:     return () => {
  100:       // Don't terminate the worker here to allow it to be reused
  101:     };
  102:   }, []);
  103:   
  104:   // Send a request to the worker and return a promise
  105:   const sendRequest = React.useCallback((request: WorkerRequest): Promise<WorkerResponse> => {
  106:     if (!workerInstance) {
  107:       return Promise.reject(new Error('Worker not initialized'));
  108:     }
  109:     
  110:     setIsProcessing(true);
  111:     
  112:     // Generate a unique ID for this request
  113:     const id = `${request.operation}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  114:     
  115:     // Create a promise that will be resolved when the worker responds
  116:     return new Promise((resolve) => {
  117:       pendingRequests.set(id, resolve);
  118:       workerInstance!.postMessage({ ...request, id });
  119:     });
  120:   }, []);
  121:   
  122:   // Process data with multiple operations
  123:   const processData = React.useCallback(
  124:     (data: Record<string, unknown>[], params: {
  125:       sorts?: Array<{ columnId: string; desc: boolean }>;
  126:       filters?: Array<{ id: string; value: unknown; type: string }>;
  127:     }): Promise<WorkerResponse> => {
  128:       return sendRequest({
  129:         operation: 'process',
  130:         data,
  131:         params,
  132:       });
  133:     },
  134:     [sendRequest]
  135:   );
  136:   
  137:   // Sort data
  138:   const sortData = React.useCallback(
  139:     (data: Record<string, unknown>[], params: { columnId: string; desc: boolean }): Promise<WorkerResponse> => {
  140:       return sendRequest({
  141:         operation: 'sort',
  142:         data,
  143:         params,
  144:       });
  145:     },
  146:     [sendRequest]
  147:   );
  148:   
  149:   // Filter data
  150:   const filterData = React.useCallback(
  151:     (data: Record<string, unknown>[], params: { 
  152:       filters: Array<{ id: string; value: unknown; type: string }> 
  153:     }): Promise<WorkerResponse> => {
  154:       return sendRequest({
  155:         operation: 'filter',
  156:         data,
  157:         params,
  158:       });
  159:     },
  160:     [sendRequest]
  161:   );
  162:   
  163:   // Terminate the worker
  164:   const terminateWorker = React.useCallback(() => {
  165:     if (workerInstance) {
  166:       workerInstance.terminate();
  167:       workerInstance = null;
  168:       pendingRequests.clear();
  169:       setIsProcessing(false);
  170:     }
  171:   }, []);
  172:   
  173:   return {
  174:     processData,
  175:     sortData,
  176:     filterData,
  177:     terminateWorker,
  178:     isProcessing,
  179:   };
  180: } 

================================================================================
File: hooks/useVirtualization.ts
================================================================================

    1: import * as React from "react"
    2: import { useVirtualizer } from "@tanstack/react-virtual"
    3: import { Row } from "@tanstack/react-table"
    4: import { useResizeObserver } from "./useResizeObserver"
    5: 
    6: interface UseVirtualizationOptions {
    7:   enabled?: boolean
    8:   estimateSize?: number
    9:   overscan?: number
   10:   paddingStart?: number
   11:   paddingEnd?: number
   12:   tableHeight?: string | number
   13:   expanded?: Record<string, boolean>
   14:   adaptiveHeight?: boolean
   15:   measurementCacheKey?: string
   16:   optimizationLevel?: 'low' | 'medium' | 'high'
   17:   scrollingDelay?: number
   18:   expandedRowSize?: number
   19: }
   20: 
   21: /**
   22:  * Enhanced hook for managing virtualized table rows
   23:  * 
   24:  * Provides high-performance virtualization capabilities for data tables with large datasets.
   25:  * Uses TanStack Virtual with advanced optimizations to efficiently render only the visible rows
   26:  * while minimizing DOM operations, layout thrashing, and frame drops.
   27:  * 
   28:  * Key improvements:
   29:  * - DOM recycling to reduce DOM size by 80-90% for large tables
   30:  * - Measurement caching to reduce layout thrashing
   31:  * - Scroll performance optimizations to prevent frame drops
   32:  * - Dynamic overscan adjustments during rapid scrolling
   33:  * - Efficient row height calculations
   34:  * - Optimized rendering pipeline with debounced updates
   35:  * 
   36:  * @param rows Array of table rows
   37:  * @param options Configuration options
   38:  * @returns Enhanced virtualization utilities and state
   39:  */
   40: export function useVirtualization<TData>(
   41:   rows: Row<TData>[],
   42:   {
   43:     enabled = true,
   44:     estimateSize = 35,
   45:     overscan = 10,
   46:     paddingStart = 0,
   47:     paddingEnd = 0,
   48:     tableHeight,
   49:     expanded,
   50:     adaptiveHeight = true,
   51:     measurementCacheKey = '',
   52:     optimizationLevel = 'high',
   53:     scrollingDelay = 150,
   54:     expandedRowSize = 200, // Default expanded row size to avoid huge DOM expansion
   55:   }: UseVirtualizationOptions = {}
   56: ) {
   57:   const parentRef = React.useRef<HTMLDivElement>(null)
   58:   
   59:   // Use resize observer to track the container size
   60:   const { size } = useResizeObserver({ targetRef: parentRef })
   61:   
   62:   // Track the container size in state for comparison
   63:   const [containerSize, setContainerSize] = React.useState<{ width: number; height: number } | null>(null)
   64: 
   65:   // Track if user is actively scrolling to optimize performance
   66:   const [isScrolling, setIsScrolling] = React.useState(false)
   67:   
   68:   // Store row height measurements to avoid repeated calculations
   69:   const rowHeightCache = React.useRef<Map<string, number>>(new Map()).current
   70:   
   71:   // Track rows that have been measured
   72:   const measuredRows = React.useRef<Set<string>>(new Set()).current
   73: 
   74:   // Reset measurement cache when rows or expanded state changes significantly
   75:   React.useEffect(() => {
   76:     if (measurementCacheKey) {
   77:       rowHeightCache.clear()
   78:       measuredRows.clear()
   79:     }
   80:   }, [measurementCacheKey, rowHeightCache, measuredRows])
   81: 
   82:   // Dynamic overscan calculation based on scrolling state
   83:   const dynamicOverscan = React.useMemo(() => {
   84:     if (optimizationLevel === 'low') return overscan
   85:     return isScrolling ? Math.max(5, Math.floor(overscan / 2)) : overscan * 2
   86:   }, [isScrolling, overscan, optimizationLevel])
   87: 
   88:   // More efficient row height estimation function that uses cached measurements when available
   89:   const getRowHeight = React.useCallback(
   90:     (index: number) => {
   91:       const row = rows[index]
   92:       if (!row) return estimateSize
   93: 
   94:       const rowId = row.id
   95:       
   96:       // Use cached height if available
   97:       if (rowHeightCache.has(rowId)) {
   98:         return rowHeightCache.get(rowId) || estimateSize
   99:       }
  100:       
  101:       // For expandable rows, set a fixed larger size to avoid layout shifts
  102:       if (expanded && expanded[rowId]) {
  103:         return expandedRowSize // Use a fixed larger size for expanded rows
  104:       }
  105:       
  106:       return estimateSize
  107:     },
  108:     [rows, estimateSize, expanded, rowHeightCache, expandedRowSize]
  109:   )
  110: 
  111:   // Create the enhanced virtualizer with optimizations
  112:   const virtualizer = useVirtualizer({
  113:     count: rows.length,
  114:     getScrollElement: () => parentRef.current,
  115:     estimateSize: getRowHeight,
  116:     overscan: dynamicOverscan,
  117:     paddingStart,
  118:     paddingEnd,
  119:     // Force aggressive measurement caching for improved performance
  120:     measureElement: (element) => {
  121:       // Get a more accurate measurement, factoring in any expanded content
  122:       const height = element instanceof HTMLElement ? element.offsetHeight : 0
  123:       // Store the height in our cache
  124:       const rowId = element instanceof HTMLElement ? element.getAttribute('data-row-id') : null
  125:       if (rowId && height > 0) {
  126:         rowHeightCache.set(rowId, height)
  127:         measuredRows.add(rowId)
  128:       }
  129:       return height
  130:     },
  131:   })
  132: 
  133:   // Utility function for debouncing to reduce layout thrashing
  134:   function debounce<Args extends unknown[], R>(fn: (...args: Args) => R, delay: number): (...args: Args) => void {
  135:     let timeoutId: ReturnType<typeof setTimeout> | null = null;
  136:     return (...args: Args) => {
  137:       if (timeoutId) clearTimeout(timeoutId);
  138:       timeoutId = setTimeout(() => {
  139:         fn(...args);
  140:         timeoutId = null;
  141:       }, delay) as unknown as ReturnType<typeof setTimeout>;
  142:     };
  143:   }
  144:   
  145:   // More efficient container size update with debouncing to reduce thrashing
  146:   const updateContainerSize = React.useMemo(() => {
  147:     return debounce((newSize: { width: number; height: number }) => {
  148:       setContainerSize(newSize)
  149:       virtualizer.measure()
  150:     }, optimizationLevel === 'high' ? 100 : optimizationLevel === 'medium' ? 50 : 0)
  151:   }, [virtualizer, optimizationLevel])
  152: 
  153:   // Update container size when it changes
  154:   React.useEffect(() => {
  155:     if (enabled && size && adaptiveHeight) {
  156:       // Only update when the size actually changes
  157:       if (!containerSize || 
  158:           containerSize.width !== size.width || 
  159:           containerSize.height !== size.height) {
  160:         updateContainerSize(size)
  161:       }
  162:     }
  163:   }, [size, containerSize, enabled, virtualizer, adaptiveHeight, updateContainerSize])
  164:   
  165:   // Store timeout reference outside of effects to prevent React Hook violations
  166:   const scrollingTimeoutRef = React.useRef<number | null>(null)
  167:   
  168:   // Handle scroll events to detect active scrolling
  169:   React.useEffect(() => {
  170:     if (!enabled || !parentRef.current || optimizationLevel === 'low') return
  171:     
  172:     const handleScroll = () => {
  173:       if (!isScrolling) {
  174:         setIsScrolling(true)
  175:       }
  176:       
  177:       // Reset scrolling state after scrolling stops
  178:       if (scrollingTimeoutRef.current) {
  179:         clearTimeout(scrollingTimeoutRef.current)
  180:       }
  181:       
  182:       scrollingTimeoutRef.current = window.setTimeout(() => {
  183:         setIsScrolling(false)
  184:       }, scrollingDelay) as unknown as number
  185:     }
  186:     
  187:     const scrollEl = parentRef.current
  188:     
  189:     scrollEl.addEventListener('scroll', handleScroll, { passive: true })
  190:     
  191:     return () => {
  192:       scrollEl.removeEventListener('scroll', handleScroll)
  193:       if (scrollingTimeoutRef.current) clearTimeout(scrollingTimeoutRef.current)
  194:     }
  195:   }, [enabled, isScrolling, parentRef, optimizationLevel, scrollingDelay])
  196: 
  197:   // More efficient resizing and recalculation handler with debouncing
  198:   const handleRecalculation = React.useMemo(() => {
  199:     return debounce(() => {
  200:       if (enabled && parentRef.current) {
  201:         virtualizer.measure()
  202:       }
  203:     }, optimizationLevel === 'high' ? 100 : optimizationLevel === 'medium' ? 50 : 0)
  204:   }, [enabled, parentRef, virtualizer, optimizationLevel])
  205: 
  206:   // Effect to handle resize and recalculate dimensions when key properties change
  207:   React.useEffect(() => {
  208:     handleRecalculation()
  209:   }, [tableHeight, rows.length, expanded, enabled, handleRecalculation])
  210:   
  211:   // Function to measure and cache a row's height
  212:   const measureRow = React.useCallback((index: number, element: HTMLElement | null) => {
  213:     if (!element || !rows[index] || !enabled) return
  214:     
  215:     const rowId = rows[index].id
  216:     // Set the row ID attribute for the virtualizer's measureElement to use
  217:     element.setAttribute('data-row-id', rowId)
  218:     if (measuredRows.has(rowId)) return
  219:     
  220:     const height = element.getBoundingClientRect().height
  221:     if (height > 0 && height !== rowHeightCache.get(rowId)) {
  222:       rowHeightCache.set(rowId, height)
  223:       measuredRows.add(rowId)
  224:       
  225:       // Only trigger a re-measure if the height is significantly different
  226:       if (Math.abs(height - estimateSize) > 5) {
  227:         virtualizer.measure()
  228:       }
  229:     }
  230:   }, [rows, measuredRows, rowHeightCache, virtualizer, estimateSize, enabled])
  231: 
  232:   // Create optimized virtual items that include additional metadata
  233:   const virtualRows = React.useMemo(() => {
  234:     if (!enabled) return []
  235:     
  236:     const items = virtualizer.getVirtualItems()
  237:     
  238:     // During active scrolling, we can reduce DOM nodes to improve performance
  239:     if (isScrolling && optimizationLevel === 'high') {
  240:       // During fast scrolling, render fewer rows (every other row)
  241:       return items.filter((_, i) => i % 2 === 0).map((item) => ({
  242:         ...item,
  243:         isScrolling: true,
  244:         measure: (el: HTMLElement | null) => measureRow(item.index, el),
  245:         original: rows[item.index],
  246:       }))
  247:     }
  248:     
  249:     // For higher optimization levels, we enhance the virtual items with additional metadata
  250:     return items.map((item) => ({
  251:       ...item,
  252:       isScrolling,
  253:       measure: (el: HTMLElement | null) => measureRow(item.index, el),
  254:       original: rows[item.index],
  255:       // Add expanded state information to help with rendering performance
  256:       isExpanded: expanded ? !!expanded[rows[item.index]?.id] : false,
  257:     }))
  258:   }, [enabled, virtualizer, optimizationLevel, isScrolling, measureRow, rows, expanded])
  259: 
  260:   return {
  261:     virtualizer,
  262:     parentRef,
  263:     virtualRows,
  264:     totalSize: enabled ? virtualizer.getTotalSize() : 0,
  265:     isVirtualized: enabled,
  266:     containerSize,
  267:     isScrolling,
  268:     measureRow,
  269:     // Add scroll to index functionality for better UX
  270:     scrollToIndex: virtualizer.scrollToIndex,
  271:     // Add scroll to row ID functionality
  272:     scrollToRowId: React.useCallback((rowId: string, options?: { align?: 'start' | 'center' | 'end' | 'auto' }) => {
  273:       const index = rows.findIndex(row => row.id === rowId)
  274:       if (index >= 0) {
  275:         virtualizer.scrollToIndex(index, options)
  276:       }
  277:     }, [rows, virtualizer]),
  278:     // Force all rows to be recalculated - useful when expanding/collapsing
  279:     recalculate: virtualizer.measure,
  280:   }
  281: } 

================================================================================
File: index.ts
================================================================================

    1: /**
    2:  * Data Table Module
    3:  * 
    4:  * This module serves as the main entry point for the data table component system.
    5:  * It provides a comprehensive set of tools for building and managing data tables
    6:  * with advanced features like filtering, sorting, grouping, and pagination.
    7:  * 
    8:  * Key Components:
    9:  * - Core DataTable component
   10:  * - Context and hooks for state management
   11:  * - Schema utilities for table configuration
   12:  * - Filter functionality for data filtering
   13:  * - Column management tools
   14:  * - Grouping capabilities
   15:  * - Pagination controls
   16:  * - Cell rendering system
   17:  * - Aggregation functions
   18:  * - Virtualization for large datasets
   19:  * 
   20:  * Features:
   21:  * - Type-safe table configuration
   22:  * - Flexible data handling
   23:  * - Customizable column definitions
   24:  * - Advanced filtering options
   25:  * - Multi-level grouping
   26:  * - Responsive pagination
   27:  * - Custom cell rendering
   28:  * - Data aggregation
   29:  * - Backward compatibility support
   30:  * - Virtualized rendering for performance
   31:  * 
   32:  * @module data-table
   33:  */
   34: 
   35: // Export the main DataTable component
   36: export * from "./core"
   37: 
   38: // Export context and hooks
   39: export * from "./core"
   40: 
   41: // Export types
   42: export * from "./types"
   43: 
   44: // Export utils
   45: export * from "./utils"
   46: 
   47: // Export filter functionality
   48: export * from "./filters"
   49: 
   50: // Export schema utilities
   51: export * from "./schema"
   52: 
   53: // Export UI parts
   54: export * from "./parts"
   55: 
   56: // Export aggregation functionality
   57: export * from "./aggregation"
   58: 
   59: // Export cell renderers
   60: export * from "./cell-renderers"
   61: 
   62: // Export default registry
   63: export * from "./cell-renderers/defaultRegistry"
   64: 
   65: // Export schema utils
   66: export * from "./schema/schema-utils"
   67: 
   68: // Export serialization utils
   69: export * from "./schema/serialization"
   70: 
   71: // Export hooks
   72: export * from "./hooks"
   73: 

================================================================================
File: parts/column-header.tsx
================================================================================

    1: "use client";
    2: 
    3: /**
    4:  * @module data-table/parts/column-header
    5:  * @description Interactive column header with sorting, filtering, aggregation, and visibility controls.
    6:  */
    7: 
    8: // React + Lib Imports
    9: import * as React from "react";
   10: import type { Column } from "@tanstack/react-table";
   11: import {
   12:   ChevronDown,
   13:   ChevronUp,
   14:   ChevronsUpDown,
   15:   EyeOff,
   16:   X,
   17:   Filter,
   18:   Calculator,
   19:   PlusCircle,
   20:   CheckCircle,
   21: } from "lucide-react";
   22: 
   23: // Internal Imports
   24: import { useDataTable } from "../core/context";
   25: import { getGlobalAggregationFunctionRegistry, createAggregationFunctionRegistry } from "../aggregation";
   26: import { FilterFactory } from "../filters/filter-factory";
   27: import { cn } from "@/lib/utils";
   28: import { formatAggregationType } from "../utils"; // Use extracted utility
   29: import type { DataTableColumnDef, ColumnFilter } from "../types";
   30: 
   31: // UI Imports
   32: import {
   33:   DropdownMenu,
   34:   DropdownMenuCheckboxItem,
   35:   DropdownMenuContent,
   36:   DropdownMenuItem,
   37:   DropdownMenuSeparator,
   38:   DropdownMenuTrigger,
   39: } from "@/components/ui/dropdown-menu";
   40: import { Badge } from "@/components/ui/badge";
   41: import {
   42:   Select,
   43:   SelectContent,
   44:   SelectItem,
   45:   SelectTrigger,
   46:   SelectValue,
   47: } from "@/components/ui/select";
   48: import { Button } from "@/components/ui/button";
   49: 
   50: // --- Sub Components for Composition ---
   51: 
   52: interface ColumnHeaderTriggerProps<TData> {
   53:   column: Column<TData, unknown>;
   54:   title: React.ReactNode;
   55:   alignment?: 'left' | 'center' | 'right';
   56:   className?: string;
   57:   hasAggregation: boolean;
   58: }
   59: 
   60: /** Renders the trigger element for the column header dropdown */
   61: const ColumnHeaderTrigger = React.memo(
   62:   <TData,>({ column, title, alignment, className, hasAggregation }: ColumnHeaderTriggerProps<TData>) => {
   63:     const hasActiveFilter = column.getFilterValue() !== undefined;
   64:     const canSort = column.getCanSort();
   65: 
   66:     // Consistent styling for trigger and icons
   67:     const triggerClass = cn(
   68:       "flex h-8 items-center gap-1.5 rounded-md px-2 py-1.5 hover:bg-accent focus:outline-none focus:ring-1 focus:ring-ring data-[state=open]:bg-accent w-full",
   69:       className
   70:     );
   71:     const iconClass = "h-4 w-4 shrink-0 text-muted-foreground";
   72:     const activeIconClass = "h-3.5 w-3.5";
   73: 
   74:     return (
   75:       <DropdownMenuTrigger className={triggerClass}>
   76:         <div className="flex w-full items-center justify-between">
   77:           {/* Title with alignment */}
   78:           <span className={cn("truncate", alignment ? `text-${alignment}` : 'text-left')}>{title}</span>
   79: 
   80:           {/* Status Icons */}
   81:           <span className="flex items-center ml-1 gap-0.5">
   82:             {canSort && column.getIsSorted() && (
   83:               column.getIsSorted() === "desc" ? (
   84:                 <ChevronDown className={activeIconClass} />
   85:               ) : (
   86:                 <ChevronUp className={activeIconClass} />
   87:               )
   88:             )}
   89:             {hasActiveFilter && (
   90:               <Filter className={cn(activeIconClass, "text-primary")} />
   91:             )}
   92:             {/* Show indicator for aggregation when applicable */}
   93:             {hasAggregation && (
   94:               <Calculator className={cn(activeIconClass, "text-indigo-500 opacity-75")} />
   95:             )}
   96:             {/* Show default sort icon only if sortable and not currently sorted */}
   97:             {canSort && !column.getIsSorted() && (
   98:               <ChevronsUpDown className={cn(iconClass, "opacity-50")} />
   99:             )}
  100:           </span>
  101:         </div>
  102:       </DropdownMenuTrigger>
  103:     );
  104:   },
  105:   // Compare props to prevent unnecessary re-renders
  106:   (prevProps, nextProps) => {
  107:     // Basic props comparison
  108:     const titleEqual = prevProps.title === nextProps.title;
  109:     const alignmentEqual = prevProps.alignment === nextProps.alignment;
  110:     const classNameEqual = prevProps.className === nextProps.className;
  111:     
  112:     // Column state comparison
  113:     const prevSorted = prevProps.column.getIsSorted();
  114:     const nextSorted = nextProps.column.getIsSorted();
  115:     const sortEqual = prevSorted === nextSorted;
  116:     
  117:     const prevFilter = prevProps.column.getFilterValue();
  118:     const nextFilter = nextProps.column.getFilterValue();
  119:     const filterEqual = prevFilter === nextFilter;
  120:     
  121:     const aggregationEqual = prevProps.hasAggregation === nextProps.hasAggregation;
  122:     
  123:     // Skip re-render if all important states are equal
  124:     return titleEqual && alignmentEqual && classNameEqual && sortEqual && filterEqual && aggregationEqual;
  125:   }
  126: );
  127: 
  128: // Add display name
  129: ColumnHeaderTrigger.displayName = "ColumnHeaderTrigger";
  130: 
  131: interface SortMenuItemsProps<TData> {
  132:   column: Column<TData, unknown>;
  133: }
  134: 
  135: /** Renders the sort-related menu items */
  136: const SortMenuItems = React.memo(
  137:   <TData,>({ column }: SortMenuItemsProps<TData>) => {
  138:     const iconClass = "h-4 w-4 shrink-0 text-muted-foreground";
  139:     const handleSortAsc = React.useCallback(() => column.toggleSorting(false), [column]);
  140:     const handleSortDesc = React.useCallback(() => column.toggleSorting(true), [column]);
  141:     const handleResetSort = React.useCallback(() => column.clearSorting(), [column]);
  142: 
  143:     return (
  144:       <>
  145:         <DropdownMenuCheckboxItem
  146:           className="relative pr-8 pl-2 text-xs [&>span:first-child]:right-2 [&>span:first-child]:left-auto"
  147:           checked={column.getIsSorted() === "asc"}
  148:           onSelect={handleSortAsc}
  149:         >
  150:           <ChevronUp className={iconClass} />
  151:           Asc
  152:         </DropdownMenuCheckboxItem>
  153:         <DropdownMenuCheckboxItem
  154:           className="relative pr-8 pl-2 text-xs [&>span:first-child]:right-2 [&>span:first-child]:left-auto"
  155:           checked={column.getIsSorted() === "desc"}
  156:           onSelect={handleSortDesc}
  157:         >
  158:           <ChevronDown className={iconClass} />
  159:           Desc
  160:         </DropdownMenuCheckboxItem>
  161:         {column.getIsSorted() && (
  162:           <DropdownMenuItem
  163:             className="pl-2 text-xs"
  164:             onSelect={handleResetSort}
  165:           >
  166:             <X className={iconClass} />
  167:             Reset Sort
  168:           </DropdownMenuItem>
  169:         )}
  170:       </>
  171:     );
  172:   },
  173:   // Compare props to prevent unnecessary re-renders
  174:   (prevProps, nextProps) => {
  175:     // Only compare the sorting state
  176:     const prevSorted = prevProps.column.getIsSorted();
  177:     const nextSorted = nextProps.column.getIsSorted();
  178:     return prevSorted === nextSorted;
  179:   }
  180: );
  181: 
  182: // Add display name
  183: SortMenuItems.displayName = "SortMenuItems";
  184: 
  185: interface AggregationSectionProps<TData> {
  186:   column: Column<TData, unknown>;
  187: }
  188: 
  189: /** Renders the aggregation section in the dropdown menu */
  190: const AggregationSection = React.memo(
  191:   <TData,>({ column }: AggregationSectionProps<TData>) => {
  192:     const { setColumnAggregation, columnAggregations } = useDataTable<TData>();
  193:     const columnDef = column.columnDef as DataTableColumnDef<TData>;
  194:     const [isAddingAggregation, setIsAddingAggregation] = React.useState(false);
  195:     const [showSuccess, setShowSuccess] = React.useState(false);
  196: 
  197:     // Initialize registry (consider moving to context/provider if used globally)
  198:     React.useEffect(() => {
  199:       createAggregationFunctionRegistry();
  200:     }, []);
  201: 
  202:     const aggregationRegistry = React.useMemo(() => getGlobalAggregationFunctionRegistry(), []);
  203:     const aggregationTypes = React.useMemo(() => aggregationRegistry?.getTypes() ?? [], [aggregationRegistry]);
  204: 
  205:     const currentAggregationType = React.useMemo(() => {
  206:       const columnId = column.id;
  207:       return columnAggregations?.[columnId] ?? columnDef.aggregationType;
  208:     }, [column.id, columnAggregations, columnDef.aggregationType]);
  209: 
  210:     const hasAggregation = !!currentAggregationType;
  211: 
  212:     const handleAggregationChange = React.useCallback((type: string) => {
  213:       if (setColumnAggregation && column.id) {
  214:         setColumnAggregation(column.id, type || undefined);
  215:         setIsAddingAggregation(false);
  216:         if (type) {
  217:           setShowSuccess(true);
  218:           setTimeout(() => setShowSuccess(false), 1500);
  219:         }
  220:       }
  221:     }, [setColumnAggregation, column.id]);
  222: 
  223:     const handleRemoveAggregation = React.useCallback(() => {
  224:       if (setColumnAggregation && column.id) {
  225:         setColumnAggregation(column.id, undefined);
  226:         setShowSuccess(false);
  227:         setIsAddingAggregation(false);
  228:       }
  229:     }, [setColumnAggregation, column.id]);
  230: 
  231:     return (
  232:       <div className="px-2 py-1.5">
  233:         {/* Header and Add button */}
  234:         <div className="text-xs font-medium mb-1 flex items-center justify-between">
  235:           <span className="flex items-center gap-1">
  236:             <Calculator className="h-3.5 w-3.5 text-indigo-500" />
  237:             Aggregation
  238:           </span>
  239:           {!isAddingAggregation && !hasAggregation && (
  240:             <Button
  241:               variant="outline"
  242:               size="sm"
  243:               className="h-6 text-xs flex items-center gap-1"
  244:               onClick={() => setIsAddingAggregation(true)}
  245:             >
  246:               <PlusCircle className="h-3 w-3" />
  247:               Add
  248:             </Button>
  249:           )}
  250:         </div>
  251: 
  252:         {/* Aggregation Controls: Select or Status Badge */}
  253:         {isAddingAggregation ? (
  254:           <div className="mt-1 space-y-1">
  255:             <Select value={currentAggregationType || ""} onValueChange={handleAggregationChange}>
  256:               <SelectTrigger className="w-full h-8 text-xs">
  257:                 <SelectValue placeholder="Select function..." />
  258:               </SelectTrigger>
  259:               <SelectContent>
  260:                 {aggregationTypes.length > 0 ? (
  261:                   aggregationTypes.map(type => {
  262:                     const config = aggregationRegistry?.getConfig(type);
  263:                     return (
  264:                       <SelectItem key={type} value={type} className="text-xs">
  265:                         {config?.label || formatAggregationType(type, aggregationRegistry)}
  266:                       </SelectItem>
  267:                     );
  268:                   })
  269:                 ) : (
  270:                   <SelectItem value="count" disabled className="text-xs text-muted-foreground">
  271:                     No functions available
  272:                   </SelectItem>
  273:                 )}
  274:               </SelectContent>
  275:             </Select>
  276:             <Button
  277:               variant="ghost"
  278:               size="sm"
  279:               className="h-7 text-xs w-full"
  280:               onClick={() => setIsAddingAggregation(false)}
  281:             >
  282:               Cancel
  283:             </Button>
  284:           </div>
  285:         ) : hasAggregation ? (
  286:           <div className="mt-1 space-y-1">
  287:             <div className="flex justify-between items-center gap-1">
  288:               <Badge
  289:                 variant="outline"
  290:                 className={cn(
  291:                   "justify-center flex-1 transition-colors h-7 text-xs",
  292:                   showSuccess && "bg-green-100 text-green-800 border-green-300"
  293:                 )}
  294:               >
  295:                 {showSuccess && <CheckCircle className="h-3.5 w-3.5 mr-1 text-green-600" />}
  296:                 {formatAggregationType(String(currentAggregationType), aggregationRegistry)}
  297:               </Badge>
  298:               <Button
  299:                 variant="ghost"
  300:                 size="icon"
  301:                 className="h-6 w-6"
  302:                 onClick={handleRemoveAggregation}
  303:                 aria-label="Remove aggregation"
  304:               >
  305:                 <X className="h-3.5 w-3.5" />
  306:               </Button>
  307:             </div>
  308:             <Button
  309:               variant="outline"
  310:               size="sm"
  311:               className="h-7 text-xs w-full"
  312:               onClick={() => setIsAddingAggregation(true)}
  313:             >
  314:               Change
  315:             </Button>
  316:           </div>
  317:         ) : (
  318:           <div className="text-xs text-muted-foreground mt-1">
  319:             No aggregation set.
  320:           </div>
  321:         )}
  322:       </div>
  323:     );
  324:   }
  325: );
  326: 
  327: // Add display name
  328: AggregationSection.displayName = "AggregationSection";
  329: 
  330: interface FilterSectionProps<TData> {
  331:   column: Column<TData, unknown>;
  332:   filterConfig: ColumnFilter;
  333: }
  334: 
  335: /** Renders the filter section in the dropdown menu */
  336: const FilterSection = React.memo(
  337:   <TData,>({ column, filterConfig }: FilterSectionProps<TData>) => {
  338:     return (
  339:       <div className="px-2 py-1.5">
  340:         <div className="text-xs font-medium mb-1 flex items-center gap-1">
  341:           <Filter className="h-3.5 w-3.5 text-primary" />
  342:           <span>Filter</span>
  343:         </div>
  344:         {/* Pass column and filter config to the factory */}
  345:         <FilterFactory
  346:           column={column}
  347:           filter={filterConfig}
  348:           showClearButton={true}
  349:         />
  350:       </div>
  351:     );
  352:   }
  353: );
  354: 
  355: // Add display name
  356: FilterSection.displayName = "FilterSection";
  357: 
  358: interface VisibilityToggleItemProps<TData> {
  359:   column: Column<TData, unknown>;
  360: }
  361: 
  362: /** Renders the hide column menu item */
  363: const VisibilityToggleItem = React.memo(
  364:   <TData,>({ column }: VisibilityToggleItemProps<TData>) => {
  365:     const iconClass = "h-4 w-4 shrink-0 text-muted-foreground";
  366:     const handleToggleVisibility = React.useCallback(() => column.toggleVisibility(false), [column]);
  367: 
  368:     return (
  369:       <DropdownMenuCheckboxItem
  370:         className="relative pr-8 pl-2 text-xs [&>span:first-child]:right-2 [&>span:first-child]:left-auto"
  371:         checked={!column.getIsVisible()}
  372:         onSelect={handleToggleVisibility}
  373:       >
  374:         <EyeOff className={iconClass} />
  375:         Hide Column
  376:       </DropdownMenuCheckboxItem>
  377:     );
  378:   },
  379:   // Compare props to prevent unnecessary re-renders
  380:   (prevProps, nextProps) => {
  381:     // Only compare the visibility state
  382:     const prevVisible = prevProps.column.getIsVisible();
  383:     const nextVisible = nextProps.column.getIsVisible();
  384:     return prevVisible === nextVisible;
  385:   }
  386: );
  387: 
  388: // Add display name
  389: VisibilityToggleItem.displayName = "VisibilityToggleItem";
  390: 
  391: interface ColumnHeaderMenuContentProps<TData> {
  392:   column: Column<TData, unknown>;
  393: }
  394: 
  395: /** Renders the content of the column header dropdown menu */
  396: const ColumnHeaderMenuContent = React.memo(
  397:   <TData,>({ column }: ColumnHeaderMenuContentProps<TData>) => {
  398:     const { schema } = useDataTable<TData>();
  399:     const columnDef = column.columnDef as DataTableColumnDef<TData>;
  400:     const filterConfig = columnDef.filter;
  401:     const canSort = column.getCanSort();
  402:     const canHide = column.getCanHide();
  403:     const canFilter = column.getCanFilter() && !!filterConfig;
  404:     const showAggregationControls = schema.enableGrouping; // Aggregation linked to grouping
  405: 
  406:     // Cast column to unknown type to avoid TypeScript errors
  407:     const unknownColumn = column as unknown as Column<unknown, unknown>;
  408: 
  409:     return (
  410:       <DropdownMenuContent align="start" className="w-64">
  411:         {/* Sorting Section */}
  412:         {canSort && <SortMenuItems column={unknownColumn} />}
  413: 
  414:         {/* Aggregation Section */}
  415:         {showAggregationControls && (
  416:           <>
  417:             {(canSort) && <DropdownMenuSeparator />}
  418:             <AggregationSection column={unknownColumn} />
  419:           </>
  420:         )}
  421: 
  422:         {/* Filter Section */}
  423:         {canFilter && (
  424:           <>
  425:             {(canSort || showAggregationControls) && <DropdownMenuSeparator />}
  426:             <FilterSection column={unknownColumn} filterConfig={filterConfig!} />
  427:           </>
  428:         )}
  429: 
  430:         {/* Visibility Section */}
  431:         {canHide && (
  432:           <>
  433:             {(canSort || canFilter || showAggregationControls) && <DropdownMenuSeparator />}
  434:             <VisibilityToggleItem column={unknownColumn} />
  435:           </>
  436:         )}
  437:       </DropdownMenuContent>
  438:     );
  439:   }
  440: );
  441: 
  442: // Add display name
  443: ColumnHeaderMenuContent.displayName = "ColumnHeaderMenuContent";
  444: 
  445: // --- Main Component ---
  446: 
  447: // Props Interface (simplified)
  448: interface DataTableColumnHeaderProps<TData> {
  449:   column: Column<TData, unknown>;
  450:   title: React.ReactNode;
  451:   className?: string;
  452: }
  453: 
  454: /**
  455:  * Renders an interactive column header.
  456:  * Provides a dropdown menu for sorting, filtering (if configured),
  457:  * aggregation (if enabled), and hiding the column.
  458:  */
  459: export const DataTableColumnHeader = React.memo(
  460:   function DataTableColumnHeaderInner<TData>({
  461:     column,
  462:     title,
  463:     className,
  464:   }: DataTableColumnHeaderProps<TData>) {
  465:     // --- State & Hooks ---
  466:     const columnDef = column.columnDef as DataTableColumnDef<TData>;
  467:     const alignment = columnDef.alignment;
  468:     const { schema, columnAggregations } = useDataTable<TData>();
  469: 
  470:     // --- Render Logic ---
  471:     // Render simple header if no interactive features are enabled
  472:     const canSort = column.getCanSort();
  473:     const canHide = column.getCanHide();
  474:     const canFilter = column.getCanFilter() && !!columnDef.filter;
  475:     const showAggregationControls = schema.enableGrouping;
  476: 
  477:     // Calculate hasAggregation here using the state from the unconditional hook call
  478:     const hasAggregation = !!(columnDef.aggregationType || columnAggregations?.[column.id]);
  479: 
  480:     // Cast column to unknown type to avoid TypeScript errors
  481:     const unknownColumn = column as unknown as Column<unknown, unknown>;
  482: 
  483:     if (!canSort && !canHide && !canFilter && !showAggregationControls) {
  484:       return (
  485:         <div className={cn("p-2", className, alignment ? `text-${alignment}` : 'text-left')}>
  486:           {title}
  487:         </div>
  488:       );
  489:     }
  490: 
  491:     return (
  492:       <DropdownMenu modal={false}> {/* Prevent focus trap issues with filters inside */}
  493:         <ColumnHeaderTrigger 
  494:           column={unknownColumn} 
  495:           title={title} 
  496:           alignment={alignment} 
  497:           className={className} 
  498:           hasAggregation={hasAggregation}
  499:         />
  500:         <ColumnHeaderMenuContent column={unknownColumn} />
  501:       </DropdownMenu>
  502:     );
  503:   },
  504:   // Custom comparison function
  505:   (prevProps, nextProps) => {
  506:     // Compare basic props
  507:     const titleEqual = prevProps.title === nextProps.title;
  508:     const classNameEqual = prevProps.className === nextProps.className;
  509:     
  510:     // Compare column state
  511:     const prevColumn = prevProps.column;
  512:     const nextColumn = nextProps.column;
  513:     
  514:     const prevSortingState = prevColumn.getIsSorted();
  515:     const nextSortingState = nextColumn.getIsSorted();
  516:     
  517:     const prevFilterValue = prevColumn.getFilterValue();
  518:     const nextFilterValue = nextColumn.getFilterValue();
  519:     
  520:     const prevVisibility = prevColumn.getIsVisible();
  521:     const nextVisibility = nextColumn.getIsVisible();
  522:     
  523:     // Skip re-render if all important states are equal
  524:     return titleEqual && 
  525:            classNameEqual && 
  526:            prevSortingState === nextSortingState &&
  527:            prevFilterValue === nextFilterValue &&
  528:            prevVisibility === nextVisibility;
  529:   }
  530: );
  531: 
  532: // Add display name
  533: DataTableColumnHeader.displayName = "DataTableColumnHeader"; 

================================================================================
File: parts/data-table-part-cell.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * @module data-table/parts/data-table-part-cell
    5:  * @description Renders table cells, supporting default rendering or custom cell renderers
    6:  * defined in the column definition.
    7:  */
    8: 
    9: // React + Lib Imports
   10: import * as React from "react"
   11: import { Cell, flexRender } from "@tanstack/react-table"
   12: 
   13: // Internal Imports
   14: import { DataTableColumnDef, SerializableCellRenderer } from "../types"
   15: import { DataTableCell, DataTableAggregatedCell } from "../core"
   16: import { ExpandIcon, CollapseIcon } from "./icons"
   17: 
   18: /**
   19:  * Props for the DataTablePartCell component
   20:  * 
   21:  * @interface DataTablePartCellProps
   22:  * @template TData - The type of data in the table
   23:  */
   24: interface DataTablePartCellProps<TData> {
   25:   /** The cell to render */
   26:   cell: Cell<TData, unknown>
   27: }
   28: 
   29: /**
   30:  * Renders a single table cell content based on its type.
   31:  * Handles grouped cells, aggregated cells with optional renderers, and normal cells.
   32:  * Optimized to use React.Fragment where possible to reduce DOM nodes.
   33:  */
   34: export const DataTablePartCell = React.memo(
   35:   function DataTablePartCellInner<TData>({
   36:     cell,
   37:   }: DataTablePartCellProps<TData>) {
   38:     // Get the column definition using the centralized type
   39:     const columnDef = cell.column.columnDef as DataTableColumnDef<TData> & {
   40:       // Explicitly type meta for easier access
   41:       meta?: {
   42:         aggregationRenderer?: SerializableCellRenderer;
   43:         // other meta properties...
   44:       };
   45:     };
   46: 
   47:     // Handle grouped cells (with expand/collapse buttons, etc.)
   48:     if (cell.getIsGrouped()) {
   49:       // Get the row from context
   50:       const row = cell.getContext().row;
   51:       
   52:       // Return grouped cell with button in a fragment to minimize nodes
   53:       return (
   54:         <React.Fragment>
   55:           {/* Add expand/collapse button next to grouped cells */}
   56:           {row.subRows?.length > 0 && (
   57:             <button
   58:               className="mr-0.5 h-3 w-3 p-0 flex-shrink-0 align-middle"
   59:               onClick={(e) => {
   60:                 e.stopPropagation()
   61:                 row.toggleExpanded()
   62:               }}
   63:               aria-label={row.getIsExpanded() ? "Collapse row" : "Expand row"}
   64:             >
   65:               {row.getIsExpanded() ? <CollapseIcon /> : <ExpandIcon />}
   66:             </button>
   67:           )}
   68:           
   69:           {/* Cell value */}
   70:           {flexRender(cell.column.columnDef.cell, cell.getContext())}
   71:           
   72:           {/* Show aggregation count */}
   73:           <span className="ml-1 text-muted-foreground text-xs">
   74:             {row.subRows.length > 0 && `(${row.subRows.length})`}
   75:           </span>
   76:         </React.Fragment>
   77:       );
   78:     }
   79: 
   80:     // Handle aggregated cells
   81:     if (cell.getIsAggregated()) {
   82:       const aggregationRenderer = columnDef.meta?.aggregationRenderer;
   83:       
   84:       // If column has a specified aggregation renderer, use that
   85:       if (aggregationRenderer) {
   86:         return (
   87:           <DataTableAggregatedCell cell={cell as Cell<unknown, unknown>} />
   88:         );
   89:       }
   90: 
   91:       // Default rendering for aggregated value
   92:       return (
   93:         <React.Fragment>
   94:           {flexRender(
   95:             cell.column.columnDef.aggregatedCell || cell.column.columnDef.cell,
   96:             cell.getContext()
   97:           )}
   98:         </React.Fragment>
   99:       );
  100:     }
  101: 
  102:     // Handle placeholder cells (part of a grouped row)
  103:     if (cell.getIsPlaceholder()) {
  104:       return <React.Fragment></React.Fragment>;
  105:     }
  106: 
  107:     // Standard cell rendering
  108:     return (
  109:       <DataTableCell cell={cell as Cell<unknown, unknown>} />
  110:     );
  111:   },
  112:   // Custom comparison function to prevent unnecessary re-renders
  113:   (prevProps, nextProps) => {
  114:     // Compare the cell values
  115:     const prevValue = prevProps.cell.getValue();
  116:     const nextValue = nextProps.cell.getValue();
  117:     const valuesEqual = prevValue === nextValue;
  118:     
  119:     // Compare grouped state
  120:     const prevIsGrouped = prevProps.cell.getIsGrouped();
  121:     const nextIsGrouped = nextProps.cell.getIsGrouped();
  122:     
  123:     // Compare aggregated state
  124:     const prevIsAggregated = prevProps.cell.getIsAggregated();
  125:     const nextIsAggregated = nextProps.cell.getIsAggregated();
  126:     
  127:     // Compare expanded state if grouped
  128:     let expandedEqual = true;
  129:     if (prevIsGrouped && nextIsGrouped) {
  130:       const prevRow = prevProps.cell.getContext().row;
  131:       const nextRow = nextProps.cell.getContext().row;
  132:       expandedEqual = prevRow.getIsExpanded() === nextRow.getIsExpanded();
  133:     }
  134:     
  135:     // Return true if all relevant properties are equal (preventing re-render)
  136:     return valuesEqual && 
  137:            prevIsGrouped === nextIsGrouped && 
  138:            prevIsAggregated === nextIsAggregated &&
  139:            expandedEqual;
  140:   }
  141: ) 

================================================================================
File: parts/grouping-controls.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Grouping Controls Module
    5:  * 
    6:  * This module provides a button and dialog interface for managing table grouping.
    7:  * It integrates with the data table context to provide a seamless grouping experience.
    8:  * 
    9:  * Features:
   10:  * - Group management dialog
   11:  * - Active group count display
   12:  * - Schema-based group validation
   13:  * - Responsive design
   14:  * - Keyboard accessibility
   15:  * 
   16:  * @module data-table/parts/grouping-controls
   17:  */
   18: 
   19: import * as React from "react"
   20: import { useDataTable } from "../core/context"
   21: import { Button } from "@/components/ui/button"
   22: import { Settings } from "lucide-react"
   23: import { Badge } from "@/components/ui/badge"
   24: import {
   25:   Dialog,
   26:   DialogContent,
   27:   DialogDescription,
   28:   DialogHeader,
   29:   DialogTitle,
   30:   DialogTrigger,
   31: } from "@/components/ui/dialog"
   32: import { TableConfigurationPanel } from "./table-configuration-panel"
   33: import { getGroupableColumns } from "../schema/schema-utils"
   34: import { hasAccessorKey } from "../utils"
   35: import type { GroupableColumn as ConfigurableColumn } from "../types"
   36: 
   37: /**
   38:  * Grouping Controls Component
   39:  * 
   40:  * A component that provides a button to open the grouping dialog and displays the
   41:  * number of active groups. It integrates with the data table context to manage
   42:  * grouping state and provides a user-friendly interface for group management.
   43:  * 
   44:  * Features:
   45:  * - Group management dialog
   46:  * - Active group count display
   47:  * - Schema-based group validation
   48:  * - Responsive design
   49:  * - Keyboard accessibility
   50:  * 
   51:  * The component automatically hides itself if:
   52:  * - Grouping is disabled in the schema
   53:  * - There are no groupable columns available
   54:  * 
   55:  * @example
   56:  * ```tsx
   57:  * // Basic usage
   58:  * <GroupingControls />
   59:  * ```
   60:  */
   61: export function GroupingControls<TData>() {
   62:   const {
   63:     schema,
   64:     grouping,
   65:     setGrouping,
   66:     columnOrder,
   67:     setColumnOrder,
   68:     columnVisibility,
   69:     setColumnVisibility,
   70:   } = useDataTable<TData>()
   71: 
   72:   const [isGroupingDialogOpen, setIsGroupingDialogOpen] = React.useState(false)
   73: 
   74:   // Get groupable column IDs (still needed for checking below)
   75:   const groupableColumns = React.useMemo(() => getGroupableColumns(schema), [schema])
   76: 
   77:   // Create a list of ALL columns with labels and groupable status
   78:   const configurableColumnObjects = React.useMemo(() => {
   79:     // Map over all columns defined in the schema
   80:     return schema.columns.map(colDef => {
   81:       const columnId = colDef.id || (hasAccessorKey(colDef) ? colDef.accessorKey : undefined);
   82:       
   83:       // Skip if we can't determine a column ID
   84:       if (!columnId) return null; 
   85: 
   86:       // Determine if the column is groupable (using the pre-calculated list)
   87:       const isGroupable = groupableColumns.includes(columnId);
   88: 
   89:       // Generate label from header or fallback to capitalized ID
   90:       const label = typeof colDef.header === 'string' 
   91:         ? colDef.header 
   92:         : (columnId.charAt(0).toUpperCase() + columnId.slice(1));
   93: 
   94:       return {
   95:         id: columnId,
   96:         label: label,
   97:         isGroupable: isGroupable // <-- Add groupable status
   98:       }
   99:     }).filter(Boolean); // Filter out any null entries
  100:   }, [schema, groupableColumns]) // Update dependencies
  101: 
  102:   // If grouping is not enabled or there are no groupable columns, don't render anything
  103:   if (!schema.enableGrouping || groupableColumns.length === 0) {
  104:     return null
  105:   }
  106: 
  107:   return (
  108:     <Dialog open={isGroupingDialogOpen} onOpenChange={setIsGroupingDialogOpen}>
  109:       <DialogTrigger asChild>
  110:         <Button 
  111:           variant="outline" 
  112:           size="sm" 
  113:           className="gap-1 h-7 text-xs"
  114:         >
  115:           <Settings className="h-3.5 w-3.5" />
  116:           Configure
  117:           {grouping.length > 0 && (
  118:             <Badge 
  119:               variant="secondary" 
  120:               className="ml-1 rounded-sm px-1 font-normal text-xs"
  121:             >
  122:               {grouping.length}
  123:             </Badge>
  124:           )}
  125:         </Button>
  126:       </DialogTrigger>
  127:       <DialogContent className="sm:max-w-[425px]">
  128:         <DialogHeader>
  129:           <DialogTitle>Configure Table</DialogTitle>
  130:           <DialogDescription>
  131:             Manage column visibility, order, and grouping. Drag items to reorder.
  132:           </DialogDescription>
  133:         </DialogHeader>
  134:         <TableConfigurationPanel
  135:           configurableColumns={configurableColumnObjects as ConfigurableColumn[]}
  136:           grouping={grouping}
  137:           onGroupingChange={setGrouping}
  138:           columnOrder={columnOrder}
  139:           onColumnOrderChange={setColumnOrder}
  140:           columnVisibility={columnVisibility}
  141:           onColumnVisibilityChange={setColumnVisibility}
  142:         />
  143:       </DialogContent>
  144:     </Dialog>
  145:   )
  146: } 

================================================================================
File: parts/icons.tsx
================================================================================

    1: /**
    2:  * Data Table Icons Module
    3:  * 
    4:  * This module provides optimized, memoized SVG icons used throughout the data table
    5:  * components. Centralizing icons improves performance by:
    6:  * 
    7:  * 1. Reducing SVG duplication in the bundle
    8:  * 2. Ensuring consistent memoization across components
    9:  * 3. Improving render performance with proper React.memo usage
   10:  * 4. Adding proper accessibility attributes
   11:  * 
   12:  * Each icon is created as a separate component with proper display names
   13:  * to help with debugging and profiling.
   14:  */
   15: 
   16: import React from "react";
   17: 
   18: // --- Expand/Collapse Icons ---
   19: 
   20: /**
   21:  * Expand icon (right-facing chevron)
   22:  */
   23: export const ExpandIcon = React.memo(() => (
   24:   <svg 
   25:     xmlns="http://www.w3.org/2000/svg" 
   26:     viewBox="0 0 20 20" 
   27:     fill="currentColor" 
   28:     className="h-3 w-3"
   29:     aria-hidden="true"
   30:     role="img"
   31:   >
   32:     <path 
   33:       fillRule="evenodd" 
   34:       d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" 
   35:       clipRule="evenodd" 
   36:     />
   37:   </svg>
   38: ));
   39: ExpandIcon.displayName = 'ExpandIcon';
   40: 
   41: /**
   42:  * Collapse icon (down-facing chevron)
   43:  */
   44: export const CollapseIcon = React.memo(() => (
   45:   <svg 
   46:     xmlns="http://www.w3.org/2000/svg" 
   47:     viewBox="0 0 20 20" 
   48:     fill="currentColor" 
   49:     className="h-3 w-3"
   50:     aria-hidden="true"
   51:     role="img"
   52:   >
   53:     <path 
   54:       fillRule="evenodd" 
   55:       d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" 
   56:       clipRule="evenodd" 
   57:     />
   58:   </svg>
   59: ));
   60: CollapseIcon.displayName = 'CollapseIcon';
   61: 
   62: // --- Pagination Icons ---
   63: 
   64: /**
   65:  * Previous page navigation icon
   66:  */
   67: export const PreviousPageIcon = React.memo(() => (
   68:   <svg 
   69:     xmlns="http://www.w3.org/2000/svg" 
   70:     viewBox="0 0 24 24" 
   71:     fill="none" 
   72:     stroke="currentColor" 
   73:     strokeWidth="2" 
   74:     strokeLinecap="round" 
   75:     strokeLinejoin="round" 
   76:     className="h-3 w-3"
   77:     aria-hidden="true"
   78:     role="img"
   79:   >
   80:     <path d="m15 18-6-6 6-6"></path>
   81:   </svg>
   82: ));
   83: PreviousPageIcon.displayName = 'PreviousPageIcon';
   84: 
   85: /**
   86:  * Next page navigation icon
   87:  */
   88: export const NextPageIcon = React.memo(() => (
   89:   <svg 
   90:     xmlns="http://www.w3.org/2000/svg" 
   91:     viewBox="0 0 24 24" 
   92:     fill="none" 
   93:     stroke="currentColor" 
   94:     strokeWidth="2" 
   95:     strokeLinecap="round" 
   96:     strokeLinejoin="round" 
   97:     className="h-3 w-3"
   98:     aria-hidden="true"
   99:     role="img"
  100:   >
  101:     <path d="m9 18 6-6-6-6"></path>
  102:   </svg>
  103: ));
  104: NextPageIcon.displayName = 'NextPageIcon';
  105: 
  106: // --- Filter & Sort Icons ---
  107: 
  108: /**
  109:  * Filter icon for column headers
  110:  */
  111: export const FilterIcon = React.memo(() => (
  112:   <svg 
  113:     xmlns="http://www.w3.org/2000/svg" 
  114:     viewBox="0 0 24 24" 
  115:     fill="none" 
  116:     stroke="currentColor" 
  117:     strokeWidth="2" 
  118:     strokeLinecap="round" 
  119:     strokeLinejoin="round" 
  120:     className="h-3.5 w-3.5"
  121:     aria-hidden="true"
  122:     role="img"
  123:   >
  124:     <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
  125:   </svg>
  126: ));
  127: FilterIcon.displayName = 'FilterIcon';
  128: 
  129: /**
  130:  * Sort ascending icon (up arrow)
  131:  */
  132: export const SortAscIcon = React.memo(() => (
  133:   <svg 
  134:     xmlns="http://www.w3.org/2000/svg" 
  135:     viewBox="0 0 24 24" 
  136:     fill="none" 
  137:     stroke="currentColor" 
  138:     strokeWidth="2" 
  139:     strokeLinecap="round" 
  140:     strokeLinejoin="round" 
  141:     className="h-3.5 w-3.5"
  142:     aria-hidden="true"
  143:     role="img"
  144:   >
  145:     <path d="m18 15-6-6-6 6"></path>
  146:   </svg>
  147: ));
  148: SortAscIcon.displayName = 'SortAscIcon';
  149: 
  150: /**
  151:  * Sort descending icon (down arrow)
  152:  */
  153: export const SortDescIcon = React.memo(() => (
  154:   <svg 
  155:     xmlns="http://www.w3.org/2000/svg" 
  156:     viewBox="0 0 24 24" 
  157:     fill="none" 
  158:     stroke="currentColor" 
  159:     strokeWidth="2" 
  160:     strokeLinecap="round" 
  161:     strokeLinejoin="round" 
  162:     className="h-3.5 w-3.5"
  163:     aria-hidden="true"
  164:     role="img"
  165:   >
  166:     <path d="m6 9 6 6 6-6"></path>
  167:   </svg>
  168: ));
  169: SortDescIcon.displayName = 'SortDescIcon';
  170: 
  171: /**
  172:  * Sort both direction icon (up/down arrows)
  173:  */
  174: export const SortBothIcon = React.memo(() => (
  175:   <svg 
  176:     xmlns="http://www.w3.org/2000/svg" 
  177:     viewBox="0 0 24 24" 
  178:     fill="none" 
  179:     stroke="currentColor" 
  180:     strokeWidth="2" 
  181:     strokeLinecap="round" 
  182:     strokeLinejoin="round" 
  183:     className="h-4 w-4 opacity-50"
  184:     aria-hidden="true"
  185:     role="img"
  186:   >
  187:     <path d="m7 15 5 5 5-5"></path>
  188:     <path d="m7 9 5-5 5 5"></path>
  189:   </svg>
  190: ));
  191: SortBothIcon.displayName = 'SortBothIcon'; 

================================================================================
File: parts/index.ts
================================================================================

    1: /**
    2:  * Data Table Parts Module
    3:  * 
    4:  * This module provides the core structural components that make up the data table.
    5:  * These components work together to create a complete table interface with all necessary
    6:  * functionality and visual elements.
    7:  * 
    8:  * Key Components:
    9:  * - TableHeader: Renders the table header with column headers and sorting controls
   10:  * - TableBody: Renders the table body with rows and cells
   11:  * - TableCell: Renders individual table cells with proper formatting
   12:  * - Toolbar: Provides table controls and actions
   13:  * - Pagination: Handles table pagination and page navigation
   14:  * - DataTableColumnHeader: Interactive column header with sorting, filtering and more
   15:  * - GroupingPanel: Panel for configuring and managing grouping
   16:  * - GroupingControls: Controls for activating and managing grouping
   17:  * 
   18:  * Features:
   19:  * - Modular table structure
   20:  * - Consistent styling
   21:  * - Responsive design
   22:  * - Accessibility support
   23:  * - Flexible customization
   24:  * 
   25:  * @module data-table/parts
   26:  */
   27: 
   28: export { TableHeaderComponent as TableHeader } from './table-header'
   29: export { TableBodyComponent as TableBody } from './table-body'
   30: export { DataTablePartCell as TableCell } from './data-table-part-cell'
   31: export { Toolbar } from './toolbar'
   32: export { DataTableColumnHeader } from './column-header'
   33: export { GroupingControls } from './grouping-controls'
   34: export { TableConfigurationPanel } from './table-configuration-panel'
   35: export { Pagination } from './pagination' 

================================================================================
File: parts/pagination.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Pagination Module
    5:  * 
    6:  * This module provides the pagination component for the data table, which includes
    7:  * page navigation controls, page size selection, and entry count display. The
    8:  * component integrates with the table's context to provide a consistent interface
    9:  * for pagination operations.
   10:  * 
   11:  * Features:
   12:  * - Page navigation controls
   13:  * - Page size selection
   14:  * - Entry count display
   15:  * - Grouping information display
   16:  * - Responsive design
   17:  * - Accessibility support
   18:  * 
   19:  * @module data-table/parts/pagination
   20:  */
   21: 
   22: import * as React from "react"
   23: import { useDataTable } from "../core/context"
   24: import { Table } from "@tanstack/react-table"
   25: import {
   26:   Select,
   27:   SelectContent,
   28:   SelectItem,
   29:   SelectTrigger,
   30:   SelectValue,
   31: } from "@/components/ui/select"
   32: import { PreviousPageIcon, NextPageIcon } from "./icons"
   33: 
   34: // Memoized pagination button component to reduce re-renders
   35: interface PaginationButtonProps {
   36:   onClick: () => void;
   37:   disabled: boolean;
   38:   label: string;
   39:   icon: React.ReactNode;
   40: }
   41: 
   42: const PaginationButton = React.memo(({ onClick, disabled, label, icon }: PaginationButtonProps) => (
   43:   <button
   44:     className={`h-6 px-1.5 flex items-center ${disabled ? "opacity-50 cursor-not-allowed" : "hover:bg-accent"} rounded-sm`}
   45:     onClick={onClick}
   46:     disabled={disabled}
   47:     aria-label={label}
   48:   >
   49:     <span className="sr-only">{label}</span>
   50:     {icon}
   51:   </button>
   52: ));
   53: PaginationButton.displayName = 'PaginationButton';
   54: 
   55: /**
   56:  * Pagination Component
   57:  * 
   58:  * A comprehensive pagination component that provides page navigation, size selection,
   59:  * and entry count display for the data table. It integrates with the table's context
   60:  * to manage pagination state and display grouping information when applicable.
   61:  * 
   62:  * Features:
   63:  * - Page navigation with previous/next buttons
   64:  * - Page size selection (25, 50, 100, 250, 500, 1000)
   65:  * - Current page and total pages display
   66:  * - Total entries count
   67:  * - Grouping information display
   68:  * - Responsive design
   69:  * - Accessibility support
   70:  * 
   71:  * The component automatically:
   72:  * - Renders pagination controls when enabled
   73:  * - Shows entry count and grouping information
   74:  * - Provides page size selection
   75:  * - Handles page navigation
   76:  * - Disables navigation buttons when at limits
   77:  * 
   78:  * @example
   79:  * ```tsx
   80:  * // Basic usage
   81:  * <Pagination />
   82:  * 
   83:  * // With custom configuration
   84:  * const schema = {
   85:  *   enablePagination: true,
   86:  *   columns: [
   87:  *     {
   88:  *       id: 'name',
   89:  *       header: 'Name',
   90:  *       enableGrouping: true
   91:  *     }
   92:  *   ]
   93:  * }
   94:  * ```
   95:  */
   96: export function Pagination() {
   97:   const {
   98:     schema,
   99:     table,
  100:     grouping,
  101:   } = useDataTable<unknown>()
  102:   
  103:   // Cast table to the correct type
  104:   const typedTable = table as Table<unknown>
  105: 
  106:   // Memoize callback functions to prevent recreating on each render
  107:   const handlePreviousPage = React.useCallback(() => {
  108:     if (typedTable.getCanPreviousPage()) {
  109:       typedTable.previousPage()
  110:     }
  111:   }, [typedTable]);
  112: 
  113:   const handleNextPage = React.useCallback(() => {
  114:     if (typedTable.getCanNextPage()) {
  115:       typedTable.nextPage()
  116:     }
  117:   }, [typedTable]);
  118: 
  119:   const handlePageSizeChange = React.useCallback((value: string) => {
  120:     typedTable.setPageSize(Number(value))
  121:   }, [typedTable]);
  122: 
  123:   // If pagination is not enabled, don't render anything
  124:   if (schema.enablePagination !== true) {
  125:     return null
  126:   }
  127: 
  128:   /**
  129:    * Gets the display label for a grouped column
  130:    * 
  131:    * @param columnId - The ID of the column to get the label for
  132:    * @returns The display label for the column
  133:    */
  134:   const getGroupedColumnLabel = (columnId: string) => {
  135:     const column = schema.columns.find(c => c.id === columnId) ||
  136:       schema.columns.find(c => 'accessorKey' in c && c.accessorKey === columnId)
  137:     
  138:     return typeof column?.header === 'string'
  139:       ? column.header
  140:       : columnId.charAt(0).toUpperCase() + columnId.slice(1)
  141:   }
  142: 
  143:   // Memoize derived state to prevent recalculations
  144:   const filteredRowCount = typedTable.getFilteredRowModel().rows.length;
  145:   const totalRowCount = typedTable.options.data.length;
  146:   const currentPage = typedTable.getState().pagination.pageIndex + 1;
  147:   const totalPages = typedTable.getPageCount();
  148:   const canPreviousPage = typedTable.getCanPreviousPage();
  149:   const canNextPage = typedTable.getCanNextPage();
  150:   const pageSize = typedTable.getState().pagination.pageSize.toString();
  151: 
  152:   return (
  153:     <div className="flex items-center justify-between text-xs">
  154:       <div className="flex-1 text-muted-foreground">
  155:         Showing {filteredRowCount} of {totalRowCount} entries
  156:         {grouping.length > 0 && (
  157:           <span className="ml-2">
  158:             (Grouped by{" "}
  159:             {grouping.map((columnId, index) => {
  160:               return (
  161:                 <React.Fragment key={columnId}>
  162:                   <span className="font-medium">
  163:                     {getGroupedColumnLabel(columnId)}
  164:                   </span>
  165:                   {index < grouping.length - 1 ? " → " : ""}
  166:                 </React.Fragment>
  167:               )
  168:             })}
  169:             )
  170:           </span>
  171:         )}
  172:       </div>
  173:       <div className="flex items-center gap-1 border rounded-md p-0.5">
  174:         <Select
  175:           value={pageSize}
  176:           onValueChange={handlePageSizeChange}
  177:         >
  178:           <SelectTrigger className="h-6 w-[80px] border-0 text-xs">
  179:             <SelectValue placeholder={pageSize} />
  180:           </SelectTrigger>
  181:           <SelectContent>
  182:             {[25, 50, 100, 250, 500, 1000].map((pageSize) => (
  183:               <SelectItem key={pageSize} value={pageSize.toString()} className="text-xs">
  184:                 {pageSize}
  185:               </SelectItem>
  186:             ))}
  187:           </SelectContent>
  188:         </Select>
  189:         <span className="text-xs font-medium px-1">per page</span>
  190:         <div className="border-l h-6 mx-1"></div>
  191:         
  192:         <PaginationButton
  193:           onClick={handlePreviousPage}
  194:           disabled={!canPreviousPage}
  195:           label="Previous page"
  196:           icon={<PreviousPageIcon />}
  197:         />
  198:         
  199:         <span className="text-xs font-medium">
  200:           Page {currentPage} of{" "}
  201:           {totalPages}
  202:         </span>
  203:         
  204:         <PaginationButton
  205:           onClick={handleNextPage}
  206:           disabled={!canNextPage}
  207:           label="Next page"
  208:           icon={<NextPageIcon />}
  209:         />
  210:       </div>
  211:     </div>
  212:   )
  213: } 

================================================================================
File: parts/table-body.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Table Body Module
    5:  * 
    6:  * This module provides the table body component that renders the data rows and cells
    7:  * of the table. It handles row rendering, cell alignment, grouping, aggregation,
    8:  * and expandable rows.
    9:  * 
   10:  * Features:
   11:  * - Row and cell rendering
   12:  * - Automatic cell alignment
   13:  * - Grouping support
   14:  * - Aggregation display
   15:  * - Expandable rows
   16:  * - Empty state handling
   17:  * - Responsive design
   18:  * - Virtualized scrolling for large datasets
   19:  * 
   20:  * @module data-table/parts/table-body
   21:  */
   22: 
   23: import * as React from "react"
   24: import { Row, Cell } from "@tanstack/react-table"
   25: import { useDataTable } from "../core/context"
   26: import { TableBody, TableCell, TableRow } from "@/components/ui/table"
   27: import { DataTablePartCell } from "./data-table-part-cell"
   28: import { useVirtualization } from "../hooks/useVirtualization"
   29: import { TableHeaderComponent } from "./table-header"
   30: 
   31: // Regular expressions to avoid recomputing this on each render
   32: const DATE_REGEX = /^\d{4}-\d{2}-\d{2}|\d{2}\/\d{2}\/\d{4}/
   33: 
   34: /**
   35:  * Table Body Component
   36:  * 
   37:  * Renders the body section of the data table, including all rows and cells.
   38:  * The component handles various cell types (grouped, aggregated, placeholder)
   39:  * and provides automatic alignment based on data type.
   40:  * 
   41:  * Features:
   42:  * - Row and cell rendering
   43:  * - Automatic cell alignment based on data type
   44:  * - Grouping support with expand/collapse
   45:  * - Aggregation display
   46:  * - Empty state handling
   47:  * - Responsive design
   48:  * - Virtualized scrolling for large datasets with high performance optimizations
   49:  * - Adaptive sizing using ResizeObserver
   50:  * 
   51:  * The component automatically:
   52:  * - Renders all rows and cells
   53:  * - Applies appropriate alignment
   54:  * - Handles grouped and aggregated cells
   55:  * - Shows expand/collapse buttons for grouped rows
   56:  * - Displays row counts for grouped cells
   57:  * - Shows an empty state when no data is available
   58:  * - Uses virtualization for efficient rendering of large datasets
   59:  * - Adapts to container size changes
   60:  * 
   61:  * @example
   62:  * ```tsx
   63:  * // Basic usage
   64:  * <TableBody />
   65:  * 
   66:  * // With grouping
   67:  * const columns = [
   68:  *   {
   69:  *     id: 'category',
   70:  *     header: 'Category',
   71:  *     enableGrouping: true
   72:  *   },
   73:  *   {
   74:  *     id: 'value',
   75:  *     header: 'Value',
   76:  *     aggregationFn: 'sum'
   77:  *   }
   78:  * ]
   79:  * ```
   80:  */
   81: export function TableBodyComponent() {
   82:   const { 
   83:     table, 
   84:     schema,
   85:     grouping,
   86:     expanded,
   87:   } = useDataTable<unknown>()
   88:   
   89:   // Keep track of the last seen parent values for each depth level
   90:   const lastParentValues = React.useRef<Record<number, string>>({})
   91:   
   92:   // Get row model
   93:   const rows = table.getRowModel().rows;
   94:   
   95:   // Use virtualization when enabled in schema and we have many rows 
   96:   // Only use virtualization when we're not using grouping since they're not compatible
   97:   const shouldVirtualize = schema.enableVirtualization !== false && 
   98:                           rows.length > (schema.virtualizationThreshold || 50) &&
   99:                           !schema.enableGrouping;
  100:                           
  101:   // Track which rows have been rendered for caching alignment classes
  102:   const alignmentCache = React.useRef<Map<string, string>>(new Map()).current;
  103:   
  104:   // Track if virtualization is in normal or high-performance mode
  105:   const [highPerformanceMode, setHighPerformanceMode] = React.useState(false);
  106:   
  107:   // Generate measurement cache key to reset cache when needed
  108:   const measurementCacheKey = React.useMemo(() => {
  109:     return `${rows.length}-${Object.keys(expanded || {}).length}`;
  110:   }, [rows.length, expanded]);
  111:   
  112:   // Get virtualization options from schema (with defaults)
  113:   const virtualizationOptions = React.useMemo(() => ({
  114:     enabled: shouldVirtualize,
  115:     estimateSize: schema.rowHeight || 35,
  116:     overscan: schema.virtualOverscan || 15, // Increase overscan for smoother scrolling
  117:     tableHeight: schema.tableHeight || '400px',
  118:     expanded: expanded as Record<string, boolean> | undefined,
  119:     adaptiveHeight: schema.enableAdaptiveSizing !== false,
  120:     optimizationLevel: 'high' as const,
  121:     scrollingDelay: 150,
  122:     measurementCacheKey,
  123:     expandedRowSize: 200, // Set fixed expanded row size to avoid DOM explosions
  124:   }), [shouldVirtualize, schema.rowHeight, schema.virtualOverscan, schema.tableHeight, 
  125:       expanded, schema.enableAdaptiveSizing, measurementCacheKey]);
  126:   
  127:   // Initialize enhanced virtualization with performance optimizations
  128:   const {
  129:     parentRef,
  130:     virtualRows,
  131:     totalSize,
  132:     isVirtualized,
  133:     containerSize,
  134:     isScrolling,
  135:     measureRow,
  136:     recalculate, // Use to force recalculation when rows expand/collapse
  137:     scrollToRowId, // Helps scroll to the expanded row
  138:   } = useVirtualization(rows, virtualizationOptions)
  139:   
  140:   // Switch to high-performance mode during scrolling to further reduce frame drops
  141:   React.useEffect(() => {
  142:     setHighPerformanceMode(isScrolling);
  143:   }, [isScrolling]);
  144:   
  145:   // Determine the effective table height
  146:   // Use the container size if it's available and adaptive sizing is enabled
  147:   const effectiveTableHeight = React.useMemo(() => {
  148:     if (schema.enableAdaptiveSizing !== false && containerSize) {
  149:       return `${containerSize.height}px`;
  150:     }
  151:     return schema.tableHeight || '400px';
  152:   }, [schema.enableAdaptiveSizing, containerSize, schema.tableHeight]);
  153:   
  154:   // VirtualRow type definition to properly handle the enhanced virtual items
  155:   type VirtualRow = {
  156:     index: number;
  157:     start: number;
  158:     size: number;
  159:     measureRef?: (el: HTMLElement | null) => void;
  160:     original?: Row<unknown>;
  161:     isScrolling?: boolean;
  162:     isExpanded?: boolean;
  163:     measure?: (el: HTMLElement | null) => void;
  164:   };
  165:   
  166:   // Create a row reference map outside the render loop
  167:   const rowRefs = React.useRef<Map<string, HTMLDivElement>>(new Map()).current;
  168:   
  169:   // Get alignment class - optimized to reduce calculations during scrolling
  170:   const getAlignmentClass = React.useCallback((cell: Cell<unknown, unknown>) => {
  171:     // First check cache to avoid repeated calculations
  172:     if (alignmentCache.has(cell.id)) {
  173:       return alignmentCache.get(cell.id) || '';
  174:     }
  175:     
  176:     let alignmentClass = ''
  177:     
  178:     // Check if column has explicit alignment set
  179:     const columnDef = cell.column.columnDef as unknown as { 
  180:       alignment?: 'left' | 'center' | 'right';
  181:     }
  182:     
  183:     if (columnDef.alignment) {
  184:       alignmentClass = `text-${columnDef.alignment}`
  185:     } else {
  186:       // Only run this expensive check if we're not in high performance mode
  187:       if (!highPerformanceMode) {
  188:         const value = cell.getValue()
  189:         
  190:         // Align numbers to the right
  191:         if (typeof value === 'number') {
  192:           alignmentClass = 'text-right'
  193:         }
  194:         // Optimized date check with regex first to avoid expensive Date.parse
  195:         else if (value instanceof Date || 
  196:                 (typeof value === 'string' && 
  197:                  (DATE_REGEX.test(value) || !isNaN(Date.parse(value as string))))) {
  198:           alignmentClass = 'text-center'
  199:         }
  200:       }
  201:     }
  202:     
  203:     // Cache the result to avoid recalculating
  204:     alignmentCache.set(cell.id, alignmentClass);
  205:     return alignmentClass;
  206:   }, [alignmentCache, highPerformanceMode]);
  207:   
  208:   // Function to measure a row and update its height
  209:   const measureRowHeight = React.useCallback((index: number, rowId: string) => {
  210:     const rowElement = rowRefs.get(rowId);
  211:     if (rowElement && measureRow) {
  212:       measureRow(index, rowElement);
  213:     }
  214:   }, [measureRow, rowRefs]);
  215:   
  216:   // Create a memoized row ref function generator to avoid creating it inside the render callback
  217:   const createRowRefCallback = React.useCallback((rowId: string, index: number) => {
  218:     return (el: HTMLDivElement | null) => {
  219:       if (el) {
  220:         rowRefs.set(rowId, el);
  221:         // Schedule measurement on next frame for better performance
  222:         requestAnimationFrame(() => {
  223:           measureRowHeight(index, rowId);
  224:         });
  225:       } else {
  226:         rowRefs.delete(rowId);
  227:       }
  228:     };
  229:   }, [rowRefs, measureRowHeight]);
  230: 
  231:   // Handle row expansion with performance optimizations
  232:   const handleRowExpand = React.useCallback((rowId: string) => {
  233:     if (!expanded) return;
  234:     
  235:     // Create a proper copy to avoid mutation
  236:     // Use Record<string, boolean> to ensure we have a type-safe dictionary
  237:     const newExpanded: Record<string, boolean> = {};
  238:     
  239:     // Copy existing expanded state safely, regardless of actual type
  240:     if (expanded && typeof expanded === 'object') {
  241:       Object.entries(expanded).forEach(([key, value]) => {
  242:         if (typeof value === 'boolean') {
  243:           newExpanded[key] = value;
  244:         }
  245:       });
  246:     }
  247:     
  248:     // Toggle the current row
  249:     if (newExpanded[rowId]) {
  250:       delete newExpanded[rowId];
  251:     } else {
  252:       newExpanded[rowId] = true;
  253:       // Scroll to the expanded row after a short delay to allow rendering
  254:       setTimeout(() => scrollToRowId(rowId, { align: 'center' }), 50);
  255:     }
  256:     
  257:     // Update the expanded state through the table context
  258:     table.setExpanded(newExpanded);
  259:     
  260:     // Force recalculation to account for the new heights
  261:     setTimeout(recalculate, 100);
  262:   }, [expanded, table, recalculate, scrollToRowId]);
  263: 
  264:   // Render an individual row with optimizations
  265:   const renderVirtualRow = React.useCallback((virtualRow: VirtualRow) => {
  266:     // Get the original row from the virtual item
  267:     const row = virtualRow.original || rows[virtualRow.index];
  268: 
  269: 
  270:     // Reset tracking when we're at the root level
  271:     if (row.depth === 0) {
  272:       lastParentValues.current = {}
  273:     }
  274:     
  275:     // Skip rendering if we don't have a valid row (might happen during updates)
  276:     if (!row) return null;
  277:     
  278:     // High performance rendering - reduce non-essential calculations during scrolling
  279:     const visibleCells = row.getVisibleCells();
  280:     // Note: isSelected is checked but currently not used - keeping for future styling enhancements
  281:     const isExpanded = expanded && typeof expanded === 'object' ? !!expanded[row.id] : false;
  282:     
  283:     // Determine whether the row is currently expanded
  284:     // Use memo to avoid unnecessary calculations during scrolling
  285:     const rowState = isExpanded ? "open" : "closed";
  286:     
  287:     // Get the ref callback for this row (for accurate height measurement)
  288:     const rowRefCallback = virtualRow.measure || createRowRefCallback(row.id, virtualRow.index);
  289:     
  290:     return (
  291:       <div
  292:         ref={rowRefCallback}
  293:         key={row.id}
  294:         data-row-id={row.id}
  295:         className="absolute w-full"
  296:         style={{
  297:           transform: `translateY(${virtualRow.start}px)`,
  298:           height: `${virtualRow.size}px`,
  299:           willChange: highPerformanceMode ? 'transform' : 'auto', // Optimize GPU rendering during scrolling
  300:         }}
  301:       >
  302:         <table className="w-full border-collapse">
  303:           <tbody>
  304:             <tr
  305:               data-state={rowState}
  306:               aria-expanded={isExpanded}
  307:               data-expanded={isExpanded}
  308:               className="hover:bg-muted/50 data-[state=selected]:bg-muted data-[state=open]:bg-muted/10 border-b transition-colors h-8"
  309:             >
  310:               {visibleCells.map((cell: Cell<unknown, unknown>, cellIndex: number) => {
  311:                 const alignmentClass = getAlignmentClass(cell);
  312:                 const isGroupedColumn = grouping.includes(cell.column.id);
  313:                 
  314:                 // Check if this cell has expansion capability
  315:                 const hasExpandControl = cellIndex === 0 && row.getCanExpand();
  316: 
  317:                 return (
  318:                   <td 
  319:                     key={cell.id}
  320:                     className={`p-1 py-1 align-middle ${alignmentClass} ${isGroupedColumn ? "font-medium" : ""}`}
  321:                   >
  322:                     {/* Render with proper padding for depth and expansion controls */}
  323:                     <div className="flex items-center" style={{ paddingLeft: cellIndex === 0 ? `${row.depth * 1}rem` : 0 }}>
  324:                       {/* Render expansion button if this is an expandable cell */}
  325:                       {hasExpandControl && cellIndex === 0 && (
  326:                         <button
  327:                           type="button"
  328:                           onClick={() => handleRowExpand(row.id)}
  329:                           aria-label={isExpanded ? "Collapse row" : "Expand row"}
  330:                           className="mr-2 rounded-sm p-1 hover:bg-muted"
  331:                         >
  332:                           <span className="transform transition-transform duration-200" 
  333:                                 style={{ display: 'inline-block', transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)' }}>
  334:                             →
  335:                           </span>
  336:                         </button>
  337:                       )}
  338:                       
  339:                       {/* Only render actual cell component if not in high-performance scrolling mode 
  340:                           or if it's a critical cell (e.g., first few columns) */}
  341:                       {(!highPerformanceMode && !virtualRow.isScrolling) || cellIndex < 3 ? (
  342:                         <DataTablePartCell cell={cell} />
  343:                       ) : (
  344:                         // Simplified placeholder during fast scrolling
  345:                         <span className="opacity-80">
  346:                           {typeof cell.getValue() === 'number' ? '0' : '...'}
  347:                         </span>
  348:                       )}
  349:                     </div>
  350:                   </td>
  351:                 )
  352:               })}
  353:             </tr>
  354:           </tbody>
  355:         </table>
  356:       </div>
  357:     )
  358:   }, [getAlignmentClass, lastParentValues, grouping, expanded, highPerformanceMode, createRowRefCallback, handleRowExpand, rows]);
  359: 
  360:   // Create a virtualized table body using a wrapper approach
  361:   if (isVirtualized) {
  362:     // Return the virtualized wrapper around the content
  363:     return (
  364:       <div className="relative">
  365:         {/* Table for headers (fixed) */}
  366:         <table className="w-full caption-bottom text-sm">
  367:           <TableHeaderComponent />
  368:         </table>
  369:         
  370:         {/* The virtualized table body with content */}
  371:         <div 
  372:           style={{ 
  373:             height: effectiveTableHeight,
  374:             position: 'relative'
  375:           }}
  376:         >
  377:           <div 
  378:             ref={parentRef} 
  379:             className="overflow-auto absolute inset-0"
  380:           >
  381:             <table className="w-full caption-bottom text-sm">
  382:               <tbody className="[&_tr:last-child]:border-0">
  383:                 {/* Empty row for spacing to ensure alignment */}
  384:                 <tr style={{ height: `${totalSize}px` }}>
  385:                   <td colSpan={schema.columns.length} style={{ padding: 0, border: 'none' }}>
  386:                     {/* Optimized virtualized row rendering */}
  387:                     {virtualRows.map((virtualRow) => renderVirtualRow(virtualRow))}
  388:                   </td>
  389:                 </tr>
  390:               </tbody>
  391:             </table>
  392:           </div>
  393:         </div>
  394:       </div>
  395:     )
  396:   }
  397: 
  398:   // Standard non-virtualized rendering
  399:   return (
  400:     <TableBody>
  401:       {rows.map((row: Row<unknown>) => {
  402:         // Reset tracking when we're at the root level
  403:         if (row.depth === 0) {
  404:           lastParentValues.current = {}
  405:         }
  406: 
  407:         return (
  408:           <TableRow
  409:             key={row.id}
  410:             data-state={row.getIsSelected() && "selected"}
  411:             className="h-8"
  412:           >
  413:             {row.getVisibleCells().map((cell: Cell<unknown, unknown>, cellIndex: number) => {
  414:               // Determine alignment class
  415:               let alignmentClass = ''
  416:               
  417:               // Check if column has explicit alignment set
  418:               const columnDef = cell.column.columnDef as unknown as { 
  419:                 alignment?: 'left' | 'center' | 'right';
  420:               }
  421:               if (columnDef.alignment) {
  422:                 alignmentClass = `text-${columnDef.alignment}`
  423:               }
  424:               // Otherwise use auto-detection based on data type
  425:               else {
  426:                 const value = cell.getValue()
  427:                 
  428:                 // Align numbers to the right
  429:                 if (typeof value === 'number') {
  430:                   alignmentClass = 'text-right'
  431:                 }
  432:                 // Align dates to the center
  433:                 else if (value instanceof Date || (typeof value === 'string' && !isNaN(Date.parse(value as string)))) {
  434:                   alignmentClass = 'text-center'
  435:                 }
  436:               }
  437: 
  438:               const isGroupedColumn = grouping.includes(cell.column.id)
  439:               
  440:               return (
  441:                 <TableCell 
  442:                   key={cell.id}
  443:                   className={`p-1 py-1 align-middle ${alignmentClass} ${isGroupedColumn ? "font-medium" : ""}`}
  444:                 >
  445:                   {/* Render with proper padding for depth */}
  446:                   <span style={{ paddingLeft: cellIndex === 0 ? `${row.depth * 1}rem` : 0 }}>
  447:                     <DataTablePartCell cell={cell} />
  448:                   </span>
  449:                 </TableCell>
  450:               )
  451:             })}
  452:           </TableRow>
  453:         )
  454:       })}
  455:     </TableBody>
  456:   )
  457: } 

================================================================================
File: parts/table-configuration-panel.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Table Configuration Panel Module
    5:  * 
    6:  * This module provides components for managing table row grouping and column visibility/order 
    7:  * through a user interface. It includes draggable lists for active groups and visible columns,
    8:  * and controls for adding/removing items.
    9:  * 
   10:  * Features:
   11:  * - Drag-and-drop group reordering
   12:  * - Drag-and-drop column reordering/visibility control
   13:  * - Visual configuration management
   14:  * - Group/Column addition/removal
   15:  * - Keyboard accessibility
   16:  * - Responsive design
   17:  * 
   18:  * @module data-table/parts/table-configuration-panel
   19:  */
   20: 
   21: import * as React from "react"
   22: import {
   23:   DndContext,
   24:   closestCenter,
   25:   KeyboardSensor,
   26:   PointerSensor,
   27:   useSensor,
   28:   useSensors,
   29:   DragEndEvent,
   30:   UniqueIdentifier,
   31: } from "@dnd-kit/core"
   32: import {
   33:   arrayMove,
   34:   SortableContext,
   35:   sortableKeyboardCoordinates,
   36:   useSortable,
   37:   verticalListSortingStrategy,
   38: } from "@dnd-kit/sortable"
   39: import { CSS } from "@dnd-kit/utilities"
   40: import type {
   41:   GroupingState,
   42:   ColumnOrderState,
   43:   VisibilityState,
   44:   Updater,
   45: } from "@tanstack/react-table"
   46: 
   47: import { GripVertical, Plus, X } from "lucide-react"
   48: import {
   49:   Select,
   50:   SelectContent,
   51:   SelectItem,
   52:   SelectTrigger,
   53:   SelectValue,
   54: } from "@/components/ui/select"
   55: // Renamed GroupableColumn to ConfigurableColumn for broader scope
   56: import type { GroupableColumn as ConfigurableColumn } from "../types"
   57: import { Button } from "@/components/ui/button"
   58: import { Badge } from "@/components/ui/badge"
   59: import { cn } from "@/lib/utils"
   60: 
   61: /**
   62:  * Props for the SortableItem component
   63:  */
   64: interface SortableItemProps {
   65:   /** Unique identifier for the item (column ID) */
   66:   id: UniqueIdentifier
   67:   /** Display label for the item */
   68:   label: string
   69:   /** Callback function when the item is removed */
   70:   onRemove: (id: string) => void
   71:   /** Optional flag indicating if the item is currently grouped */
   72:   isGrouped?: boolean
   73: }
   74: 
   75: /**
   76:  * Sortable Item Component
   77:  * 
   78:  * A draggable item representing a group or a visible column in the configuration panel. 
   79:  * It includes a drag handle, label, and remove button.
   80:  * 
   81:  * @param props Component properties
   82:  */
   83: const SortableItem = ({ id, label, onRemove, isGrouped }: SortableItemProps) => {
   84:   const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id })
   85: 
   86:   const style = {
   87:     transform: CSS.Transform.toString(transform),
   88:     transition,
   89:   }
   90: 
   91:   const handleRemove = React.useCallback(() => {
   92:     onRemove(id as string)
   93:   }, [id, onRemove])
   94: 
   95:   return (
   96:     <div
   97:       ref={setNodeRef}
   98:       style={style}
   99:       className={cn(
  100:         "flex h-7 max-w-xs items-center gap-1 rounded-md bg-accent px-2 py-1 text-sm text-accent-foreground",
  101:         isGrouped && "bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200" // Conditional styling
  102:       )}
  103:       title={label}
  104:     >
  105:       <span
  106:         {...attributes}
  107:         {...listeners}
  108:         className="cursor-grab touch-none p-1 flex-shrink-0"
  109:         aria-label={`Drag ${label}`}
  110:       >
  111:         <GripVertical className="h-4 w-4" />
  112:       </span>
  113:       <span className="select-none truncate flex-grow min-w-0">{label}</span>
  114:       <Button
  115:         variant="ghost"
  116:         size="icon"
  117:         className="ml-1 h-6 w-6 hover:bg-muted flex-shrink-0"
  118:         onClick={handleRemove}
  119:         aria-label={`Remove ${label}`}
  120:       >
  121:         <X className="h-3.5 w-3.5" />
  122:       </Button>
  123:     </div>
  124:   )
  125: }
  126: 
  127: /**
  128:  * Props for the TableConfigurationPanel component
  129:  */
  130: interface TableConfigurationPanelProps {
  131:   /** List of columns that can be configured (grouped, ordered, visibility toggled) */
  132:   configurableColumns: ConfigurableColumn[]
  133:   /** Current grouping state */
  134:   grouping: GroupingState
  135:   /** Callback function when grouping changes */
  136:   onGroupingChange: (grouping: GroupingState) => void
  137:   /** Current column order state (represents visible, ordered columns) */
  138:   columnOrder: ColumnOrderState
  139:   /** Callback function when column order changes */
  140:   onColumnOrderChange: (order: ColumnOrderState) => void
  141:   /** Current column visibility state */
  142:   columnVisibility: VisibilityState
  143:   /** Callback function when column visibility changes */
  144:   onColumnVisibilityChange: (updater: Updater<VisibilityState>) => void
  145: }
  146: 
  147: /**
  148:  * Table Configuration Panel Component
  149:  * 
  150:  * A panel component providing a UI for managing table row grouping and column visibility/order.
  151:  * Allows users to add, remove, and reorder groups and visible columns via drag-and-drop.
  152:  * 
  153:  * @param props Component properties
  154:  */
  155: export function TableConfigurationPanel({
  156:   configurableColumns,
  157:   grouping,
  158:   onGroupingChange,
  159:   columnOrder,
  160:   onColumnOrderChange,
  161:   columnVisibility,
  162:   onColumnVisibilityChange,
  163: }: TableConfigurationPanelProps) {
  164:   // DnD hook instance for Grouping
  165:   const { 
  166:     sensors: groupingSensors, 
  167:     handleDragEnd: handleGroupingDragEnd 
  168:   } = useConfigurationDnD(grouping, onGroupingChange)
  169:   
  170:   // DnD hook instance for Column Order
  171:   const { 
  172:     sensors: columnOrderSensors, 
  173:     handleDragEnd: handleColumnOrderDragEnd 
  174:   } = useConfigurationDnD(columnOrder, onColumnOrderChange)
  175: 
  176:   // Filter columnOrder based on visibility before using it
  177:   const visibleOrderedColumns = React.useMemo(() => 
  178:     columnOrder.filter(id => columnVisibility[id] !== false),
  179:     [columnOrder, columnVisibility]
  180:   );
  181: 
  182:   // Memoized active group items for DnD
  183:   const activeGroupItems = React.useMemo(() => grouping.map(id => ({ id })), [grouping])
  184:   
  185:   // Memoized active column order items for DnD (use filtered list)
  186:   const activeColumnOrderItems = React.useMemo(() => visibleOrderedColumns.map(id => ({ id })), [visibleOrderedColumns])
  187: 
  188:   // --- Grouping Callbacks ---
  189:   const handleRemoveGroup = React.useCallback((columnId: string) => {
  190:     onGroupingChange(grouping.filter((g) => g !== columnId))
  191:   }, [grouping, onGroupingChange])
  192: 
  193:   const handleAddGroup = React.useCallback((columnId: string) => {
  194:     // Ensure the selected column is actually groupable
  195:     const column = configurableColumns.find(c => c.id === columnId)
  196:     // Assuming any column in configurableColumns can be grouped, 
  197:     // or filtering happens in the parent component.
  198:     if (column && !grouping.includes(columnId)) {
  199:       onGroupingChange([...grouping, columnId])
  200:     }
  201:   }, [grouping, onGroupingChange, configurableColumns])
  202: 
  203:   // Filter the full list of configurable columns to find those available for grouping
  204:   const columnsToAddForGrouping = React.useMemo(() => 
  205:     configurableColumns.filter(
  206:       (column) => column.isGroupable && !grouping.includes(column.id)
  207:     ),
  208:     [configurableColumns, grouping] // Use configurableColumns and grouping as dependencies
  209:   )
  210: 
  211:   // --- Column Order Callbacks ---
  212:   const handleRemoveColumnFromOrder = React.useCallback((columnId: string) => {
  213:     onColumnOrderChange(columnOrder.filter((id) => id !== columnId))
  214:     onColumnVisibilityChange((old) => ({ ...old, [columnId]: false }))
  215:   }, [columnOrder, onColumnOrderChange, onColumnVisibilityChange])
  216: 
  217:   const handleAddColumnToOrder = React.useCallback((columnId: string) => {
  218:     if (columnId) { // Basic check that we have an ID
  219:       // Always ensure the column is marked as visible
  220:       onColumnVisibilityChange((old) => ({ ...old, [columnId]: true }));
  221:       
  222:       // If the column isn't already in the order, add it to the end
  223:       if (!columnOrder.includes(columnId)) {
  224:         onColumnOrderChange([...columnOrder, columnId]);
  225:       }
  226:     }
  227:   }, [columnOrder, onColumnOrderChange, onColumnVisibilityChange]);
  228: 
  229:   const columnsToAddForOrdering = React.useMemo(() =>
  230:     // Filter columns that are explicitly marked as hidden in the visibility state
  231:     configurableColumns.filter(
  232:       (column) => columnVisibility[column.id] === false
  233:     ),
  234:     [configurableColumns, columnVisibility]
  235:   )
  236: 
  237:   // Find column label helper
  238:   const getColumnLabel = (columnId: string): string => {
  239:     return configurableColumns.find(col => col.id === columnId)?.label ?? columnId
  240:   }
  241: 
  242:   return (
  243:     <div className="flex flex-col gap-6 p-1">
  244:       {/* Grouping Section */}
  245:       <div className="space-y-3 border-b pb-6">
  246:         <h3 className="text-sm font-medium text-foreground">Grouping</h3>
  247:         <div className="space-y-2">
  248:           <span className="text-xs font-medium text-muted-foreground">Active groups (drag to reorder):</span>
  249:           {grouping.length > 0 ? (
  250:             <DndContext
  251:               sensors={groupingSensors}
  252:               collisionDetection={closestCenter}
  253:               onDragEnd={handleGroupingDragEnd}
  254:             >
  255:               <SortableContext items={activeGroupItems} strategy={verticalListSortingStrategy}>
  256:                 <div className="flex flex-wrap gap-2">
  257:                   {grouping.map((columnId) => (
  258:                     <SortableItem 
  259:                       key={columnId} 
  260:                       id={columnId} 
  261:                       label={getColumnLabel(columnId)} 
  262:                       onRemove={handleRemoveGroup} 
  263:                     />
  264:                   ))}
  265:                 </div>
  266:               </SortableContext>
  267:               <div className="pt-2 text-xs text-muted-foreground">
  268:                 Drag grip to reorder • Click X to remove
  269:               </div>
  270:             </DndContext>
  271:           ) : (
  272:             <Badge variant="outline" className="text-xs font-normal">
  273:               No grouping applied
  274:             </Badge>
  275:           )}
  276:         </div>
  277:         {columnsToAddForGrouping.length > 0 && (
  278:           <div className="space-y-2">
  279:             <span className="text-xs font-medium text-muted-foreground">Add group:</span>
  280:             <Select value="" onValueChange={handleAddGroup}>
  281:               <SelectTrigger className="h-8 text-sm max-w-xs">
  282:                 <div className="flex items-center gap-2">
  283:                   <Plus className="h-4 w-4" />
  284:                   <SelectValue placeholder="Select column to group by..." />
  285:                 </div>
  286:               </SelectTrigger>
  287:               <SelectContent>
  288:                 {columnsToAddForGrouping.map((column) => (
  289:                   <SelectItem key={column.id} value={column.id}>
  290:                     {column.label}
  291:                   </SelectItem>
  292:                 ))}
  293:               </SelectContent>
  294:             </Select>
  295:           </div>
  296:         )}
  297:       </div>
  298: 
  299:       {/* Column Visibility & Order Section */}
  300:       <div className="space-y-3">
  301:          <h3 className="text-sm font-medium text-foreground">Visible Columns</h3>
  302:          <div className="space-y-2">
  303:           <span className="text-xs font-medium text-muted-foreground">Visible columns (drag to reorder):</span>
  304:           {columnOrder.length > 0 ? (
  305:             <DndContext
  306:               sensors={columnOrderSensors}
  307:               collisionDetection={closestCenter}
  308:               onDragEnd={handleColumnOrderDragEnd}
  309:             >
  310:               <SortableContext items={activeColumnOrderItems} strategy={verticalListSortingStrategy}>
  311:                 <div className="flex flex-wrap gap-2">
  312:                   {visibleOrderedColumns.map((columnId) => (
  313:                      <SortableItem 
  314:                       key={columnId} 
  315:                       id={columnId} 
  316:                       label={getColumnLabel(columnId)} 
  317:                       onRemove={handleRemoveColumnFromOrder} 
  318:                       isGrouped={grouping.includes(columnId)} // Pass the isGrouped prop
  319:                     />
  320:                   ))}
  321:                 </div>
  322:               </SortableContext>
  323:                <div className="pt-2 text-xs text-muted-foreground">
  324:                 Drag grip to reorder • Click X to hide
  325:               </div>
  326:               <div className="pt-1 text-xs text-blue-600">
  327:                 Note: Blue items are grouped and always appear first, ordered by group sequence.
  328:               </div>
  329:             </DndContext>
  330:           ) : (
  331:              <Badge variant="outline" className="text-xs font-normal">
  332:               No columns visible
  333:             </Badge>
  334:           )}
  335:         </div>
  336:          {columnsToAddForOrdering.length > 0 && (
  337:           <div className="space-y-2">
  338:             <span className="text-xs font-medium text-muted-foreground">Show column:</span>
  339:             <Select value="" onValueChange={handleAddColumnToOrder}>
  340:               <SelectTrigger className="h-8 text-sm max-w-xs">
  341:                  <div className="flex items-center gap-2">
  342:                   <Plus className="h-4 w-4" />
  343:                   <SelectValue placeholder="Select column to show..." />
  344:                 </div>
  345:               </SelectTrigger>
  346:               <SelectContent>
  347:                 {columnsToAddForOrdering.map((column) => (
  348:                   <SelectItem key={column.id} value={column.id}>
  349:                     {column.label}
  350:                   </SelectItem>
  351:                 ))}
  352:               </SelectContent>
  353:             </Select>
  354:           </div>
  355:         )}
  356:       </div>
  357:     </div>
  358:   )
  359: }
  360: 
  361: /**
  362:  * Hook to manage drag-and-drop state and logic for configuration lists (grouping, column order).
  363:  * @param items Current list of item IDs (e.g., column IDs).
  364:  * @param onItemsChange Callback to update the list state.
  365:  * @returns DndContext sensors and handleDragEnd function.
  366:  */
  367: function useConfigurationDnD(
  368:   items: string[], // Generalized from GroupingState
  369:   onItemsChange: (items: string[]) => void // Generalized from onGroupingChange
  370: ) {
  371:   const sensors = useSensors(
  372:     useSensor(PointerSensor),
  373:     useSensor(KeyboardSensor, {
  374:       coordinateGetter: sortableKeyboardCoordinates,
  375:     })
  376:   )
  377: 
  378:   const handleDragEnd = React.useCallback(
  379:     (event: DragEndEvent) => {
  380:       const { active, over } = event
  381:       
  382:       if (over && active.id !== over.id) {
  383:         const oldIndex = items.indexOf(active.id as string)
  384:         const newIndex = items.indexOf(over.id as string)
  385:         
  386:         if (oldIndex !== -1 && newIndex !== -1) {
  387:           onItemsChange(arrayMove(items, oldIndex, newIndex))
  388:         }
  389:       }
  390:     },
  391:     [items, onItemsChange] // Updated dependencies
  392:   )
  393: 
  394:   return { sensors, handleDragEnd }
  395: } 

================================================================================
File: parts/table-header.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * Table Header Module
    5:  * 
    6:  * This module provides the table header component that renders column headers and
    7:  * their associated controls. It handles header rendering, alignment, and integration
    8:  * with the table's sorting and filtering functionality.
    9:  * 
   10:  * Features:
   11:  * - Column header rendering
   12:  * - Custom alignment support
   13:  * - Placeholder handling
   14:  * - Responsive design
   15:  * - Accessibility support
   16:  * 
   17:  * @module data-table/parts/table-header
   18:  */
   19: 
   20: import * as React from "react"
   21: import { flexRender, HeaderGroup, Header, Table } from "@tanstack/react-table"
   22: import { useDataTable } from "../core/context"
   23: import { DataTableColumnDef } from "../types"
   24: import { TableHead, TableHeader, TableRow } from "@/components/ui/table"
   25: 
   26: /**
   27:  * Table Header Component
   28:  * 
   29:  * Renders the header section of the data table, including column headers and their
   30:  * associated controls. The component supports custom alignment and placeholder handling.
   31:  * 
   32:  * Features:
   33:  * - Column header rendering
   34:  * - Custom alignment support (left, center, right)
   35:  * - Placeholder handling
   36:  * - Responsive design
   37:  * - Accessibility support
   38:  * 
   39:  * The component automatically:
   40:  * - Renders all header groups
   41:  * - Applies column alignment
   42:  * - Handles placeholder headers
   43:  * - Integrates with table context
   44:  * 
   45:  * @example
   46:  * ```tsx
   47:  * // Basic usage
   48:  * <TableHeader />
   49:  * 
   50:  * // With custom alignment
   51:  * const columns = [
   52:  *   {
   53:  *     id: 'name',
   54:  *     header: 'Name',
   55:  *     alignment: 'left'
   56:  *   },
   57:  *   {
   58:  *     id: 'value',
   59:  *     header: 'Value',
   60:  *     alignment: 'right'
   61:  *   }
   62:  * ]
   63:  * ```
   64:  */
   65: export const TableHeaderComponent = React.memo(
   66:   function TableHeaderComponentInner() {
   67:     const { table } = useDataTable<unknown>()
   68:     const typedTable = table as Table<unknown>
   69:   
   70:     return (
   71:       <TableHeader>
   72:         {typedTable.getHeaderGroups().map((headerGroup: HeaderGroup<unknown>) => (
   73:           <TableRow key={headerGroup.id}>
   74:             {headerGroup.headers.map((header: Header<unknown, unknown>) => {
   75:               const columnDef = header.column.columnDef as DataTableColumnDef<unknown>
   76:               const alignmentClass = columnDef.alignment ? `text-${columnDef.alignment}` : 'text-left';
   77:               
   78:               return (
   79:                 <TableHead 
   80:                   key={header.id} 
   81:                   className={`p-2 align-middle ${alignmentClass}`}
   82:                   style={{ width: header.getSize() !== 150 ? header.getSize() : undefined }}
   83:                 >
   84:                   {header.isPlaceholder ? null : (
   85:                     flexRender(
   86:                       header.column.columnDef.header,
   87:                       header.getContext()
   88:                     )
   89:                   )}
   90:                 </TableHead>
   91:               )
   92:             })}
   93:           </TableRow>
   94:         ))}
   95:       </TableHeader>
   96:     )
   97:   },
   98:   // We don't need to provide a custom comparison function since the component 
   99:   // should re-render whenever any of the header-related states change, which is
  100:   // handled through the context
  101: ) 

================================================================================
File: parts/toolbar.tsx
================================================================================

    1: "use client"
    2: 
    3: /**
    4:  * @module data-table/parts/toolbar
    5:  * @description Provides the table toolbar with global search, export, and grouping controls.
    6:  */
    7: 
    8: // React + Lib Imports
    9: import * as React from "react"
   10: import { Settings, Download } from "lucide-react"
   11: 
   12: // Internal Imports
   13: import { useDataTable } from "../core/context"
   14: import { TableConfigurationPanel } from "./table-configuration-panel"
   15: import { getGroupableColumns } from "../schema" // Assuming this utility handles schema logic
   16: import { hasAccessorKey, exportToCSV } from "../utils" // Assuming general utils
   17: import type { GroupableColumn as ConfigurableColumn } from "../types"
   18: 
   19: // UI Imports
   20: import { Input } from "@/components/ui/input"
   21: import { Button } from "@/components/ui/button"
   22: import { Badge } from "@/components/ui/badge"
   23: import {
   24:   Dialog,
   25:   DialogContent,
   26:   DialogDescription,
   27:   DialogHeader,
   28:   DialogTitle,
   29:   DialogTrigger,
   30: } from "@/components/ui/dialog"
   31: 
   32: /**
   33:  * Renders the toolbar for the data table.
   34:  * Includes optional global filter input, CSV export button, and grouping dialog trigger/content.
   35:  * Feature visibility is controlled by flags in the table schema.
   36:  */
   37: export function Toolbar<TData>() {
   38:   // --- State & Hooks ---
   39:   const {
   40:     schema,
   41:     data,
   42:     globalFilter,
   43:     setGlobalFilter,
   44:     grouping,
   45:     setGrouping,
   46:     columnOrder,
   47:     setColumnOrder,
   48:     columnVisibility,
   49:     setColumnVisibility,
   50:   } = useDataTable<TData>()
   51: 
   52:   const [isGroupingDialogOpen, setIsGroupingDialogOpen] = React.useState(false)
   53: 
   54:   // Local state for debounced filter input
   55:   const [filterValue, setFilterValue] = React.useState(globalFilter || "")
   56:   
   57:   // Reference for debouncing timeout
   58:   const filterTimeoutRef = React.useRef<NodeJS.Timeout | null>(null)
   59:   
   60:   // Update local state when global filter changes externally
   61:   React.useEffect(() => {
   62:     setFilterValue(globalFilter || "")
   63:   }, [globalFilter])
   64:   
   65:   // Clean up timeout on unmount
   66:   React.useEffect(() => {
   67:     return () => {
   68:       if (filterTimeoutRef.current) {
   69:         clearTimeout(filterTimeoutRef.current)
   70:       }
   71:     }
   72:   }, [])
   73: 
   74:   // --- Memoized Calculations ---
   75:   // Get groupable column IDs (still needed for checking below)
   76:   const groupableColumns = React.useMemo(() => getGroupableColumns(schema), [schema])
   77: 
   78:   // Create a list of ALL columns with labels and groupable status
   79:   const configurableColumnObjects = React.useMemo(() => {
   80:     // Map over all columns defined in the schema
   81:     return schema.columns.map(colDef => {
   82:       const columnId = colDef.id || (hasAccessorKey(colDef) ? colDef.accessorKey : undefined);
   83:       
   84:       // Skip if we can't determine a column ID
   85:       if (!columnId) return null;
   86: 
   87:       // Determine if the column is groupable (using the pre-calculated list)
   88:       const isGroupable = groupableColumns.includes(columnId);
   89: 
   90:       // Generate label from header or fallback to capitalized ID
   91:       const label = typeof colDef.header === 'string' 
   92:         ? colDef.header 
   93:         : (columnId.charAt(0).toUpperCase() + columnId.slice(1));
   94: 
   95:       return {
   96:         id: columnId,
   97:         label: label,
   98:         isGroupable: isGroupable // <-- Add groupable status
   99:       }
  100:     }).filter(Boolean); // Filter out any null entries
  101:   }, [schema, groupableColumns]) // Update dependencies
  102: 
  103:   // --- Event Handlers ---
  104:   const handleExportCSV = React.useCallback(() => {
  105:     // Pass necessary data to the utility function
  106:     exportToCSV(data, schema.columns, 'table-export') 
  107:   }, [data, schema.columns]) // Dependencies for export
  108: 
  109:   // Handle input change with debouncing
  110:   const handleGlobalFilterChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
  111:     const newValue = e.target.value
  112:     setFilterValue(newValue)
  113:     
  114:     // Clear any existing timeout
  115:     if (filterTimeoutRef.current) {
  116:       clearTimeout(filterTimeoutRef.current)
  117:     }
  118:     
  119:     // Set new timeout for the filter update
  120:     const debounceMs = schema.filterDebounceMs || 300
  121:     filterTimeoutRef.current = setTimeout(() => {
  122:       setGlobalFilter(newValue || "")
  123:     }, debounceMs)
  124:   }, [setGlobalFilter, schema.filterDebounceMs])
  125:   
  126:   // Apply filter immediately on key press
  127:   const handleFilterKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
  128:     if (e.key === 'Enter') {
  129:       // Clear any pending timeout
  130:       if (filterTimeoutRef.current) {
  131:         clearTimeout(filterTimeoutRef.current)
  132:       }
  133:       
  134:       // Apply filter immediately
  135:       setGlobalFilter(filterValue || "")
  136:     }
  137:   }, [setGlobalFilter, filterValue])
  138: 
  139:   // --- Render Logic ---
  140:   const showGlobalFilter = schema.enableGlobalFilter !== false;
  141:   const showExport = schema.enableExport !== false;
  142:   const showGrouping = schema.enableGrouping && groupableColumns.length > 0;
  143: 
  144:   return (
  145:     <div className="flex items-center justify-between py-2">
  146:       {/* Left Side: Global Filter */}
  147:       <div className="flex items-center gap-1">
  148:         {showGlobalFilter && (
  149:           <Input
  150:             placeholder="Search all columns..."
  151:             value={filterValue}
  152:             onChange={handleGlobalFilterChange}
  153:             onKeyDown={handleFilterKeyDown}
  154:             className="h-8 w-48 sm:w-64 text-sm"
  155:           />
  156:         )}
  157:       </div>
  158: 
  159:       {/* Right Side: Actions */}
  160:       <div className="flex items-center gap-2">
  161:         {/* Export CSV Button */}
  162:         {showExport && (
  163:           <Button
  164:             variant="outline"
  165:             size="sm"
  166:             className="h-8 gap-1 text-sm"
  167:             onClick={handleExportCSV}
  168:           >
  169:             <Download className="h-3.5 w-3.5" />
  170:             <span className="hidden sm:inline">Export CSV</span>
  171:           </Button>
  172:         )}
  173: 
  174:         {/* Grouping Dialog Trigger/Content */}
  175:         {showGrouping && (
  176:           <Dialog open={isGroupingDialogOpen} onOpenChange={setIsGroupingDialogOpen}>
  177:             <DialogTrigger asChild>
  178:               <Button 
  179:                 variant="outline" 
  180:                 size="sm" 
  181:                 className="h-8 gap-1 text-sm"
  182:               >
  183:                 <Settings className="h-3.5 w-3.5" />
  184:                 <span className="hidden sm:inline">Configure</span>
  185:                 {grouping.length > 0 && (
  186:                   <Badge 
  187:                     variant="secondary" 
  188:                     className="ml-1.5 rounded-sm px-1.5 font-normal text-xs"
  189:                   >
  190:                     {grouping.length}
  191:                   </Badge>
  192:                 )}
  193:               </Button>
  194:             </DialogTrigger>
  195:             <DialogContent className="sm:max-w-md">
  196:               <DialogHeader>
  197:                 <DialogTitle>Configure Table</DialogTitle>
  198:                 <DialogDescription>
  199:                   Manage column visibility, order, and grouping. Drag items to reorder.
  200:                 </DialogDescription>
  201:               </DialogHeader>
  202:               <TableConfigurationPanel
  203:                 configurableColumns={configurableColumnObjects as ConfigurableColumn[]}
  204:                 grouping={grouping}
  205:                 onGroupingChange={setGrouping}
  206:                 columnOrder={columnOrder}
  207:                 onColumnOrderChange={setColumnOrder}
  208:                 columnVisibility={columnVisibility}
  209:                 onColumnVisibilityChange={setColumnVisibility}
  210:               />
  211:             </DialogContent>
  212:           </Dialog>
  213:         )}
  214:       </div>
  215:     </div>
  216:   )
  217: } 

================================================================================
File: schema/column-serialization.tsx
================================================================================

    1: /**
    2:  * Column Schema Serialization Module
    3:  * 
    4:  * This module provides functionality for persisting and loading table column schemas.
    5:  * It enables saving and loading column configurations, including customizations
    6:  * like sorting, filtering, and aggregation settings.
    7:  * 
    8:  * @module serialized-columns
    9:  */
   10: 
   11: "use client"
   12: 
   13: import { deserializeSchema } from "./serialization"
   14: import { SerializableDataTableSchema } from "../types"
   15: import { getGlobalCellRendererRegistry } from "@/components/data-table/cell-renderers"
   16: 
   17: /**
   18:  * Saves a table schema to a file via API.
   19:  * This function serializes the current table configuration and persists it
   20:  * for later use, allowing users to save their customizations.
   21:  * 
   22:  * Features:
   23:  * - Schema validation before saving
   24:  * - Error handling with detailed messages
   25:  * - Success confirmation with file path
   26:  * - JSON serialization of complex objects
   27:  * 
   28:  * @param schemaName Unique identifier for the schema
   29:  * @param schema The table schema configuration to save
   30:  * 
   31:  * @returns Promise resolving to success status and saved file path
   32:  * 
   33:  * @example
   34:  * ```tsx
   35:  * try {
   36:  *   const result = await saveSchemaToFile('users-table', {
   37:  *     columns: [...],
   38:  *     sorting: [...],
   39:  *     filters: [...]
   40:  *   });
   41:  *   console.log('Schema saved to:', result.path);
   42:  * } catch (error) {
   43:  *   console.error('Failed to save schema:', error);
   44:  * }
   45:  * ```
   46:  * 
   47:  * @throws Error if schema saving fails
   48:  */
   49: export async function saveSchemaToFile(schemaName: string, schema: SerializableDataTableSchema) {
   50:   try {
   51:     const response = await fetch('/api/schemas/save', {
   52:       method: 'POST',
   53:       headers: {
   54:         'Content-Type': 'application/json',
   55:       },
   56:       body: JSON.stringify({ schemaName, schema }),
   57:     })
   58: 
   59:     if (!response.ok) {
   60:       throw new Error('Failed to save schema')
   61:     }
   62: 
   63:     const result = await response.json()
   64:     return { success: true, path: result.path }
   65:   } catch (error) {
   66:     console.error('Error saving schema:', error)
   67:     throw error
   68:   }
   69: }
   70: 
   71: /**
   72:  * Loads a table schema from a file via API.
   73:  * This function retrieves and deserializes a previously saved table configuration,
   74:  * restoring all column settings and customizations.
   75:  * 
   76:  * Features:
   77:  * - Type-safe schema deserialization
   78:  * - Cell renderer registry integration
   79:  * - Error handling with context
   80:  * - Automatic schema validation
   81:  * 
   82:  * @template TData The type of data in the table rows
   83:  * @param schemaName The identifier of the schema to load
   84:  * 
   85:  * @returns Promise resolving to the deserialized table schema
   86:  * 
   87:  * @example
   88:  * ```tsx
   89:  * try {
   90:  *   const schema = await loadSchemaFromFile<User>('users-table');
   91:  *   setTableSchema(schema);
   92:  * } catch (error) {
   93:  *   console.error('Failed to load schema:', error);
   94:  * }
   95:  * ```
   96:  * 
   97:  * @throws Error if schema loading or deserialization fails
   98:  */
   99: export async function loadSchemaFromFile<TData>(schemaName: string) {
  100:   try {
  101:     const response = await fetch(`/api/schemas/load?name=${encodeURIComponent(schemaName)}`)
  102:     
  103:     if (!response.ok) {
  104:       throw new Error('Failed to load schema')
  105:     }
  106: 
  107:     const serialized = await response.json()
  108:     const registry = getGlobalCellRendererRegistry()
  109:     return deserializeSchema<TData>(serialized, registry)
  110:   } catch (error) {
  111:     console.error(`Error loading schema ${schemaName}:`, error)
  112:     throw new Error(`Failed to load schema: ${schemaName}`)
  113:   }
  114: } 

================================================================================
File: schema/index.ts
================================================================================

    1: /**
    2:  * Schema Module
    3:  * 
    4:  * This module provides the core schema functionality for the data table system.
    5:  * It includes utilities for schema management, serialization, and building table
    6:  * configurations.
    7:  * 
    8:  * Key Components:
    9:  * - Schema Utilities: Helper functions for schema manipulation and validation
   10:  * - Serialization: Functions for converting schemas to/from different formats
   11:  * - Schema Builder: Tools for programmatically creating and modifying schemas
   12:  * - Column Serialization: Functions for saving and loading column schema configurations
   13:  * 
   14:  * Features:
   15:  * - Type-safe schema definitions
   16:  * - Schema validation and normalization
   17:  * - Serialization/deserialization support
   18:  * - Programmatic schema building
   19:  * - Column configuration management
   20:  * - Schema persistence
   21:  * 
   22:  * @module data-table/schema
   23:  */
   24: 
   25: export * from "./schema-utils"
   26: export * from "./serialization"
   27: export * from "./schema-builder"
   28: export * from "./column-serialization" 

================================================================================
File: schema/schema-builder.ts
================================================================================

    1: /**
    2:  * Schema Builder Module
    3:  * 
    4:  * This module provides a fluent API for building data table schemas programmatically.
    5:  * It offers a type-safe and intuitive way to construct complex table configurations
    6:  * through method chaining.
    7:  * 
    8:  * Features:
    9:  * - Fluent API for schema construction
   10:  * - Type-safe column definitions
   11:  * - Method chaining for intuitive configuration
   12:  * - Comprehensive column customization
   13:  * - Built-in validation and normalization
   14:  * 
   15:  * @module data-table/schema/schema-builder
   16:  */
   17: 
   18: import { DataTableSchema, DataTableColumnDef, ColumnFilter } from "../types"
   19: import { createDataTableSchema } from "./schema-utils"
   20: import { AggregationFunctionType } from "../aggregation"
   21: 
   22: /**
   23:  * Schema Builder Class
   24:  * 
   25:  * A fluent API class for building data table schemas. Provides methods for
   26:  * configuring columns, filters, grouping, sorting, and other table features
   27:  * through method chaining.
   28:  * 
   29:  * @template TData - The type of data in the table
   30:  * 
   31:  * @example
   32:  * ```tsx
   33:  * const schema = createTableSchema<User>()
   34:  *   .addColumn({
   35:  *     id: 'name',
   36:  *     header: 'Name',
   37:  *     accessorKey: 'name'
   38:  *   })
   39:  *   .addColumn({
   40:  *     id: 'age',
   41:  *     header: 'Age',
   42:  *     accessorKey: 'age'
   43:  *   })
   44:  *   .enableGrouping(['name'])
   45:  *   .setPagination(true, 25)
   46:  *   .build()
   47:  * ```
   48:  */
   49: export class SchemaBuilder<TData> {
   50:   private schema: Partial<DataTableSchema<TData>> = {
   51:     columns: [],
   52:     defaultSorting: [],
   53:     defaultGrouping: [],
   54:     defaultColumnVisibility: {},
   55:   }
   56: 
   57:   /**
   58:    * Adds a single column to the schema
   59:    * 
   60:    * @param column - The column definition to add
   61:    * @returns The builder instance for method chaining
   62:    */
   63:   addColumn(column: DataTableColumnDef<TData>): SchemaBuilder<TData> {
   64:     this.schema.columns = [...(this.schema.columns || []), column]
   65:     return this
   66:   }
   67: 
   68:   /**
   69:    * Adds multiple columns to the schema
   70:    * 
   71:    * @param columns - Array of column definitions to add
   72:    * @returns The builder instance for method chaining
   73:    */
   74:   addColumns(columns: DataTableColumnDef<TData>[]): SchemaBuilder<TData> {
   75:     this.schema.columns = [...(this.schema.columns || []), ...columns]
   76:     return this
   77:   }
   78: 
   79:   /**
   80:    * Enables grouping for specific columns
   81:    * 
   82:    * @param columnIds - Array of column IDs to enable grouping for
   83:    * @returns The builder instance for method chaining
   84:    */
   85:   enableGrouping(columnIds: string[]): SchemaBuilder<TData> {
   86:     this.schema.enableGrouping = true
   87:     
   88:     // Mark specific columns as groupable
   89:     if (this.schema.columns) {
   90:       this.schema.columns = this.schema.columns.map(column => {
   91:         const id = column.id || column.accessorKey as string
   92:         if (id && columnIds.includes(id)) {
   93:           return { ...column, enableGrouping: true }
   94:         }
   95:         return column
   96:       })
   97:     }
   98:     
   99:     return this
  100:   }
  101: 
  102:   /**
  103:    * Adds a filter to a specific column
  104:    * 
  105:    * @param columnId - The ID of the column to add the filter to
  106:    * @param filter - The filter configuration
  107:    * @returns The builder instance for method chaining
  108:    */
  109:   addFilter(columnId: string, filter: ColumnFilter): SchemaBuilder<TData> {
  110:     if (this.schema.columns) {
  111:       this.schema.columns = this.schema.columns.map(column => {
  112:         const id = column.id || column.accessorKey as string
  113:         if (id === columnId) {
  114:           return { ...column, filter }
  115:         }
  116:         return column
  117:       })
  118:     }
  119:     
  120:     return this
  121:   }
  122: 
  123:   /**
  124:    * Sets an aggregation function for a column
  125:    * 
  126:    * @param columnId - The ID of the column to set aggregation for
  127:    * @param aggregationType - The type of aggregation function to use
  128:    * @param aggregationRendererType - Optional type for the aggregation cell renderer
  129:    * @param aggregationRendererConfig - Optional configuration for the aggregation cell renderer
  130:    * @returns The builder instance for method chaining
  131:    */
  132:   setAggregation(
  133:     columnId: string,
  134:     aggregationType: AggregationFunctionType,
  135:     aggregationRendererType?: string,
  136:     aggregationRendererConfig?: Record<string, unknown>
  137:   ): SchemaBuilder<TData> {
  138:     if (this.schema.columns) {
  139:       this.schema.columns = this.schema.columns.map(column => {
  140:         const id = column.id || column.accessorKey as string
  141:         if (id === columnId) {
  142:           // Construct the aggregationRenderer object only if a type is provided
  143:           const aggregationRenderer = aggregationRendererType
  144:             ? {
  145:                 type: aggregationRendererType,
  146:                 ...(aggregationRendererConfig ? { config: aggregationRendererConfig } : {})
  147:               }
  148:             : undefined; // Set to undefined if no type is given
  149: 
  150:           return {
  151:             ...column,
  152:             aggregationType, // Keep the aggregation function type
  153:             ...(aggregationRenderer ? { aggregationRenderer } : {}) // Add the renderer object conditionally
  154:           };
  155:         }
  156:         return column;
  157:       });
  158:     }
  159: 
  160:     return this;
  161:   }
  162: 
  163:   /**
  164:    * Sets a cell renderer for a column
  165:    * 
  166:    * @param columnId - The ID of the column to set the renderer for
  167:    * @param rendererType - The type of renderer to use
  168:    * @param config - Optional configuration for the renderer
  169:    * @returns The builder instance for method chaining
  170:    */
  171:   setCellRenderer(
  172:     columnId: string,
  173:     rendererType: string,
  174:     config?: Record<string, unknown>
  175:   ): SchemaBuilder<TData> {
  176:     if (this.schema.columns) {
  177:       this.schema.columns = this.schema.columns.map(column => {
  178:         const id = column.id || column.accessorKey as string
  179:         if (id === columnId) {
  180:           return { 
  181:             ...column, 
  182:             cellRenderer: {
  183:               type: rendererType,
  184:               ...(config ? { config } : {})
  185:             }
  186:           }
  187:         }
  188:         return column
  189:       })
  190:     }
  191:     
  192:     return this
  193:   }
  194: 
  195:   /**
  196:    * Sets the default sorting state
  197:    * 
  198:    * @param sortingState - Array of sorting configurations
  199:    * @returns The builder instance for method chaining
  200:    */
  201:   setDefaultSorting(sortingState: { id: string, desc: boolean }[]): SchemaBuilder<TData> {
  202:     this.schema.defaultSorting = sortingState
  203:     return this
  204:   }
  205: 
  206:   /**
  207:    * Sets the default grouping state
  208:    * 
  209:    * @param groupingState - Array of column IDs to group by
  210:    * @returns The builder instance for method chaining
  211:    */
  212:   setDefaultGrouping(groupingState: string[]): SchemaBuilder<TData> {
  213:     this.schema.defaultGrouping = groupingState
  214:     return this
  215:   }
  216: 
  217:   /**
  218:    * Configures pagination settings
  219:    * 
  220:    * @param enabled - Whether to enable pagination
  221:    * @param defaultPageSize - Optional default page size
  222:    * @returns The builder instance for method chaining
  223:    */
  224:   setPagination(enabled: boolean, defaultPageSize?: number): SchemaBuilder<TData> {
  225:     this.schema.enablePagination = enabled
  226:     if (defaultPageSize) {
  227:       this.schema.defaultPageSize = defaultPageSize
  228:     }
  229:     return this
  230:   }
  231: 
  232:   /**
  233:    * Sets the default column visibility state
  234:    * 
  235:    * @param visibility - Object mapping column IDs to visibility states
  236:    * @returns The builder instance for method chaining
  237:    */
  238:   setColumnVisibility(visibility: Record<string, boolean>): SchemaBuilder<TData> {
  239:     this.schema.defaultColumnVisibility = visibility
  240:     return this
  241:   }
  242: 
  243:   /**
  244:    * Enables or disables the global filter
  245:    * 
  246:    * @param enabled - Whether to enable the global filter
  247:    * @returns The builder instance for method chaining
  248:    */
  249:   setGlobalFilter(enabled: boolean): SchemaBuilder<TData> {
  250:     this.schema.enableGlobalFilter = enabled
  251:     return this
  252:   }
  253: 
  254:   /**
  255:    * Builds and returns the final schema
  256:    * 
  257:    * @returns The completed DataTableSchema
  258:    */
  259:   build(): DataTableSchema<TData> {
  260:     return createDataTableSchema(this.schema)
  261:   }
  262: }
  263: 
  264: /**
  265:  * Creates a new schema builder instance
  266:  * 
  267:  * @template TData - The type of data in the table
  268:  * @returns A new SchemaBuilder instance
  269:  * 
  270:  * @example
  271:  * ```tsx
  272:  * const builder = createTableSchema<User>()
  273:  * ```
  274:  */
  275: export function createTableSchema<TData>(): SchemaBuilder<TData> {
  276:   return new SchemaBuilder<TData>()
  277: } 

================================================================================
File: schema/schema-utils.ts
================================================================================

    1: /**
    2:  * Schema Utilities Module
    3:  * 
    4:  * This module provides utility functions for working with data table schemas.
    5:  * It includes functions for schema creation, column filtering, and grouping
    6:  * configuration.
    7:  * 
    8:  * Features:
    9:  * - Schema creation and normalization
   10:  * - Column filtering configuration
   11:  * - Grouping column extraction
   12:  * - Type-safe schema manipulation
   13:  * 
   14:  * @module data-table/schema/schema-utils
   15:  */
   16: 
   17: import { DataTableSchema } from "../types"
   18: import { hasAccessorKey } from "../utils"
   19: 
   20: /**
   21:  * Creates a complete DataTable schema from partial options
   22:  * 
   23:  * This function normalizes and completes a partial schema configuration,
   24:  * providing default values for optional properties and ensuring type safety.
   25:  * 
   26:  * @template TData - The type of data in the table
   27:  * @param options - Partial schema configuration
   28:  * @returns Complete DataTableSchema with defaults applied
   29:  * 
   30:  * @example
   31:  * ```tsx
   32:  * const schema = createDataTableSchema({
   33:  *   columns: [
   34:  *     { id: 'name', header: 'Name' },
   35:  *     { id: 'age', header: 'Age' }
   36:  *   ],
   37:  *   enablePagination: true,
   38:  *   defaultPageSize: 25
   39:  * })
   40:  * ```
   41:  */
   42: export function createDataTableSchema<TData>(
   43:   options: Partial<DataTableSchema<TData>>
   44: ): DataTableSchema<TData> {
   45:   // Explicitly convert enablePagination to boolean
   46:   const paginationEnabled = options.enablePagination !== false
   47:   
   48:   return {
   49:     columns: options.columns || [],
   50:     defaultSorting: options.defaultSorting || [],
   51:     defaultGrouping: options.defaultGrouping || [],
   52:     defaultColumnVisibility: options.defaultColumnVisibility || {},
   53:     enableGrouping: options.enableGrouping !== false,
   54:     enableGlobalFilter: options.enableGlobalFilter !== false,
   55:     enablePagination: paginationEnabled,
   56:     defaultPageSize: options.defaultPageSize || 10,
   57:   }
   58: }
   59: 
   60: /**
   61:  * Extracts groupable column IDs from a schema
   62:  * 
   63:  * This function identifies columns that are enabled for grouping and returns
   64:  * their IDs. It handles both direct ID references and accessorKey-based columns.
   65:  * 
   66:  * @template TData - The type of data in the table
   67:  * @param schema - The DataTable schema
   68:  * @returns Array of groupable column IDs
   69:  * 
   70:  * @example
   71:  * ```tsx
   72:  * const groupableColumns = getGroupableColumns(schema)
   73:  * // Returns: ['category', 'status']
   74:  * ```
   75:  */
   76: export function getGroupableColumns<TData>(schema: DataTableSchema<TData>): string[] {
   77:   return schema.columns
   78:     .filter(column => column.enableGrouping)
   79:     .map(column => column.id || (hasAccessorKey(column) ? column.accessorKey : ''))
   80:     .filter(Boolean)
   81: }
   82: 
   83: /**
   84:  * Extracts column filter configurations from a schema
   85:  * 
   86:  * This function processes the schema to identify columns with filter configurations
   87:  * and returns a normalized array of filter settings. It supports multiple filter
   88:  * types and handles various configuration options.
   89:  * 
   90:  * @template TData - The type of data in the table
   91:  * @param schema - The DataTable schema
   92:  * @returns Array of column filter configurations
   93:  * 
   94:  * @example
   95:  * ```tsx
   96:  * const filters = getColumnFilters(schema)
   97:  * // Returns: [
   98:  * //   {
   99:  * //     type: 'select',
  100:  * //     column: 'status',
  101:  * //     label: 'Status',
  102:  * //     options: [
  103:  * //       { label: 'Active', value: 'active' },
  104:  * //       { label: 'Inactive', value: 'inactive' }
  105:  * //     ]
  106:  * //   }
  107:  * // ]
  108:  * ```
  109:  */
  110: export function getColumnFilters<TData>(schema: DataTableSchema<TData>): {
  111:   type: 'select' | 'multi-select' | 'range' | 'date-range' | 'boolean'
  112:   column: string
  113:   label: string
  114:   options?: { label: string, value: string }[]
  115:   min?: number | string
  116:   max?: number | string
  117:   getOptionsFromData?: boolean
  118: }[] {
  119:   return schema.columns
  120:     .filter(column => column.filter)
  121:     .map(column => {
  122:       const columnId = column.id || (hasAccessorKey(column) ? column.accessorKey : '')
  123:       const columnLabel = typeof column.header === 'string' ? column.header : columnId
  124:       
  125:       if (column.filter?.type === 'select') {
  126:         return {
  127:           type: 'select' as const,
  128:           column: columnId,
  129:           label: columnLabel,
  130:           options: column.filter.options,
  131:           getOptionsFromData: column.filter.getOptionsFromData !== false && !column.filter.options?.length
  132:         }
  133:       } else if (column.filter?.type === 'multi-select') {
  134:         return {
  135:           type: 'multi-select' as const,
  136:           column: columnId,
  137:           label: columnLabel,
  138:           options: column.filter.options,
  139:           getOptionsFromData: column.filter.getOptionsFromData !== false && !column.filter.options?.length
  140:         }
  141:       } else if (column.filter?.type === 'range') {
  142:         return {
  143:           type: 'range' as const,
  144:           column: columnId,
  145:           label: columnLabel,
  146:           min: column.filter.min,
  147:           max: column.filter.max
  148:         }
  149:       } else if (column.filter?.type === 'date-range') {
  150:         return {
  151:           type: 'date-range' as const,
  152:           column: columnId,
  153:           label: columnLabel,
  154:           min: column.filter.min,
  155:           max: column.filter.max
  156:         }
  157:       } else if (column.filter?.type === 'boolean') {
  158:         return {
  159:           type: 'boolean' as const,
  160:           column: columnId,
  161:           label: columnLabel,
  162:         }
  163:       }
  164:       
  165:       return null
  166:     })
  167:     .filter(Boolean) as Array<{
  168:       type: 'select' | 'multi-select' | 'range' | 'date-range' | 'boolean'
  169:       column: string
  170:       label: string
  171:       options?: { label: string, value: string }[]
  172:       min?: number | string
  173:       max?: number | string
  174:       getOptionsFromData?: boolean
  175:     }>
  176: } 

================================================================================
File: schema/serialization.ts
================================================================================

    1: /**
    2:  * Schema Serialization Module
    3:  * 
    4:  * This module provides functions for serializing and deserializing data table schemas.
    5:  * It enables storing table configurations in databases or other storage systems and
    6:  * restoring them to their runtime form.
    7:  * 
    8:  * Features:
    9:  * - Schema serialization to JSON-compatible format
   10:  * - Schema deserialization with runtime restoration
   11:  * - Cell renderer registry integration
   12:  * - Aggregation function restoration
   13:  * - Type-safe serialization/deserialization
   14:  * 
   15:  * @module data-table/schema/serialization
   16:  */
   17: 
   18: import { DataTableSchema, SerializableDataTableSchema, DataTableColumnDef, SerializableColumnDef } from "../types"
   19: import { CellRendererFunction } from "../cell-renderers"
   20: import { getGlobalAggregationFunctionRegistry } from "../aggregation"
   21: 
   22: // Define a minimal type for the registry based on usage
   23: interface CellRendererRegistry {
   24:   get: (type: string) => CellRendererFunction | undefined;
   25: }
   26: 
   27: /**
   28:  * Serializes a runtime schema to a JSON-compatible format
   29:  * 
   30:  * This function converts a runtime schema into a format that can be safely stored
   31:  * in a database or transmitted over a network. It handles complex types like
   32:  * functions and objects by converting them to serializable representations.
   33:  * 
   34:  * @template TData - The type of data in the table
   35:  * @param schema - The runtime schema to serialize
   36:  * @returns A serializable version of the schema
   37:  * 
   38:  * @example
   39:  * ```tsx
   40:  * const runtimeSchema = {
   41:  *   columns: [
   42:  *     {
   43:  *       id: 'name',
   44:  *       header: 'Name',
   45:  *       cellRenderer: { type: 'badge', config: { color: 'blue' } }
   46:  *     }
   47:  *   ]
   48:  * }
   49:  * 
   50:  * const serialized = serializeSchema(runtimeSchema)
   51:  * // Can now be stored in a database
   52:  * ```
   53:  */
   54: export function serializeSchema<TData>(schema: DataTableSchema<TData>): SerializableDataTableSchema {
   55:   return {
   56:     ...schema,
   57:     columns: schema.columns.map(column => {
   58:       const serializedColumn: SerializableColumnDef = {
   59:         id: column.id,
   60:         accessorKey: column.accessorKey,
   61:         header: typeof column.header === 'string' ? column.header : undefined,
   62:         enableGrouping: column.enableGrouping,
   63:         enableSorting: column.enableSorting,
   64:         alignment: column.alignment,
   65:         filter: column.filter,
   66:         cellRenderer: column.cellRenderer,
   67:         aggregationType: column.aggregationType,
   68:         aggregationRenderer: column.aggregationRenderer
   69:       }
   70:       
   71:       return serializedColumn
   72:     })
   73:   }
   74: }
   75: 
   76: /**
   77:  * Deserializes a stored schema back to its runtime form
   78:  * 
   79:  * This function converts a serialized schema back into a runtime schema with
   80:  * all functions and complex types restored. It uses registries to restore
   81:  * cell renderers and aggregation functions.
   82:  * 
   83:  * @template TData - The type of data in the table
   84:  * @param serialized - The serialized schema to restore
   85:  * @param registry - The cell renderer registry to use for restoration
   86:  * @returns The restored runtime schema
   87:  * 
   88:  * @example
   89:  * ```tsx
   90:  * const serializedSchema = {
   91:  *   columns: [
   92:  *     {
   93:  *       id: 'name',
   94:  *       header: 'Name',
   95:  *       cellRenderer: { type: 'badge', config: { color: 'blue' } }
   96:  *     }
   97:  *   ]
   98:  * }
   99:  * 
  100:  * const runtimeSchema = deserializeSchema(serializedSchema, cellRendererRegistry)
  101:  * // Can now be used with the data table
  102:  * ```
  103:  */
  104: export function deserializeSchema<TData>(
  105:   serialized: SerializableDataTableSchema,
  106:   registry: CellRendererRegistry
  107: ): DataTableSchema<TData> {
  108:   // Get aggregation registry
  109:   const aggregationRegistry = getGlobalAggregationFunctionRegistry()
  110:   
  111:   return {
  112:     ...serialized,
  113:     columns: serialized.columns.map(col => {
  114:       const column: DataTableColumnDef<TData> = {
  115:         ...col
  116:       }
  117:       
  118:       // Convert cell renderer type back to function
  119:       if (col.cellRenderer) {
  120:         const renderer = registry.get(col.cellRenderer.type)
  121:         if (renderer) {
  122:           // Pass the cell context to the renderer after casting
  123:           column.cell = (props) => {
  124:             // Cast the props to a compatible format for our renderers
  125:             return renderer({
  126:               getValue: props.getValue,
  127:               row: {
  128:                 getValue: (colId: string) => props.row.getValue(colId),
  129:               },
  130:               column: {
  131:                 id: props.column.id,
  132:               }
  133:             }, col.cellRenderer?.config as Record<string, unknown>)
  134:           }
  135:         }
  136:       }
  137:       
  138:       // Set aggregation function if aggregationType is specified
  139:       if (col.aggregationType) {
  140:         const aggregationFn = aggregationRegistry.get(col.aggregationType)
  141:         if (aggregationFn) {
  142:           column.aggregationFn = (columnId, leafRows, childRows) => 
  143:             aggregationFn(columnId, leafRows, childRows, col.aggregationRenderer?.config)
  144:         }
  145:       }
  146:       
  147:       return column
  148:     })
  149:   }
  150: } 

================================================================================
File: types.ts
================================================================================

    1: /**
    2:  * Data Table Types Module
    3:  * 
    4:  * This module contains all type definitions used across the data table components.
    5:  * It centralizes types to avoid duplication and ensure consistency throughout the codebase.
    6:  * 
    7:  * Key Type Categories:
    8:  * - Filter Types: Define various filter configurations (select, multi-select, range, etc.)
    9:  * - Column Types: Define column structure and behavior
   10:  * - Schema Types: Define table structure and configuration
   11:  * - Context Types: Define state management and context values
   12:  * - Serialization Types: Define serializable versions of complex types
   13:  * 
   14:  * Features:
   15:  * - Type-safe filter configurations
   16:  * - Flexible column definitions
   17:  * - Comprehensive schema structure
   18:  * - Serializable data structures
   19:  * - Type guards for runtime type checking
   20:  * 
   21:  * @module data-table-types
   22:  */
   23: 
   24: import { ColumnDef, ColumnFiltersState, SortingState, VisibilityState, GroupingState, ExpandedState, HeaderContext } from "@tanstack/react-table"
   25: import * as React from "react"
   26: import { AggregationFunctionType } from "./aggregation"
   27: 
   28: /**
   29:  * Filter Option Type
   30:  * 
   31:  * Represents a single option in a filter dropdown or selection.
   32:  * 
   33:  * @example
   34:  * ```typescript
   35:  * const options: FilterOption[] = [
   36:  *   { label: 'Active', value: 'active' },
   37:  *   { label: 'Inactive', value: 'inactive' }
   38:  * ];
   39:  * ```
   40:  */
   41: export interface FilterOption {
   42:   label: string
   43:   value: string
   44: }
   45: 
   46: /**
   47:  * Base Filter Type
   48:  * 
   49:  * Common properties shared by all filter types.
   50:  * 
   51:  * @example
   52:  * ```typescript
   53:  * const baseFilter: BaseFilter = {
   54:  *   type: 'select',
   55:  *   column: 'status'
   56:  * };
   57:  * ```
   58:  */
   59: export interface BaseFilter {
   60:   type: string;
   61:   column?: string;
   62: }
   63: 
   64: /**
   65:  * Select Filter Type
   66:  * 
   67:  * Represents a single-select filter configuration.
   68:  * 
   69:  * @example
   70:  * ```typescript
   71:  * const selectFilter: SelectFilter = {
   72:  *   type: 'select',
   73:  *   options: [
   74:  *     { label: 'Active', value: 'active' },
   75:  *     { label: 'Inactive', value: 'inactive' }
   76:  *   ]
   77:  * };
   78:  * ```
   79:  */
   80: export interface SelectFilter extends BaseFilter {
   81:   type: 'select';
   82:   options?: FilterOption[];
   83:   getOptionsFromData?: boolean;
   84: }
   85: 
   86: /**
   87:  * Multi-Select Filter Type
   88:  * 
   89:  * Represents a multi-select filter configuration.
   90:  * 
   91:  * @example
   92:  * ```typescript
   93:  * const multiSelectFilter: MultiSelectFilter = {
   94:  *   type: 'multi-select',
   95:  *   options: [
   96:  *     { label: 'Red', value: 'red' },
   97:  *     { label: 'Blue', value: 'blue' },
   98:  *     { label: 'Green', value: 'green' }
   99:  *   ]
  100:  * };
  101:  * ```
  102:  */
  103: export interface MultiSelectFilter extends BaseFilter {
  104:   type: 'multi-select';
  105:   options?: FilterOption[];
  106:   getOptionsFromData?: boolean;
  107: }
  108: 
  109: /**
  110:  * Numeric Range Filter Type
  111:  * 
  112:  * Represents a numeric range filter configuration.
  113:  * 
  114:  * @example
  115:  * ```typescript
  116:  * const rangeFilter: RangeFilter = {
  117:  *   type: 'range',
  118:  *   min: 0,
  119:  *   max: 100
  120:  * };
  121:  * ```
  122:  */
  123: export interface RangeFilter extends BaseFilter {
  124:   type: 'range';
  125:   min?: number;
  126:   max?: number;
  127: }
  128: 
  129: /**
  130:  * Date Range Filter Type
  131:  * 
  132:  * Represents a date range filter configuration.
  133:  * 
  134:  * @example
  135:  * ```typescript
  136:  * const dateRangeFilter: DateRangeFilter = {
  137:  *   type: 'date-range',
  138:  *   min: '2023-01-01',
  139:  *   max: '2023-12-31'
  140:  * };
  141:  * ```
  142:  */
  143: export interface DateRangeFilter extends BaseFilter {
  144:   type: 'date-range';
  145:   min?: string; // ISO date string
  146:   max?: string; // ISO date string
  147: }
  148: 
  149: /**
  150:  * Boolean Filter Type
  151:  * 
  152:  * Represents a boolean filter configuration.
  153:  * 
  154:  * @example
  155:  * ```typescript
  156:  * const booleanFilter: BooleanFilter = {
  157:  *   type: 'boolean',
  158:  *   value: true
  159:  * };
  160:  * ```
  161:  */
  162: export interface BooleanFilter extends BaseFilter {
  163:   type: 'boolean';
  164:   value?: boolean;
  165: }
  166: 
  167: /**
  168:  * Text filter configuration
  169:  * 
  170:  * Defines a text input filter that performs case-insensitive searches.
  171:  * 
  172:  * @example
  173:  * ```typescript
  174:  * const textFilter: TextFilter = {
  175:  *   type: 'text',
  176:  *   placeholder: 'Search name...',
  177:  *   debounceMs: 300
  178:  * };
  179:  * ```
  180:  */
  181: export interface TextFilter {
  182:   /** The filter type */
  183:   type: 'text'
  184:   /** Placeholder text for the input */
  185:   placeholder?: string
  186:   /** Debounce time in milliseconds */
  187:   debounceMs?: number
  188: }
  189: 
  190: /**
  191:  * Union type for all column filters
  192:  * 
  193:  * Represents any valid filter type that can be applied to a column.
  194:  * 
  195:  * @example
  196:  * ```typescript
  197:  * const filter: ColumnFilter = {
  198:  *   type: 'select',
  199:  *   options: [
  200:  *     { label: 'Active', value: 'active' }
  201:  *   ]
  202:  * };
  203:  * ```
  204:  */
  205: export type ColumnFilter = 
  206:   | SelectFilter 
  207:   | MultiSelectFilter 
  208:   | RangeFilter 
  209:   | DateRangeFilter
  210:   | BooleanFilter
  211:   | TextFilter
  212: 
  213: /**
  214:  * Type guard for SelectFilter
  215:  * 
  216:  * @param filter - The filter to check
  217:  * @returns true if the filter is a SelectFilter
  218:  */
  219: export function isSelectFilter(filter: ColumnFilter): filter is SelectFilter {
  220:   return filter.type === 'select';
  221: }
  222: 
  223: /**
  224:  * Type guard for MultiSelectFilter
  225:  * 
  226:  * @param filter - The filter to check
  227:  * @returns true if the filter is a MultiSelectFilter
  228:  */
  229: export function isMultiSelectFilter(filter: ColumnFilter): filter is MultiSelectFilter {
  230:   return filter.type === 'multi-select';
  231: }
  232: 
  233: /**
  234:  * Type guard for RangeFilter
  235:  * 
  236:  * @param filter - The filter to check
  237:  * @returns true if the filter is a RangeFilter
  238:  */
  239: export function isRangeFilter(filter: ColumnFilter): filter is RangeFilter {
  240:   return filter.type === 'range';
  241: }
  242: 
  243: /**
  244:  * Type guard for DateRangeFilter
  245:  * 
  246:  * @param filter - The filter to check
  247:  * @returns true if the filter is a DateRangeFilter
  248:  */
  249: export function isDateRangeFilter(filter: ColumnFilter): filter is DateRangeFilter {
  250:   return filter.type === 'date-range';
  251: }
  252: 
  253: /**
  254:  * Type guard for BooleanFilter
  255:  * 
  256:  * @param filter - The filter to check
  257:  * @returns true if the filter is a BooleanFilter
  258:  */
  259: export function isBooleanFilter(filter: ColumnFilter): filter is BooleanFilter {
  260:   return filter.type === 'boolean';
  261: }
  262: 
  263: /**
  264:  * Enhanced column definition that includes filtering and grouping metadata
  265:  * 
  266:  * Extends TanStack Table's ColumnDef with additional features:
  267:  * - Filter configuration
  268:  * - Grouping support
  269:  * - Cell alignment
  270:  * - Custom cell rendering
  271:  * - Aggregation support
  272:  * 
  273:  * @example
  274:  * ```typescript
  275:  * const column: DataTableColumnDef<User> = {
  276:  *   id: 'name',
  277:  *   header: 'Name',
  278:  *   accessorKey: 'name',
  279:  *   enableGrouping: true,
  280:  *   filter: {
  281:  *     type: 'select',
  282:  *     options: [
  283:  *       { label: 'John', value: 'John' },
  284:  *       { label: 'Jane', value: 'Jane' }
  285:  *     ]
  286:  *   }
  287:  * };
  288:  * ```
  289:  */
  290: export interface DataTableColumnDef<TData, TValue = unknown> extends Omit<ColumnDef<TData, TValue>, "id"> {
  291:   id?: string
  292:   accessorKey?: string
  293:   header?: string | ((context: HeaderContext<TData, unknown>) => React.ReactNode)
  294:   enableGrouping?: boolean
  295:   filter?: ColumnFilter
  296:   /**
  297:    * Optional alignment override that applies to both header and cells.
  298:    * When specified, this overrides the automatic alignment based on data types.
  299:    * Possible values: 'left' (default), 'center', 'right'
  300:    */
  301:   alignment?: 'left' | 'center' | 'right'
  302:   /**
  303:    * Cell renderer configuration
  304:    */
  305:   cellRenderer?: SerializableCellRenderer
  306:   /**
  307:    * Aggregation type to use when this column is aggregated
  308:    * Can be a standard TanStack aggregation function, a custom function from the registry,
  309:    * or a custom aggregation function
  310:    */
  311:   aggregationType?: AggregationFunctionType
  312:   /**
  313:    * Optional configuration for the aggregation function
  314:    */
  315:   aggregationRenderer?: SerializableCellRenderer
  316: }
  317: 
  318: /**
  319:  * Complete schema for a data table
  320:  * 
  321:  * Defines the structure and behavior of a data table, including:
  322:  * - Column definitions
  323:  * - Default sorting
  324:  * - Default grouping
  325:  * - Column visibility
  326:  * - Feature flags
  327:  * - Pagination settings
  328:  * 
  329:  * @example
  330:  * ```typescript
  331:  * const schema: DataTableSchema<User> = {
  332:  *   columns: [
  333:  *     { id: 'name', header: 'Name', accessorKey: 'name' },
  334:  *     { id: 'age', header: 'Age', accessorKey: 'age' }
  335:  *   ],
  336:  *   defaultSorting: [{ id: 'name', desc: false }],
  337:  *   enableGrouping: true,
  338:  *   enablePagination: true,
  339:  *   defaultPageSize: 10
  340:  * };
  341:  * ```
  342:  */
  343: export interface DataTableSchema<TData> {
  344:   columns: DataTableColumnDef<TData>[]
  345:   defaultSorting?: SortingState
  346:   defaultGrouping?: GroupingState
  347:   defaultColumnVisibility?: VisibilityState
  348:   enableGrouping?: boolean
  349:   enableGlobalFilter?: boolean
  350:   enablePagination?: boolean
  351:   enableExport?: boolean
  352:   defaultColumnOrder?: string[]
  353:   defaultPageSize?: number
  354:   /**
  355:    * Enable virtualization for improved performance with large datasets
  356:    * When true, the table will only render visible rows
  357:    * @default true
  358:    */
  359:   enableVirtualization?: boolean
  360:   /**
  361:    * Threshold of rows before virtualization is automatically enabled
  362:    * @default 100
  363:    */
  364:   virtualizationThreshold?: number
  365:   /**
  366:    * Height of each row in pixels for virtualization calculations
  367:    * @default 35
  368:    */
  369:   rowHeight?: number
  370:   /**
  371:    * Number of additional rows to render outside the visible area
  372:    * Higher values reduce blank space during scrolling but impact performance
  373:    * @default 10
  374:    */
  375:   virtualOverscan?: number
  376:   /**
  377:    * Height of the table container when virtualization is enabled
  378:    * Can be any valid CSS height value
  379:    * @default '400px'
  380:    */
  381:   tableHeight?: string
  382:   /**
  383:    * Enable adaptive sizing for the table using ResizeObserver
  384:    * When true, the table will automatically adjust to container size changes
  385:    * @default true
  386:    */
  387:   enableAdaptiveSizing?: boolean
  388:   /**
  389:    * Enable automatic column width adjustments based on content and container width
  390:    * When true, columns will resize to fit their content while respecting available space
  391:    * @default false
  392:    */
  393:   enableAdaptiveColumns?: boolean
  394:   /**
  395:    * Minimum column width in pixels when adaptive columns are enabled
  396:    * @default 50
  397:    */
  398:   minColumnWidth?: number
  399:   /**
  400:    * Frequency of resize checks in milliseconds
  401:    * Lower values are more responsive but impact performance
  402:    * Only applies when enableAdaptiveSizing is true
  403:    * @default 200
  404:    */
  405:   resizeThrottleMs?: number
  406:   /**
  407:    * Debounce time in milliseconds for filter inputs
  408:    * Controls how long to wait after typing before applying the filter
  409:    * @default 300
  410:    */
  411:   filterDebounceMs?: number
  412: }
  413: 
  414: /**
  415:  * Interface for the data table props
  416:  * 
  417:  * @example
  418:  * ```typescript
  419:  * const props: DataTableProps<User> = {
  420:  *   schema: userSchema,
  421:  *   data: users
  422:  * };
  423:  * ```
  424:  */
  425: export interface DataTableProps<TData> {
  426:   schema: DataTableSchema<TData>
  427:   data: TData[]
  428: }
  429: 
  430: /**
  431:  * Serializable cell renderer configuration
  432:  * 
  433:  * Defines a cell renderer that can be serialized and stored.
  434:  * 
  435:  * @example
  436:  * ```typescript
  437:  * const renderer: SerializableCellRenderer = {
  438:  *   type: 'progress',
  439:  *   config: { min: 0, max: 100 }
  440:  * };
  441:  * ```
  442:  */
  443: export interface SerializableCellRenderer {
  444:   type: string
  445:   config?: Record<string, unknown>
  446: }
  447: 
  448: /**
  449:  * Serializable version of a column definition
  450:  * 
  451:  * A simplified version of DataTableColumnDef that can be serialized.
  452:  * 
  453:  * @example
  454:  * ```typescript
  455:  * const column: SerializableColumnDef = {
  456:  *   id: 'name',
  457:  *   header: 'Name',
  458:  *   accessorKey: 'name',
  459:  *   enableGrouping: true
  460:  * };
  461:  * ```
  462:  */
  463: export interface SerializableColumnDef {
  464:   id?: string
  465:   accessorKey?: string
  466:   header?: string
  467:   enableGrouping?: boolean
  468:   enableSorting?: boolean
  469:   alignment?: 'left' | 'center' | 'right'
  470:   filter?: ColumnFilter
  471:   cellRenderer?: SerializableCellRenderer
  472:   /**
  473:    * Aggregation type to use when this column is aggregated
  474:    */
  475:   aggregationType?: AggregationFunctionType
  476:   /**
  477:    * Optional configuration for the aggregation function
  478:    */
  479:   aggregationRenderer?: SerializableCellRenderer
  480: }
  481: 
  482: /**
  483:  * Serializable version of a data table schema
  484:  * 
  485:  * A simplified version of DataTableSchema that can be serialized.
  486:  * 
  487:  * @example
  488:  * ```typescript
  489:  * const schema: SerializableDataTableSchema = {
  490:  *   columns: [
  491:  *     { id: 'name', header: 'Name', accessorKey: 'name' }
  492:  *   ],
  493:  *   defaultSorting: [{ id: 'name', desc: false }],
  494:  *   enableGrouping: true
  495:  * };
  496:  * ```
  497:  */
  498: export interface SerializableDataTableSchema {
  499:   columns: SerializableColumnDef[]
  500:   defaultSorting?: { id: string, desc: boolean }[]
  501:   defaultGrouping?: string[]
  502:   defaultColumnVisibility?: Record<string, boolean>
  503:   enableGrouping?: boolean
  504:   enableGlobalFilter?: boolean
  505:   enablePagination?: boolean
  506:   enableExport?: boolean
  507:   defaultPageSize?: number
  508: }
  509: 
  510: /**
  511:  * Interface for groupable column objects used in the GroupingPanel component
  512:  * 
  513:  * @example
  514:  * ```typescript
  515:  * const column: GroupableColumn = {
  516:  *   id: 'department',
  517:  *   label: 'Department'
  518:  * };
  519:  * ```
  520:  */
  521: export interface GroupableColumn {
  522:   id: string
  523:   label: string
  524:   isGroupable: boolean
  525: }
  526: 
  527: /**
  528:  * DataTable Context Value interface
  529:  * 
  530:  * Defines the shape of the context value provided by the DataTable context.
  531:  * Includes all state management functions and current state values.
  532:  * 
  533:  * @example
  534:  * ```typescript
  535:  * const context: DataTableContextValue<User> = {
  536:  *   schema: userSchema,
  537:  *   data: users,
  538:  *   sorting: [{ id: 'name', desc: false }],
  539:  *   setSorting: (sorting) => {},
  540:  *   columnFilters: [],
  541:  *   setColumnFilters: (filters) => {},
  542:  *   globalFilter: '',
  543:  *   setGlobalFilter: (filter) => {},
  544:  *   columnVisibility: {},
  545:  *   setColumnVisibility: (visibility) => {},
  546:  *   grouping: [],
  547:  *   setGrouping: (grouping) => {},
  548:  *   expanded: {},
  549:  *   setExpanded: (expanded) => {},
  550:  *   table: null,
  551:  *   isInitialized: true
  552:  * };
  553:  * ```
  554:  */
  555: export interface DataTableContextValue<TData> {
  556:   schema: DataTableSchema<TData>
  557:   data: TData[]
  558:   sorting: SortingState
  559:   setSorting: (sorting: SortingState) => void
  560:   columnFilters: ColumnFiltersState
  561:   setColumnFilters: (filters: ColumnFiltersState) => void
  562:   globalFilter: string
  563:   setGlobalFilter: (filter: string) => void
  564:   columnVisibility: VisibilityState
  565:   setColumnVisibility: (visibility: VisibilityState) => void
  566:   grouping: GroupingState
  567:   setGrouping: (grouping: GroupingState) => void
  568:   expanded: ExpandedState
  569:   setExpanded: (expanded: ExpandedState) => void
  570:   table: unknown // Will be strongly typed in the implementation
  571:   isInitialized: boolean
  572: } 

================================================================================
File: utils/column-helper.ts
================================================================================

    1: /**
    2:  * Column Helper Module
    3:  * 
    4:  * This module provides utility functions for creating and configuring table columns.
    5:  * It offers a type-safe and convenient way to define columns with various features
    6:  * like sorting, filtering, grouping, and aggregation.
    7:  * 
    8:  * @module column-helper
    9:  */
   10: 
   11: import * as React from "react";
   12: import { CellContext, ColumnDef, AccessorFn, AggregationFn } from "@tanstack/react-table";
   13: import { ColumnFilter, SerializableCellRenderer } from "../types";
   14: import { AggregationFunctionType } from "../aggregation";
   15: 
   16: /**
   17:  * Creates a single column definition with enhanced functionality.
   18:  * 
   19:  * This helper function provides a strongly-typed way to create column definitions
   20:  * with built-in support for common features and customizations.
   21:  * 
   22:  * Features:
   23:  * - Sorting (enabled by default)
   24:  * - Column visibility (enabled by default)
   25:  * - Grouping (opt-in)
   26:  * - Custom cell rendering
   27:  * - Column alignment
   28:  * - Filtering
   29:  * - Aggregation
   30:  * - Custom metadata
   31:  * 
   32:  * @template T The type of data in the table rows
   33:  * 
   34:  * @param options Configuration options for the column
   35:  * @param options.id Unique identifier for the column
   36:  * @param options.header Display text for the column header
   37:  * @param options.accessorKey Key path to access data in the row (e.g., 'user.name')
   38:  * @param options.accessorFn Custom function to access row data
   39:  * @param options.cell Custom cell renderer function
   40:  * @param options.enableSorting Whether sorting is enabled (default: true)
   41:  * @param options.enableHiding Whether column can be hidden (default: true)
   42:  * @param options.enableGrouping Whether grouping is enabled (default: false)
   43:  * @param options.alignment Text alignment within cells
   44:  * @param options.filter Column filter configuration
   45:  * @param options.aggregationType Type of aggregation to apply
   46:  * @param options.aggregationRenderer Custom renderer for aggregation
   47:  * @param options.meta Additional metadata for the column
   48:  * 
   49:  * @returns A configured column definition compatible with TanStack Table
   50:  * 
   51:  * @example
   52:  * ```tsx
   53:  * // Basic column
   54:  * createColumn<User>({
   55:  *   id: 'name',
   56:  *   header: 'Name',
   57:  *   accessorKey: 'name'
   58:  * })
   59:  * 
   60:  * // Advanced column with custom rendering and aggregation
   61:  * createColumn<Order>({
   62:  *   id: 'total',
   63:  *   header: 'Order Total',
   64:  *   accessorKey: 'total',
   65:  *   alignment: 'right',
   66:  *   aggregationType: 'sum',
   67:  *   cell: props => <CurrencyCell value={props.getValue()} />
   68:  * })
   69:  * ```
   70:  */
   71: export function createColumn<T>(options: {
   72:   id: string;
   73:   header: string;
   74:   accessorKey?: keyof T | string;
   75:   accessorFn?: (row: T) => unknown;
   76:   cell?: ((props: CellContext<T, unknown>) => React.ReactNode) | undefined;
   77:   enableSorting?: boolean;
   78:   enableHiding?: boolean;
   79:   enableGrouping?: boolean;
   80:   alignment?: 'left' | 'center' | 'right';
   81:   filter?: ColumnFilter;
   82:   aggregationType?: AggregationFunctionType;
   83:   aggregationRenderer?: SerializableCellRenderer;
   84:   meta?: Record<string, unknown>;
   85: }): ColumnDef<T, unknown> {
   86:   return {
   87:     id: options.id,
   88:     accessorKey: options.accessorKey as string,
   89:     accessorFn: options.accessorFn as AccessorFn<T, unknown> | undefined,
   90:     header: options.header,
   91:     cell: options.cell,
   92:     enableSorting: options.enableSorting !== false, // Enabled by default
   93:     enableHiding: options.enableHiding !== false,   // Enabled by default
   94:     enableGrouping: options.enableGrouping || false, // Disabled by default
   95:     // Type assertion to fix type compatibility with TanStack Table
   96:     aggregationFn: options.aggregationType as unknown as AggregationFn<T> | undefined,
   97:     meta: {
   98:       ...options.meta,
   99:       alignment: options.alignment,
  100:       filter: options.filter,
  101:       aggregationRenderer: options.aggregationRenderer,
  102:     },
  103:   };
  104: }
  105: 
  106: /**
  107:  * Creates multiple column definitions from an array of configurations.
  108:  * This is a convenience function for creating multiple columns at once.
  109:  * 
  110:  * @template T The type of data in the table rows
  111:  * @param columnsConfig Array of column configurations
  112:  * @returns Array of column definitions
  113:  * 
  114:  * @example
  115:  * ```tsx
  116:  * const columns = createColumns<User>([
  117:  *   {
  118:  *     id: 'name',
  119:  *     header: 'Name',
  120:  *     accessorKey: 'name'
  121:  *   },
  122:  *   {
  123:  *     id: 'email',
  124:  *     header: 'Email',
  125:  *     accessorKey: 'email'
  126:  *   }
  127:  * ])
  128:  * ```
  129:  */
  130: export function createColumns<T>(columnsConfig: Array<Parameters<typeof createColumn<T>>[0]>): ColumnDef<T, unknown>[] {
  131:   return columnsConfig.map(config => createColumn<T>(config));
  132: } 

================================================================================
File: utils/debounce.ts
================================================================================

    1: import * as React from "react";
    2: 
    3: /**
    4:  * Debounce utility
    5:  * 
    6:  * Creates a debounced version of a function that delays invocation until after
    7:  * `wait` milliseconds have elapsed since the last time it was invoked.
    8:  * 
    9:  * This is particularly useful for filter inputs to prevent excessive re-renders
   10:  * while the user is still typing.
   11:  * 
   12:  * @template T The function type to debounce
   13:  * @param func The function to debounce
   14:  * @param wait The number of milliseconds to delay
   15:  * @returns A debounced function
   16:  * 
   17:  * @example
   18:  * // Debounce a filter change handler
   19:  * const debouncedFilterChange = debounce((value: string) => {
   20:  *   setFilter(value);
   21:  * }, 300);
   22:  */
   23: export function debounce<T extends (...args: unknown[]) => unknown>(
   24:   func: T,
   25:   wait = 300
   26: ): (...args: Parameters<T>) => void {
   27:   let timeoutId: ReturnType<typeof setTimeout> | undefined;
   28:   
   29:   return function(...args: Parameters<T>): void {
   30:     // Clear previous timeout
   31:     if (timeoutId !== undefined) {
   32:       clearTimeout(timeoutId);
   33:     }
   34:     
   35:     // Set new timeout
   36:     timeoutId = setTimeout(() => {
   37:       func(...args);
   38:     }, wait);
   39:   };
   40: }
   41: 
   42: /**
   43:  * React hook version of debounce that properly memoizes the debounced function
   44:  * 
   45:  * This hook is designed to work with React's dependency system to ensure
   46:  * that the debounced function is only recreated when dependencies change.
   47:  * 
   48:  * @template T The function type to debounce
   49:  * @param callback The function to debounce
   50:  * @param delay The number of milliseconds to delay
   51:  * @param deps The dependencies array for the useMemo hook
   52:  * @returns A memoized debounced function
   53:  * 
   54:  * @example
   55:  * // In a React component
   56:  * const handleFilterChange = useDebounce((value: string) => {
   57:  *   column.setFilterValue(value);
   58:  * }, 300, [column]);
   59:  */
   60: export function useDebounce<T extends (...args: unknown[]) => unknown>(
   61:   callback: T,
   62:   delay = 300,
   63:   deps: React.DependencyList = []
   64: ): (...args: Parameters<T>) => void {
   65:   // eslint-disable-next-line react-hooks/exhaustive-deps
   66:   return React.useMemo(() => debounce(callback, delay), deps);
   67: } 

================================================================================
File: utils/index.ts
================================================================================

    1: /**
    2:  * Data Table Utilities Module
    3:  * 
    4:  * This module provides utility functions, helpers, and common tools used across
    5:  * the data table components. These utilities simplify common operations and
    6:  * provide consistent implementations of frequently needed functionality.
    7:  * 
    8:  * Key Components:
    9:  * - Column Helper: Utilities for creating and configuring column definitions
   10:  * - Type Utilities: Helper functions for type checking and validation
   11:  * - Data Processing: Functions for data transformation and manipulation
   12:  * 
   13:  * Features:
   14:  * - Type-safe utilities
   15:  * - Centralized implementations
   16:  * - Performance optimization
   17:  * - Consistent behavior
   18:  * 
   19:  * @module data-table/utils
   20:  */
   21: 
   22: export * from "./column-helper" 

================================================================================
File: utils.ts
================================================================================

    1: /**
    2:  * Data Table Utilities Module
    3:  * 
    4:  * This module provides utility functions used across the data table components.
    5:  * These utilities handle common operations like data manipulation, type checking,
    6:  * and data export functionality.
    7:  * 
    8:  * Key Features:
    9:  * - Data manipulation utilities
   10:  * - Type checking and guards
   11:  * - Column accessor management
   12:  * - CSV export functionality
   13:  * 
   14:  * @module data-table-utils
   15:  */
   16: 
   17: import { DataTableColumnDef, FilterOption } from "./types"
   18: 
   19: /**
   20:  * Gets unique values from an array
   21:  * 
   22:  * This function creates a new array containing only unique values from the input array.
   23:  * It uses the Set object to efficiently remove duplicates.
   24:  * 
   25:  * @template T - The type of values in the array
   26:  * @param values - The input array containing values (may include duplicates)
   27:  * @returns A new array containing only unique values
   28:  * 
   29:  * @example
   30:  * ```typescript
   31:  * const numbers = [1, 2, 2, 3, 3, 3];
   32:  * const uniqueNumbers = getUniqueValues(numbers); // [1, 2, 3]
   33:  * 
   34:  * const strings = ['a', 'b', 'a', 'c'];
   35:  * const uniqueStrings = getUniqueValues(strings); // ['a', 'b', 'c']
   36:  * ```
   37:  */
   38: export function getUniqueValues<T>(values: T[]): T[] {
   39:   return [...new Set(values)]
   40: }
   41: 
   42: /**
   43:  * Type guard to check if a column has accessorKey
   44:  * 
   45:  * This function checks if a column definition has a valid accessorKey property.
   46:  * It can be used to narrow down the type of a column definition in TypeScript.
   47:  * 
   48:  * @template TData - The type of data in the table
   49:  * @param column - The column definition to check
   50:  * @returns true if the column has a valid accessorKey property
   51:  * 
   52:  * @example
   53:  * ```typescript
   54:  * const column: DataTableColumnDef<User> = {
   55:  *   accessorKey: 'name',
   56:  *   header: 'Name'
   57:  * };
   58:  * 
   59:  * if (hasAccessorKey(column)) {
   60:  *   // TypeScript now knows column has accessorKey
   61:  *   const key = column.accessorKey; // string
   62:  * }
   63:  * ```
   64:  */
   65: export function hasAccessorKey<TData>(column: DataTableColumnDef<TData>): column is DataTableColumnDef<TData> & { accessorKey: string } {
   66:   return 'accessorKey' in column && typeof column.accessorKey === 'string'
   67: }
   68: 
   69: /**
   70:  * Helper function to extract unique values from data for a specific column
   71:  * 
   72:  * This function processes table data to extract unique values for a specific column,
   73:  * which can be used to populate filter options. It handles both single values and
   74:  * arrays of values, and converts all values to strings.
   75:  * 
   76:  * @template TData - The type of data in the table
   77:  * @param data - The array of data objects
   78:  * @param columnId - The ID of the column to extract values from
   79:  * @returns An array of FilterOption objects containing unique values
   80:  * 
   81:  * @example
   82:  * ```typescript
   83:  * const users = [
   84:  *   { id: 1, name: 'John', roles: ['admin', 'user'] },
   85:  *   { id: 2, name: 'Jane', roles: ['user'] },
   86:  *   { id: 3, name: 'Bob', roles: ['admin'] }
   87:  * ];
   88:  * 
   89:  * // Get unique names
   90:  * const nameOptions = getOptionsFromData(users, 'name');
   91:  * // [{ label: 'John', value: 'John' }, { label: 'Jane', value: 'Jane' }, ...]
   92:  * 
   93:  * // Get unique roles
   94:  * const roleOptions = getOptionsFromData(users, 'roles');
   95:  * // [{ label: 'admin', value: 'admin' }, { label: 'user', value: 'user' }]
   96:  * ```
   97:  */
   98: export function getOptionsFromData<TData>(
   99:   data: TData[], 
  100:   columnId: string
  101: ): FilterOption[] {
  102:   // Collect all values first, handling both single values and arrays
  103:   const allValues: string[] = []
  104:   
  105:   data.forEach(item => {
  106:     const value = (item as Record<string, unknown>)[columnId]
  107:     
  108:     if (value === undefined || value === null) {
  109:       return // Skip undefined or null values
  110:     }
  111:     
  112:     if (Array.isArray(value)) {
  113:       // If the value is an array, add each item individually
  114:       value.forEach(v => {
  115:         if (v !== undefined && v !== null) {
  116:           allValues.push(String(v))
  117:         }
  118:       })
  119:     } else {
  120:       // Otherwise add as a single value
  121:       allValues.push(String(value))
  122:     }
  123:   })
  124:   
  125:   // Get unique values
  126:   const uniqueValues = getUniqueValues(allValues)
  127:   
  128:   // Convert to FilterOption format
  129:   return uniqueValues.map(value => ({
  130:     label: value,
  131:     value: value
  132:   }))
  133: }
  134: 
  135: /**
  136:  * Get column ID from a column definition
  137:  * 
  138:  * This function extracts the ID of a column from its definition.
  139:  * It first checks for an explicit ID, then falls back to the accessorKey
  140:  * if available, and finally returns an empty string if neither exists.
  141:  * 
  142:  * @template TData - The type of data in the table
  143:  * @param column - The column definition
  144:  * @returns The column ID or an empty string if no ID is available
  145:  * 
  146:  * @example
  147:  * ```typescript
  148:  * const column1 = { id: 'name', accessorKey: 'fullName' };
  149:  * const id1 = getColumnId(column1); // 'name'
  150:  * 
  151:  * const column2 = { accessorKey: 'email' };
  152:  * const id2 = getColumnId(column2); // 'email'
  153:  * 
  154:  * const column3 = { header: 'Age' };
  155:  * const id3 = getColumnId(column3); // ''
  156:  * ```
  157:  */
  158: export function getColumnId<TData>(column: DataTableColumnDef<TData>): string {
  159:   return column.id || 
  160:     (hasAccessorKey(column) ? column.accessorKey : '')
  161: }
  162: 
  163: /**
  164:  * Exports table data to CSV and triggers download
  165:  * 
  166:  * This function converts table data to CSV format and triggers a download
  167:  * in the user's browser. It handles proper escaping of values containing
  168:  * commas, quotes, or newlines.
  169:  * 
  170:  * @template TData - The type of data in the table
  171:  * @param data - The array of data objects to export
  172:  * @param columns - Array of column definitions to determine which fields to export
  173:  * @param filename - Name of the CSV file to download (without extension)
  174:  * 
  175:  * @example
  176:  * ```typescript
  177:  * const users = [
  178:  *   { id: 1, name: 'John Doe', email: 'john@example.com' },
  179:  *   { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
  180:  * ];
  181:  * 
  182:  * const columns = [
  183:  *   { id: 'name', header: 'Full Name' },
  184:  *   { id: 'email', header: 'Email Address' }
  185:  * ];
  186:  * 
  187:  * exportToCSV(users, columns, 'users-export');
  188:  * // Downloads 'users-export.csv' with the data
  189:  * ```
  190:  */
  191: export function exportToCSV<TData>(
  192:   data: TData[],
  193:   columns: DataTableColumnDef<TData>[],
  194:   filename: string = 'table-export'
  195: ): void {
  196:   if (!data.length) {
  197:     console.warn('No data to export')
  198:     return
  199:   }
  200: 
  201:   // Get column headers and accessors
  202:   const columnHeaders: string[] = []
  203:   const columnAccessors: string[] = []
  204: 
  205:   columns.forEach(column => {
  206:     if (!column.id && !hasAccessorKey(column)) return
  207: 
  208:     // Get column header
  209:     const header = typeof column.header === 'string' 
  210:       ? column.header 
  211:       : getColumnId(column)
  212:     
  213:     // Get column accessor
  214:     const accessor = getColumnId(column)
  215:     
  216:     columnHeaders.push(header)
  217:     columnAccessors.push(accessor)
  218:   })
  219: 
  220:   // Create CSV content
  221:   let csvContent = columnHeaders.join(',') + '\n'
  222: 
  223:   // Add data rows
  224:   data.forEach(row => {
  225:     const rowData = columnAccessors.map(accessor => {
  226:       const value = (row as Record<string, unknown>)[accessor]
  227:       
  228:       if (value === null || value === undefined) {
  229:         return ''
  230:       }
  231:       
  232:       // Convert to string and escape if it contains commas, quotes, or newlines
  233:       const stringValue = String(value)
  234:       const needsQuotes = /[,"\n\r]/.test(stringValue)
  235:       
  236:       return needsQuotes 
  237:         ? `"${stringValue.replace(/"/g, '""')}"` // Escape quotes by doubling them
  238:         : stringValue
  239:     })
  240:     
  241:     csvContent += rowData.join(',') + '\n'
  242:   })
  243: 
  244:   // Create and trigger download
  245:   const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  246:   const url = URL.createObjectURL(blob)
  247:   const link = document.createElement('a')
  248:   
  249:   link.setAttribute('href', url)
  250:   link.setAttribute('download', `${filename}.csv`)
  251:   link.style.visibility = 'hidden'
  252:   
  253:   document.body.appendChild(link)
  254:   link.click()
  255:   document.body.removeChild(link)
  256: }
  257: 
  258: /**
  259:  * Formats an aggregation type name for display.
  260:  * Uses registry labels when available, falls back to camelCase formatting.
  261:  *
  262:  * @param type - The aggregation type string (e.g., 'sum', 'mean')
  263:  * @param aggregationRegistry - An instance of the aggregation function registry
  264:  * @returns A formatted string for display
  265:  */
  266: export function formatAggregationType(
  267:   type: string,
  268:   aggregationRegistry?: { getConfig: (type: string) => { label?: string } | undefined }
  269: ): string {
  270:   if (!type) return '';
  271: 
  272:   // Get from registry if possible for a more user-friendly name
  273:   if (aggregationRegistry) {
  274:     const config = aggregationRegistry.getConfig(type);
  275:     if (config?.label) return config.label;
  276:   }
  277: 
  278:   // Otherwise format from camelCase (e.g., 'totalCount' -> 'Total Count')
  279:   return type
  280:     .replace(/([A-Z])/g, ' $1') // Add space before capital letters
  281:     .replace(/^./, (str) => str.toUpperCase()); // Capitalize first letter
  282: } 

================================================================================
File: workers/table-worker.ts
================================================================================

    1: /**
    2:  * Table Data Web Worker
    3:  * 
    4:  * This worker handles computationally expensive operations for the data table:
    5:  * - Sorting
    6:  * - Filtering
    7:  * - Grouping
    8:  * - Aggregation
    9:  * 
   10:  * By performing these operations in a separate thread, the main UI thread
   11:  * remains responsive even when processing large datasets.
   12:  */
   13: 
   14: // Type definitions for messages
   15: type WorkerRequest = {
   16:   operation: 'sort' | 'filter' | 'group' | 'process';
   17:   data: Record<string, unknown>[];
   18:   params: {
   19:     columnId?: string;
   20:     desc?: boolean;
   21:     filters?: Array<{ id: string; value: unknown; type: string }>;
   22:     sorts?: Array<{ columnId: string; desc: boolean }>;
   23:   };
   24:   id?: string; // For identifying responses
   25: };
   26: 
   27: type WorkerResponse = {
   28:   result: Record<string, unknown>[];
   29:   operation: string;
   30:   id?: string; 
   31:   error?: string;
   32:   performance?: {
   33:     totalTime: number;
   34:     recordCount: number;
   35:   };
   36: };
   37: 
   38: type SortParams = {
   39:   columnId: string;
   40:   desc: boolean;
   41: };
   42: 
   43: type FilterParams = {
   44:   filters: Array<{ id: string; value: unknown; type: string }>;
   45: };
   46: 
   47: type ProcessParams = {
   48:   sorts?: Array<{ columnId: string; desc: boolean }>;
   49:   filters?: Array<{ id: string; value: unknown; type: string }>;
   50: };
   51: 
   52: type ProcessingResult = {
   53:   result: Record<string, unknown>[];
   54:   performance?: {
   55:     totalTime: number;
   56:     recordCount: number;
   57:   };
   58:   error?: string;
   59: };
   60: 
   61: /**
   62:  * Sort function that handles various data types
   63:  */
   64: function sortData(data: Record<string, unknown>[], params: SortParams): ProcessingResult {
   65:   const { columnId, desc } = params;
   66:   
   67:   // Start tracking performance
   68:   const startTime = performance.now();
   69:   
   70:   try {
   71:     // Clone the data to avoid modifications to the original
   72:     const clonedData = [...data];
   73:     
   74:     // Sort the array
   75:     const sorted = clonedData.sort((a, b) => {
   76:       // Extract values, handling potentially nested paths
   77:       let valueA = a[columnId];
   78:       let valueB = b[columnId];
   79:       
   80:       // Handle nested paths like "user.name"
   81:       if (columnId.includes('.')) {
   82:         const path = columnId.split('.');
   83:         valueA = path.reduce<unknown>((obj, key) => {
   84:           if (obj && typeof obj === 'object') {
   85:             return (obj as Record<string, unknown>)[key];
   86:           }
   87:           return undefined;
   88:         }, a);
   89:         valueB = path.reduce<unknown>((obj, key) => {
   90:           if (obj && typeof obj === 'object') {
   91:             return (obj as Record<string, unknown>)[key];
   92:           }
   93:           return undefined;
   94:         }, b);
   95:       }
   96:       
   97:       // Handle different value types
   98:       if (valueA === valueB) return 0;
   99:       
  100:       if (valueA === null || valueA === undefined) return desc ? 1 : -1;
  101:       if (valueB === null || valueB === undefined) return desc ? -1 : 1;
  102:       
  103:       // Date comparison
  104:       if (valueA instanceof Date && valueB instanceof Date) {
  105:         return desc ? valueB.getTime() - valueA.getTime() : valueA.getTime() - valueB.getTime();
  106:       }
  107:       
  108:       // Try to parse dates from strings
  109:       if (typeof valueA === 'string' && typeof valueB === 'string') {
  110:         const dateA = new Date(valueA);
  111:         const dateB = new Date(valueB);
  112:         if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
  113:           return desc ? dateB.getTime() - dateA.getTime() : dateA.getTime() - dateB.getTime();
  114:         }
  115:       }
  116:       
  117:       // Numeric comparison
  118:       if (typeof valueA === 'number' && typeof valueB === 'number') {
  119:         return desc ? valueB - valueA : valueA - valueB;
  120:       }
  121:       
  122:       // String comparison (case-insensitive)
  123:       if (typeof valueA === 'string' && typeof valueB === 'string') {
  124:         return desc 
  125:           ? valueB.localeCompare(valueA, undefined, { sensitivity: 'base' })
  126:           : valueA.localeCompare(valueB, undefined, { sensitivity: 'base' });
  127:       }
  128:       
  129:       // Boolean comparison
  130:       if (typeof valueA === 'boolean' && typeof valueB === 'boolean') {
  131:         return desc ? (valueB === valueA ? 0 : valueB ? -1 : 1) : (valueA === valueB ? 0 : valueA ? -1 : 1);
  132:       }
  133:       
  134:       // Fallback for mixed types
  135:       return desc 
  136:         ? String(valueB).localeCompare(String(valueA))
  137:         : String(valueA).localeCompare(String(valueB));
  138:     });
  139:     
  140:     // Calculate performance metrics
  141:     const endTime = performance.now();
  142:     
  143:     return {
  144:       result: sorted,
  145:       performance: {
  146:         totalTime: endTime - startTime,
  147:         recordCount: data.length
  148:       }
  149:     };
  150:   } catch (error) {
  151:     const errorMessage = error instanceof Error ? error.message : String(error);
  152:     return {
  153:       result: data, // Return original data on error
  154:       error: errorMessage,
  155:       performance: {
  156:         totalTime: performance.now() - startTime,
  157:         recordCount: data.length
  158:       }
  159:     };
  160:   }
  161: }
  162: 
  163: /**
  164:  * Filter function that supports multiple filter types
  165:  */
  166: function filterData(data: Record<string, unknown>[], params: FilterParams): ProcessingResult {
  167:   const { filters } = params;
  168:   
  169:   // Start tracking performance
  170:   const startTime = performance.now();
  171:   
  172:   try {
  173:     // If no filters, return the original data
  174:     if (!filters || filters.length === 0) {
  175:       return {
  176:         result: data,
  177:         performance: {
  178:           totalTime: 0,
  179:           recordCount: data.length
  180:         }
  181:       };
  182:     }
  183:     
  184:     // Apply all filters
  185:     const filtered = data.filter(row => {
  186:       // Item passes if it matches ALL filters (AND logic)
  187:       return filters.every(filter => {
  188:         const { id, value, type } = filter;
  189:         
  190:         // Get the value from the row
  191:         let rowValue = row[id];
  192:         
  193:         // Handle nested paths
  194:         if (id.includes('.')) {
  195:           const path = id.split('.');
  196:           rowValue = path.reduce<unknown>((obj, key) => {
  197:             if (obj && typeof obj === 'object') {
  198:               return (obj as Record<string, unknown>)[key];
  199:             }
  200:             return undefined;
  201:           }, row);
  202:         }
  203:         
  204:         // Different filtering logic based on filter type
  205:         switch (type) {
  206:           case 'text':
  207:             // Basic text search (case-insensitive)
  208:             return rowValue && String(rowValue).toLowerCase().includes(String(value).toLowerCase());
  209:             
  210:           case 'multi-select':
  211:             // Check if value is in the selected options
  212:             if (Array.isArray(value)) {
  213:               return value.length === 0 
  214:                 ? true // Empty selection means no filtering
  215:                 : value.includes(rowValue);
  216:             }
  217:             return true;
  218:             
  219:           case 'boolean':
  220:             // Boolean filtering
  221:             return value === undefined || value === null 
  222:               ? true 
  223:               : rowValue === value;
  224:               
  225:           case 'date-range':
  226:             // Date range filtering
  227:             if (!value || (typeof value === 'object' && !('from' in value) && !('to' in value))) return true;
  228:             
  229:             const dateValue = rowValue instanceof Date 
  230:               ? rowValue 
  231:               : new Date(String(rowValue));
  232:               
  233:             // Invalid date always fails the filter
  234:             if (isNaN(dateValue.getTime())) return false;
  235:             
  236:             // Check date is within range
  237:             const fromDate = value && typeof value === 'object' && 'from' in value && value.from 
  238:               ? new Date(String(value.from)) 
  239:               : null;
  240:             const toDate = value && typeof value === 'object' && 'to' in value && value.to 
  241:               ? new Date(String(value.to)) 
  242:               : null;
  243:             
  244:             let passes = true;
  245:             if (fromDate && !isNaN(fromDate.getTime())) {
  246:               passes = passes && dateValue >= fromDate;
  247:             }
  248:             if (toDate && !isNaN(toDate.getTime())) {
  249:               passes = passes && dateValue <= toDate;
  250:             }
  251:             return passes;
  252:             
  253:           case 'range':
  254:             // Numeric range filtering
  255:             if (!value || (typeof value === 'object' && !('min' in value) && !('max' in value))) return true;
  256:             
  257:             const numValue = typeof rowValue === 'number' 
  258:               ? rowValue 
  259:               : parseFloat(String(rowValue));
  260:               
  261:             // Invalid number always fails the filter
  262:             if (isNaN(numValue)) return false;
  263:             
  264:             // Check number is within range
  265:             let inRange = true;
  266:             if (value && typeof value === 'object' && 'min' in value && value.min !== undefined && value.min !== null) {
  267:               inRange = inRange && numValue >= Number(value.min);
  268:             }
  269:             if (value && typeof value === 'object' && 'max' in value && value.max !== undefined && value.max !== null) {
  270:               inRange = inRange && numValue <= Number(value.max);
  271:             }
  272:             return inRange;
  273:             
  274:           default:
  275:             // Default for unknown filter types
  276:             return true;
  277:         }
  278:       });
  279:     });
  280:     
  281:     // Calculate performance metrics
  282:     const endTime = performance.now();
  283:     
  284:     return {
  285:       result: filtered,
  286:       performance: {
  287:         totalTime: endTime - startTime,
  288:         recordCount: filtered.length
  289:       }
  290:     };
  291:   } catch (error) {
  292:     const errorMessage = error instanceof Error ? error.message : String(error);
  293:     return {
  294:       result: data, // Return original data on error
  295:       error: errorMessage,
  296:       performance: {
  297:         totalTime: performance.now() - startTime,
  298:         recordCount: data.length
  299:       }
  300:     };
  301:   }
  302: }
  303: 
  304: /**
  305:  * Process data with multiple operations (sort + filter)
  306:  */
  307: function processData(data: Record<string, unknown>[], params: ProcessParams): ProcessingResult {
  308:   const { sorts, filters } = params;
  309:   const startTime = performance.now();
  310:   
  311:   try {
  312:     let processedData = [...data];
  313:     let processingResult: ProcessingResult = { result: processedData };
  314:     
  315:     // Apply filters first to reduce the dataset
  316:     if (filters && filters.length > 0) {
  317:       processingResult = filterData(processedData, { filters });
  318:       processedData = processingResult.result;
  319:     }
  320:     
  321:     // Then apply sorting
  322:     if (sorts && sorts.length > 0) {
  323:       // Sort by multiple columns in order
  324:       for (const sort of sorts.reverse()) {
  325:         processingResult = sortData(processedData, sort);
  326:         processedData = processingResult.result;
  327:       }
  328:     }
  329:     
  330:     // Calculate performance metrics
  331:     const endTime = performance.now();
  332:     
  333:     return {
  334:       result: processedData,
  335:       performance: {
  336:         totalTime: endTime - startTime,
  337:         recordCount: processedData.length
  338:       }
  339:     };
  340:   } catch (error) {
  341:     const errorMessage = error instanceof Error ? error.message : String(error);
  342:     return {
  343:       result: data,
  344:       error: errorMessage,
  345:       performance: {
  346:         totalTime: performance.now() - startTime,
  347:         recordCount: data.length
  348:       }
  349:     };
  350:   }
  351: }
  352: 
  353: /**
  354:  * Main message handler for the worker
  355:  */
  356: self.onmessage = (event: MessageEvent<WorkerRequest>) => {
  357:   const { operation, data, params, id } = event.data;
  358:   let response: WorkerResponse;
  359:   
  360:   switch (operation) {
  361:     case 'sort':
  362:       const sortResult = sortData(data, params as SortParams);
  363:       response = {
  364:         operation,
  365:         result: sortResult.result,
  366:         performance: sortResult.performance,
  367:         error: sortResult.error,
  368:         id
  369:       };
  370:       break;
  371:       
  372:     case 'filter':
  373:       const filterResult = filterData(data, params as FilterParams);
  374:       response = {
  375:         operation,
  376:         result: filterResult.result,
  377:         performance: filterResult.performance,
  378:         error: filterResult.error,
  379:         id
  380:       };
  381:       break;
  382:       
  383:     case 'process':
  384:       const processResult = processData(data, params as ProcessParams);
  385:       response = {
  386:         operation,
  387:         result: processResult.result,
  388:         performance: processResult.performance,
  389:         error: processResult.error,
  390:         id
  391:       };
  392:       break;
  393:       
  394:     default:
  395:       response = {
  396:         operation,
  397:         result: data,
  398:         error: `Unsupported operation: ${operation}`,
  399:         id
  400:       };
  401:   }
  402:   
  403:   // Send back the response
  404:   self.postMessage(response);
  405: };
  406: 
  407: // Export an empty object to satisfy TypeScript module requirements
  408: export {}; 